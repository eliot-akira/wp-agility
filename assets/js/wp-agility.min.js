(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

window.$$ = require('./agility/index.js');
window.wp = window.wp || {};
window.wp.action = require('./wp/action.js');

},{"./agility/index.js":2,"./wp/action.js":18}],2:[function(require,module,exports){
/**
 * 
 * Agility.js - v0.2.2
 * 
 * Forked and extended from: Agility.js 0.1.3 by Artur B. Adib - http://agilityjs.com
 * 
 * Separated into CommonJS modules
 * 
 * Merged pull requests
 * - Support nested model properties
 * - Efficient handling of style
 * 
 * Extended features
 * - Only render changed model properties
 * - Form helpers
 * 
 */

/*jslint loopfunc: true */

(function(window, undefined){

  if (!window.jQuery) {
    throw "agility.js: jQuery not found";
  }
  
  // Local references
  var document = window.document,
      location = window.location,
      $        = jQuery,

      agility, // Main agility object builder

      util             = require('./util/util'),         // Internal utility functions
      shim             = require('./util/object-shim'),  // Object.create and getPrototypeOf
      timed            = require('./util/timed'),        // Timed functions
      defaultPrototype = require('./prototype/index'),   // Default object prototype
      idCounter        = 0; // Global object counter


  /*---------------------------------------------
   *
   * Main object constructor
   *
   */
  
  agility = function() {
    
    // Real array of arguments
    var args = Array.prototype.slice.call(arguments, 0),
    
    // Object to be returned by builder
    object = {},

    $root, // Used when template is from DOM

    prototype = defaultPrototype;


    /*---------------------------------------------
     *
     * Create object from prototype
     *
     */

    // If first arg is object, use it as prototype
    if (typeof args[0] === "object" && util.isAgility(args[0])) {

      prototype = args[0];    
      args.shift(); // remaining args now work as though object wasn't specified

    }

    // Build object from prototype as well as the individual prototype parts
    // This enables differential inheritance at the sub-object level, e.g. object.view.format
    object = Object.create(prototype);
    object.model = Object.create(prototype.model);
    object.view = Object.create(prototype.view);
    object.controller = Object.create(prototype.controller);
    object._container = Object.create(prototype._container);
    object._events = Object.create(prototype._events);


    // Instance properties, i.e. not inherited
    object._id = idCounter++;
    object._parent = null;
    object._events.data = {}; // event bindings will happen below
    object._container.children = {};
    object.view.$root = $(); // empty jQuery object


    // Clone own properties
    // i.e. properties that are inherited by direct copy instead of by prototype chain
    // This prevents children from altering parents models
    object.model._data = prototype.model._data ? $.extend(true, {}, prototype.model._data) : {};
    object._data = prototype._data ? $.extend(true, {}, prototype._data) : {};


    /*---------------------------------------------
     *
     * Extend model, view, controller based on given arguments
     *
     */

    // Just the default prototype {}
    if (args.length === 0) {
    }

    // ( view.format [,{ method:function, ... }] )
    else if ( typeof args[0] === 'string' ) {

      // Get template from '#id'
      if ( args[0][0] === '#' ) {

        $root = $(args[0]);

        // Template from script tag
        if ( $root.prop('tagName').toLowerCase() === 'script' ) {

          object.view.format = $root.html();

        // Template from existing DOM
        } else {

          // Include container itself
          object.view.format = $root.outerHTML();
          // Assign root to existing DOM element
          object.view.$root = $root;
          object._template = true;
        }

      }
      // or '<template>' string
      else object.view.format = args[0];

      // Controller from object
      if ( args.length > 1 && typeof args[1] === 'object') {
        $.extend(object.controller, args[1]);
        util.extendController(object);
      }

    } // single view arg

    // Prototype differential from single {model,view,controller} object
    else if (args.length === 1 && typeof args[0] === 'object' && (args[0].model || args[0].view) ) {

      for (var prop in args[0]) {

        if (prop === 'model') {

          $.extend(object.model._data, args[0].model);

        } else if (prop === 'view') {

          if (typeof args[0].view === 'string') {

            // Get template from '#id'
            if ( args[0].view[0] === '#' ) {

              $root = $(args[0].view);

              object.view.format = $root.html();

              // Template from script tag
              if ( $root.prop('tagName').toLowerCase() === 'script' ) {

                object.view.format = $root.html();

              // Template from existing DOM
              } else {

                // Include container itself
                object.view.format = $root.outerHTML();
                // Assign root to existing DOM element
                object.view.$root = $root;
                object._template = true;
              }

            }
            // or '<template>' string
            else object.view.format = args[0].view;

          } else {

            $.extend(object.view, args[0].view); // view:{format:{},style:{}}
          }

        }
        else if ( prop === 'controller' || prop === 'events' ) {
          $.extend(object.controller, args[0][prop]);
          util.extendController(object);
        }

        // User-defined methods
        else {
          object[prop] = args[0][prop];
        }
      }
    } // single {model, view, controller} arg

    // Prototype differential from separate {model}, {view}, {controller} arguments
    else {
      
      // Model object
      if (typeof args[0] === 'object') {
        $.extend(object.model._data, args[0]);
      }
      else if (args[0]) {
        throw "agility.js: unknown argument type (model)";
      }

      // View format from shorthand string (..., '<div>whatever</div>', ...)
      if (typeof args[1] === 'string') {

        // @extend Get template from ID
        if ( args[1][0] === '#' ) {

          // object.view.format = $(args[1]).html();

          $root = $(args[1]);

          // Template from script tag
          if ( $root.prop('tagName').toLowerCase() === 'script' ) {

            object.view.format = $root.html();

          // Template from existing DOM
          } else {

            // Include container itself
            object.view.format = $root.outerHTML();
            // Assign root to existing DOM element
            object.view.$root = $root;
            object._template = true;
          }
        }
        else
          object.view.format = args[1]; // extend view with .format
      }  
      // View from object (..., {format:'<div>whatever</div>'}, ...)
      else if (typeof args[1] === 'object') {
        $.extend(object.view, args[1]);
      }
      else if (args[1]) {
        throw "agility.js: unknown argument type (view)";
      }
      
      // View style from shorthand string (..., ..., 'p {color:red}', ...)

      if (typeof args[2] === 'string') {
        object.view.style = args[2];
        args.splice(2, 1); // so that controller code below works
      }

      // Controller from object (..., ..., {method:function(){}})
      if (typeof args[2] === 'object') {
        $.extend(object.controller, args[2]);
        util.extendController(object);
      }
      else if (args[2]) {
        throw "agility.js: unknown argument type (controller)";
      }
      
    } // separate ({model}, {view}, {controller}) args


    /*---------------------------------------------
     *
     * Launch sequence: Bindings, initializations, etc
     *
     */
    
    // Save model's initial state (so it can be .reset() later)
    object.model._initData = $.extend({}, object.model._data);

    // object.* will have their 'this' === object. This should come before call to object.* below.
    util.proxyAll(object, object);

  
    // Initialize $root, needed for DOM events binding below
    object.view.render();
  

    // Bind all controllers to their events

    var bindEvent = function(ev, handler){
      if (typeof handler === 'function') {
        object.bind(ev, handler);
      }
    };

    for (var eventStr in object.controller) {
      var events = eventStr.split(';');
      var handler = object.controller[eventStr];
      $.each(events, function(i, ev){
        ev = $.trim(ev);
        bindEvent(ev, handler);
      });
    }

    // Auto-triggers create event
    object.trigger('create');    
    
    return object;
    
  }; // agility



  /*---------------------------------------------
   *
   * Global properties
   *
   */

  
  // $$.document is a special Agility object, whose view is attached to <body>
  // This object is the main entry point for all DOM operations
  agility.document = agility({
    _document : true,
    view: {
      $: function(selector){ return selector ? $(selector, 'body') : $('body'); }
    },
    controller: {
      // Override default controller (don't render, don't stylize, etc)
      _create: function(){}
    }
  });

  // Shortcut to prototype for plugins
  agility.fn = defaultPrototype;

  // Namespace to declare reusable Agility objects
  // Use: app.append( $$.module.something ) or $$( $$.module.something, {m,v,c} )
  agility.module = {};

  // isAgility test
  agility.isAgility = function(obj) {
    if (typeof obj !== 'object') return false;
    return util.isAgility(obj);
  };


  /*---------------------------------------------
   *
   * Export it
   *
   */

  // AMD, CommonJS, then global
  if (typeof define === 'function' && define.amd) {
    // @todo Is this correct?
    define([], function(){
        return agility;
    });
  } else if (typeof exports === 'object') {
      module.exports = agility;
  } else {
      window.$$ = agility;
  }

})(window);

},{"./prototype/index":13,"./util/object-shim":15,"./util/timed":16,"./util/util":17}],3:[function(require,module,exports){

/*---------------------------------------------
 *
 * Controller
 *
 *  Default controllers, i.e. event handlers. Event handlers that start
 *  with '_' are of internal use only, and take precedence over any other
 *  handler without that prefix. See: trigger()
 *
 */

module.exports = {

  // Triggered after self creation
  _create: function(event){
    this.view.stylize();
    this.view.bindings(); // Model-View bindings
    this.view.sync(); // syncs View with Model
  },

  // Triggered upon removing self
  _destroy: function(event){

    // @pull #95 Remove generated style upon destruction of objects
    // @extend Only if using style attribute

    if (this.view.style) {
      var objClass = 'agility_' + this._id;
      $('head #'+objClass, window.document).remove();
    }

    // destroy any appended agility objects
    this._container.empty();

    // destroy self
    this.view.$().remove();
  },

  // Triggered after child obj is appended to container
  _append: function(event, obj, selector){
    this.view.$(selector).append(obj.view.$());
  },

  // Triggered after child obj is prepended to container
  _prepend: function(event, obj, selector){
    this.view.$(selector).prepend(obj.view.$());
  },

  // Triggered after child obj is inserted in the container
  _before: function(event, obj, selector){
    if (!selector) throw 'agility.js: _before needs a selector';
    this.view.$(selector).before(obj.view.$());
  },

  // Triggered after child obj is inserted in the container
  _after: function(event, obj, selector){
    if (!selector) throw 'agility.js: _after needs a selector';
    this.view.$(selector).after(obj.view.$());
  },

  // Triggered after a child obj is removed from container (or self-removed)
  _remove: function(event, id){        
  },

  // Triggered after model is changed
  '_change': function(event){
  }
  
};

},{}],4:[function(require,module,exports){
/*---------------------------------------------
 *
 * Get
 *
 */

module.exports = function get( arg ) {

  // Get whole model
  if (arg === undefined) {
    return this.model._data;
  }

  // Get attribute
  // @pull #91 Add support for nested models: parent.child
  if (typeof arg === 'string') {
    var paths = arg.split('.');
    var value = this.model._data[paths[0]];
    //check for nested objects
    if ($.isPlainObject(value)){
      for (var i = 1; i < paths.length; i++){
        if ($.isPlainObject(value) && value[paths[i]]){
          value = value[paths[i]];
        } else {
          value = value[paths.splice(i).join('.')];
        }
      }
    } else {
      //direct key access
      value = this.model._data[arg];
    }
    return value;
  }

  throw 'agility.js: unknown argument for getter';
};

},{}],5:[function(require,module,exports){
/*---------------------------------------------
 *
 * Set: set model attributes and trigger change events
 * 
 * @todo Performance considerations
 *
 */

module.exports = function set( arg, params, third ) {

  var self = this;
  var modified = []; // list of modified model attributes
  var previous = {}; // list of previous values

  // Set individual model property: model.set( prop, value )
  if ( typeof arg === 'string' && params ) {
    arg = { arg: params };
    params = third || {};
  }

  if ( typeof arg === 'object' ) {

    var _clone = {};

    if (params && params.reset) {
      _clone = this.model._data; // hold on to data for change events
      this.model._data = $.extend({}, arg); // erases previous model attributes without pointing to object
    }
    else {

      // @extend Compare and only trigger change event for modified keys
      _clone = $.extend({}, this.model._data);

      // @pull #91 Add support for nested models
      // Iterate through properties and find nested declarations

      for (var prop in arg){
        if (prop.indexOf('.') > -1){
          var path = prop.split('.');
          var current_node = this.model._data[path[0]];
          if (!current_node){
            current_node = this.model._data[path[0]] = {};
          }
          var next_node;
          for (var i = 1; i < path.length - 1; i++){
            next_node = current_node[path[i]];
            if ($.isPlainObject(next_node)){
             current_node = next_node;
            } else {
             current_node[path[i]] = {};
             current_node = current_node[path[i]];
            }
          }
          var last_property = path[path.length - 1];
         if ($.isPlainObject(arg[key]) && $.isPlainObject(current_node[last_property])){
           //if we're assigning objects, extend rather than replace
           $.extend(current_node[last_property], arg[prop]);
          } else {
           current_node[last_property] = arg[prop];
          }
          
          modified.push(prop);
          previous[prop] = _clone[prop];
          delete _clone[ prop ]; // no need to fire change twice
          delete arg[prop];
        }
      }

      $.extend(this.model._data, arg); // default is extend
    }

    // Given object

    for (var key in arg) {
      // Check if changed
      if (this.model._data[key] !== _clone[key] ) {
        modified.push(key);
        previous[key] = _clone[ key ];
      }
      delete _clone[ key ]; // no need to fire change twice
    }

    // Previous object

    for (key in _clone) {
      // Check if changed
      if (this.model._data[key] !== _clone[key] ) {
        modified.push(key);
        previous[key] = _clone[ key ];
      }
    }

  } else {

    // Not an object
    throw "agility.js: unknown argument type in model.set()";
  }

  // Tigger change events

  if (params && params.silent===true) return this; // do not fire events

  // @extend Pass array of modified model keys

  // $().trigger parses the second parameter as separate arguments,
  // so we put it in an array

  this.trigger('change', [modified, previous]);

  $.each(modified, function(index, key){
    self.trigger('change:'+key, previous[key]);
  });

  return this; // for chainable calls

};

},{}],6:[function(require,module,exports){

/*---------------------------------------------
 *
 * Validate model properties based on object.required
 *
 */

module.exports = {

  /*---------------------------------------------
   *
   * model.invalid()
   * 
   * @return An array of invalid keys
   *
   */

  invalid : function() {

    var invalid = [];

    // Check each required key

    for (var key in this.required) {
      if ( ! this.model.isValidKey( key ) )
        invalid.push(key);
    }

    return invalid;
  },

  /*---------------------------------------------
   *
   * isValid
   *
   * isValid() Validate whole model
   * isValid( key ) Validate key
   *
   * @return boolean
   *
   */
  

  isValid : function( key ) {

    if (typeof key === 'undefined') {

      // Check the whole model
      return ( this.model.invalid().length === 0);

    } else return this.model.isValidKey( key );

  },

  isValidKey : function( key ) {

    if ( typeof this.required[key] === 'undefined' ) {
      return true;
    }

    var val = this.model.get( key ),
        requireType = this.required[ key ];

    if ( requireType === true ) {

      return ! $.isEmpty( val );

    } else if ( requireType === 'email' ) {

      return $.isEmail( val );

    } else {

      // Other types of required: boolean, checked, custom condition..?

    }

    return true; // Passed all requirements
  }

};

$.isEmpty = function( mixed_var ) {

  // Empty: null, undefined, '', [], {}
  // Not empty: 0, true, false
  // What about jQuery object?

  var undef, key, i, len;
  var emptyValues = [undef, null, ''];

  for (i = 0, len = emptyValues.length; i < len; i++) {
    if (mixed_var === emptyValues[i]) {
      return true;
    }
  }

  if (typeof mixed_var === 'object') {
    for (key in mixed_var) {
      // Inherited properties count?
      // if (mixed_var.hasOwnProperty(key)) {
        return false;
      // }
    }
    return true;
  }

  return false;
};


// Validate e-mail
$.isEmail = function( email ) {

  if ( $.isEmpty( email ) ) return false;

  var regex = /^([a-zA-Z0-9_.+-])+\@(([a-zA-Z0-9-])+\.)+([a-zA-Z0-9]{2,4})+$/;
  return regex.test(email);
};

},{}],7:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * Model API
 *
 * get
 * set
 * reset
 * size
 * each
 * 
 * invalid
 * isValid
 * isValidKey
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null),
    util = require('../util/util'),
    modelValidate = require('./model-validate'),
    model = {

      get: require('./model-get'),
      set: require('./model-set'),

      // Resetter (to initial model upon object initialization)
      reset: function(){
        this.model.set(this.model._initData, {reset:true});
        return this; // for chainable calls
      },
      
      // Number of model properties
      size: function(){
        return util.size(this.model._data);
      },
      
      // Convenience function - loops over each model property
      each: function(fn){
        // Proxy this object
        $.each(this.model._data, $.proxy(fn,this) );
        return this; // for chainable calls
      }

    };

module.exports = $.extend( model, modelValidate );

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../util/util":17,"./model-get":4,"./model-set":5,"./model-validate":6}],8:[function(require,module,exports){

/*---------------------------------------------
 *
 * View API
 *
 * view.$
 * render
 * bindings
 * sync
 * stylize
 * $bound
 *
 */

var ROOT_SELECTOR = '&'; // Also in mvc/view.js

module.exports = {
    
  // Defaults
  format: '<div/>',
  style: '',
  
  // Shortcut to view.$root or view.$root.find(), depending on selector presence
  $: function(selector) {
    return (!selector || selector === ROOT_SELECTOR) ? this.view.$root : this.view.$root.find(selector);
  },
  

  // Render $root
  // Only function to access $root directly other than $()
  render: function(){

    // Without format there is no view
    if (this.view.format.length === 0) {
      throw "agility.js: empty format in view.render()";
    }                

    if ( this.view.$root instanceof jQuery && this._template ) {

      // Template from DOM - don't overwrite it

    } else if ( this.view.$root.size() === 0 ) {

      this.view.$root = $(this.view.format);

    } else {

      // don't overwrite $root as this would reset its presence in the DOM
      // and all events already bound

      this.view.$root.html( $(this.view.format).html() );
    }

    // Ensure we have a valid (non-empty) $root
    if ( !(this.view.$root instanceof jQuery) && this.view.$root.size() === 0 ) {
      throw 'agility.js: could not generate html from format';
    }

    this.$view = this.view.$root;
    this.$ = this.view.$;
    return this;
  }, // render



  // Parse data-bind string of the type '[attribute][=] variable[, [attribute][=] variable ]...'
  // If the variable is not an attribute, it must occur by itself
  //   all pairs in the list are assumed to be attributes
  // Returns { key:'model key', attr: [ {attr : 'attribute', attrVar : 'variable' }... ] }
  _parseBindStr: function(str){
    var obj = {key:null, attr:[]},
        pairs = str.split(','),
        // regex = /([a-zA-Z0-9_\-]+)(?:[\s=]+([a-zA-Z0-9_\-]+))?/,
        // @pull #91 Add support for nested models: key.prop
        regex = /([a-zA-Z0-9_\-\.]+)(?:[\s=]+([a-zA-Z0-9_\-]+))?/,
        keyAssigned = false,
        matched;
    
    if (pairs.length > 0) {
      for (var i = 0; i < pairs.length; i++) {
        matched = pairs[i].match(regex);
        // [ "attribute variable", "attribute", "variable" ]
        // or [ "attribute=variable", "attribute", "variable" ]
        // or
        // [ "variable", "variable", undefined ]
        // in some IE it will be [ "variable", "variable", "" ]
        // or
        // null
        if (matched) {
          if (typeof(matched[2]) === "undefined" || matched[2] === "") {
            if (keyAssigned) {
              throw new Error("You may specify only one key (" + 
                keyAssigned + " has already been specified in data-bind=" + 
                str + ")");
            } else {
              keyAssigned = matched[1];
              obj.key = matched[1];
            }
          } else {
            obj.attr.push({attr: matched[1], attrVar: matched[2]});
          }
        } // if (matched)
      } // for (pairs.length)
    } // if (pairs.length > 0)
    
    return obj;
  },


  /*---------------------------------------------
   *
   * Bindings
   *
   *  Apply two-way (DOM <--> Model) bindings to elements with 'data-bind' attributes
   *
   * @todo Separate to its own module
   *
   */

  bindings: function(){
    var self = this;
    var $rootNode = this.view.$().filter('[data-bind]');
    var $childNodes = this.view.$('[data-bind]');
    var createAttributePairClosure = function(bindData, node, i) {
      var attrPair = bindData.attr[i]; // capture the attribute pair in closure
      return function() {
        node.attr(attrPair.attr, self.model.get(attrPair.attrVar));
      };
    };

    $rootNode.add($childNodes).each(function(){

      var $node = $(this);
      var bindData = self.view._parseBindStr( $node.data('bind') );
      var required = $node.data('required');

      var bindAttributesOneWay = function() {
        // 1-way attribute binding
        if (bindData.attr) {
          for (var i = 0; i < bindData.attr.length; i++) {
            self.bind('_change:'+bindData.attr[i].attrVar,
              createAttributePairClosure(bindData, $node, i));
          } // for (bindData.attr)
        } // if (bindData.attr)
      }; // bindAttributesOneWay()
      
      // <input type="checkbox">: 2-way binding
      if ($node.is('input:checkbox')) {
        // Model --> DOM
        self.bind('_change:'+bindData.key, function(){
          $node.prop("checked", self.model.get(bindData.key)); // this won't fire a DOM 'change' event, saving us from an infinite event loop (Model <--> DOM)
        });            
        // DOM --> Model
        $node.change(function(){
          var obj = {};
          obj[bindData.key] = $(this).prop("checked");
          self.model.set(obj); // not silent as user might be listening to change events
        });
        // 1-way attribute binding
        bindAttributesOneWay();
      }
      
      // <select>: 2-way binding
      else if ($node.is('select')) {
        // Model --> DOM
        self.bind('_change:'+bindData.key, function(){
          var nodeName = $node.attr('name');
          var modelValue = self.model.get(bindData.key);
          $node.val(modelValue);
        });            
        // DOM --> Model
        $node.change(function(){
          var obj = {};
          obj[bindData.key] = $node.val();
          self.model.set(obj); // not silent as user might be listening to change events
        });
        // 1-way attribute binding
        bindAttributesOneWay();
      }
      
      // <input type="radio">: 2-way binding
      else if ($node.is('input:radio')) {

        // Model --> DOM
        self.bind('_change:'+bindData.key, function(){
          var nodeName = $node.attr('name');
          var modelValue = self.model.get(bindData.key);

            // $node.siblings('input[name="'+nodeName+'"]').filter('[value="'+modelValue+'"]').prop("checked", true);

            // @pull #110 Binding for radio buttons
            // They're not always siblings, so start from $root
            self.view.$root.find('input[name="'+nodeName+'"]')
              .filter('[value="'+modelValue+'"]')
              .prop("checked", true); // this won't fire a DOM 'change' event, saving us from an infinite event loop (Model <--> DOM)
        });            

        // DOM --> Model
        $node.change(function(){
          if (!$node.prop("checked")) return; // only handles check=true events
          var obj = {};
          obj[bindData.key] = $node.val();
          self.model.set(obj); // not silent as user might be listening to change events
        });
        // 1-way attribute binding
        bindAttributesOneWay();
      }
      
      // <input type="search"> (model is updated after every keypress event)
      else if ($node.is('input[type="search"]')) {

        // Model --> DOM
        self.bind('_change:'+bindData.key, function(){
          $node.val(self.model.get(bindData.key)); // this won't fire a DOM 'change' event, saving us from an infinite event loop (Model <--> DOM)
        });

        // Model <-- DOM
        $node.keypress(function(){
          // Without timeout $node.val() misses the last entered character
          setTimeout(function(){
            var obj = {};
            obj[bindData.key] = $node.val();
            self.model.set(obj); // not silent as user might be listening to change events
          }, 50);
        });
        // 1-way attribute binding
        bindAttributesOneWay();
      }

      // <input type="text">, <input>, and <textarea>: 2-way binding
      else if ($node.is('input:text, input[type!="search"], textarea')) {
        // Model --> DOM
        self.bind('_change:'+bindData.key, function(){
          $node.val(self.model.get(bindData.key)); // this won't fire a DOM 'change' event, saving us from an infinite event loop (Model <--> DOM)
        });            
        // Model <-- DOM
        $node.change(function(){
          var obj = {};
          obj[bindData.key] = $(this).val();
          self.model.set(obj); // not silent as user might be listening to change events
        });
        // 1-way attribute binding
        bindAttributesOneWay();
      }
      
      // all other <tag>s: 1-way binding (Model -> DOM)
      else {
        if (bindData.key) {
          self.bind('_change:'+bindData.key, function(){
            var key = self.model.get(bindData.key);
            if (key || key===0) {
              $node.text(self.model.get(bindData.key).toString());
            } else {
              $node.text('');
            }
          });
        }
        bindAttributesOneWay();
      }

      // Store binding map for later reference

      self.$node[ bindData.key ] = $node;
      self.key[ $node ] = bindData.key; // Unnecessary?

      if ( typeof required !== 'undefined' ) {
        self.required[ bindData.key ] = required;
      }

    }); // nodes.each()
    return this;
  }, // bindings()
  

  // Triggers _change and _change:* events so that view is updated as per view.bindings()
  sync: function(){
    var self = this;
    // Trigger change events so that view is updated according to model
    this.model.each(function(key, val){
      self.trigger('_change:'+key);
    });
    if (this.model.size() > 0) {
      this.trigger('_change');
    }
    return this;
  },


  // Applies style dynamically
  stylize: function(){
    var objClass,
        regex = new RegExp(ROOT_SELECTOR, 'g');
    if (this.view.style.length === 0 || this.view.$().size() === 0) {
      return;
    }
    // Own style
    // Object gets own class name ".agility_123", and <head> gets a corresponding <style>
    if (this.view.hasOwnProperty('style')) {
      objClass = 'agility_' + this._id;
      var styleStr = this.view.style.replace(regex, '.'+objClass);
      // $('head', window.document).append('<style type="text/css">'+styleStr+'</style>');

      // @pull #95 Add ID so later we can remove generated style
      // upon destruction of objects
      $('head', window.document).append('<style id="'+ objClass +'" type="text/css">'+
        styleStr+'</style>');
      this.view.$().addClass(objClass);
    }
    // Inherited style
    // Object inherits CSS class name from first ancestor to have own view.style
    else {
      // Returns id of first ancestor to have 'own' view.style
      var ancestorWithStyle = function(object) {
        while (object !== null) {
          object = Object.getPrototypeOf(object);
          if (object.view.hasOwnProperty('style'))
            return object._id;
        }
        return undefined;
      }; // ancestorWithStyle

      var ancestorId = ancestorWithStyle(this);
      objClass = 'agility_' + ancestorId;
      this.view.$().addClass(objClass);
    }
    return this;
  },


  /*---------------------------------------------
   *
   * Extended
   *
   */

  // Return element(s) bound to a model property

  // @todo Provide a reverse function from elements -> model property?

  $bound: function( key ) {

    var self = this;

    return this.view.$('[data-bind]').filter(function(){

      var bindData = self.view._parseBindStr( $(this).data('bind') );

      // What about multiple or nested bindings?
      return ( bindData.key == key );
    });
  }

};

},{}],9:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * _container
 *
 * API and related auxiliary functions for storing child Agility objects.
 * Not all methods are exposed. See 'shortcuts' below for exposed methods.
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null),
    util = require('../util/util');

module.exports = {

  // Adds child object to container, appends/prepends/etc view, listens for child removal
  _insertObject: function(obj, selector, method){
    var self = this;

    if (!util.isAgility(obj)) {
      throw "agility.js: append argument is not an agility object";
    }

    this._container.children[obj._id] = obj; // children is *not* an array; this is for simpler lookups by global object id
    this.trigger(method, [obj, selector]);
    obj._parent = this;
    // ensures object is removed from container when destroyed:
    obj.bind('destroy', function(event, id){ 
      self._container.remove(id);
    });
    // Trigger event for child to listen to
    obj.trigger('parent:'+method);
    return this;
  },

  append: function(obj, selector) { 
      return this._container._insertObject.call(this, obj, selector, 'append'); 
  },

  prepend: function(obj, selector) { 
      return this._container._insertObject.call(this, obj, selector, 'prepend'); 
  },

  after: function(obj, selector) { 
      return this._container._insertObject.call(this, obj, selector, 'after'); 
  },

  before: function(obj, selector) { 
      return this._container._insertObject.call(this, obj, selector, 'before'); 
  },
  
  // Removes child object from container
  remove: function(id){
    delete this._container.children[id];
    this.trigger('remove', id);
    return this;
  },

  // Iterates over all child objects in container
  each: function(fn){
    $.each(this._container.children, fn);
    return this; // for chainable calls
  },

  // Removes all objects in container
  empty: function(){
    this.each(function(){
      this.destroy();
    });
    return this;
  },
  
  // Number of children
  size: function() {
    return util.size(this._container.children);
  }
  
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../util/util":17}],10:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * _events API and auxiliary functions for handling events
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null),
    ROOT_SELECTOR = '&'; // Also in mvc/view.js

// Reverses the order of events attached to an object
function reverseEvents(obj, eventType){
  var events = $(obj).data('events');
  if (events !== undefined && events[eventType] !== undefined){
    // can't reverse what's not there
    var reversedEvents = [];
    for (var e in events[eventType]){
      if (!events[eventType].hasOwnProperty(e)) continue;
      reversedEvents.unshift(events[eventType][e]);
    }
    events[eventType] = reversedEvents;
  }
} //reverseEvents


module.exports = {

  // Parses event string like:
  //    'event'          : custom event
  //    'event selector' : DOM event using 'selector'
  // Returns { type:'event' [, selector:'selector'] }
  parseEventStr: function(eventStr){
    var eventObj = { type:eventStr }, 
        spacePos = eventStr.search(/\s/);
    // DOM event 'event selector', e.g. 'click button'
    if (spacePos > -1) {
      eventObj.type = eventStr.substr(0, spacePos);
      eventObj.selector = eventStr.substr(spacePos+1);
    } else if ( eventStr === 'click' || eventStr === 'submit' ) {
      // @extend Shortcut for 'click &' and 'submit &'
      eventObj.type = eventStr;
      eventObj.selector = ROOT_SELECTOR;
    }
    return eventObj;
  },

  // Binds eventStr to fn. eventStr is parsed as per parseEventStr()
  bind: function(eventStr, fn){

    var eventObj = this._events.parseEventStr(eventStr);

    // DOM event 'event selector', e.g. 'click button'
    if (eventObj.selector) {

      // Keep click and submit localized
      var fnx = function(event) {
        fn(event);
        return false; // Prevent default & bubbling
        // or just default? if ( ! event.isDefaultPrevented() ) event.preventDefault();
      };

      // Manually override root selector, as jQuery selectors can't select self object
      if (eventObj.selector === ROOT_SELECTOR) {


        if ( eventObj.type === 'click' || eventObj.type === 'submit' ) {
          this.view.$().on(eventObj.type, fnx);
        } else {
          this.view.$().on(eventObj.type, fn);
        }

        // @extend Replace $().bind with $().on
        // this.view.$().bind(eventObj.type, fn);
      }
      else {

        if ( eventObj.type === 'click' || eventObj.type === 'submit' ) {
          this.view.$().on(eventObj.type, eventObj.selector, fnx);
        } else {
          this.view.$().on(eventObj.type, eventObj.selector, fn);
        }

        // @extend Replace $().delegate with $().on
        // this.view.$().delegate(eventObj.selector, eventObj.type, fn);
      }
    }
    // Custom event
    else {

      // @extend Replace $().bind with $().on
      $(this._events.data).on(eventObj.type, fn);
      // $(this._events.data).bind(eventObj.type, fn);
    }
    return this; // for chainable calls
  }, // bind


  // Triggers eventStr. Syntax for eventStr is same as that for bind()
  trigger: function(eventStr, params){
    var eventObj = this._events.parseEventStr(eventStr);
    // DOM event 'event selector', e.g. 'click button'
    if (eventObj.selector) {
      // Manually override root selector, as jQuery selectors can't select self object
      if (eventObj.selector === ROOT_SELECTOR) {
        this.view.$().trigger(eventObj.type, params);
      }
      else {          
        this.view.$().find(eventObj.selector).trigger(eventObj.type, params);
      }
    }
    // Custom event
    else {
      $(this._events.data).trigger('_'+eventObj.type, params);
      // fire 'pre' hooks in reverse attachment order ( last first ) then put them back
      reverseEvents(this._events.data, 'pre:' + eventObj.type);
      $(this._events.data).trigger('pre:' + eventObj.type, params);
      reverseEvents(this._events.data, 'pre:' + eventObj.type);

      $(this._events.data).trigger(eventObj.type, params);

      // Trigger event for parent
      if (this.parent())
        this.parent().trigger((eventObj.type.match(/^child:/) ? '' : 'child:') + eventObj.type, params);
      $(this._events.data).trigger('post:' + eventObj.type, params);
    }
    return this; // for chainable calls
  } // trigger
  
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],11:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * Extended shortcuts
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null);

module.exports = {

  get : function( arg ) {
    this.model.get( arg );
  },

  set : function( arg, params, third ) {
    this.model.set( arg, params, third  );
  },

  replace: function( obj, selector ){
    if ( typeof selector === 'string' ) {
      this.view.$(selector).html('');
    }
    this.empty()._container.append.apply(this, arguments);
    return this; // for chainable calls
  },

  // Return nth child object
  child: function(n){
    var i = 0;
    n = n || 0;

    for (var j in this._container.children) {
      if ( this._container.children.hasOwnProperty(j) ) {
        if ( i == n )
          return this._container.children[j];
        else if ( i > n )
          return false;

        i++; // Continue searching
      }
    }
    return false;
  },

  // Return all child objects
  children: function(){
    return this._container.children; // { id: child, .. }
  },

  // Replace children models - append if there's more, destroy if less
  load: function( proto, models, selector ) {

    var self = this,
        maxModels = models.length,
        maxChildren = this.size();

    $.each(models, function(index, model) {
      if ( self.child(index) ) {
        self.child(index).model.set( model );
      } else {
        // $$ not defined yet?
        self.append( $$( proto, model ), selector );
      }
    });

    if (maxChildren > maxModels) {
      for (var i = maxModels; i < maxChildren; i++) {
        // Child's index stays the same, since each one is destroyed
        self.child(maxModels).destroy();
      }
    }

    return this;
  }

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],12:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * Form helpers
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null);

module.exports = {

  form : {

    // Clear the form
    clear : function() {

      return this.$view.find(':input')
        .not(':button, :submit, :reset, :hidden').removeAttr('checked').removeAttr('selected')
        .not(':checkbox, :radio, select').val('');
    },

    // Validate model, instead of form in the DOM directly
    // @return An array of invalid model properties
    invalid : function() {

      return this.model.invalid();
    }
  }

};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],13:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * Construct default object prototype
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null),

    defaultPrototype = {

      _agility: true,
      _container: require('./container'),
      _events: require('./events'),

      $node: {}, // Map of model properties -> bound elements
      key: {}, // Map of elements -> bound model properties
      required: {}, // Map of required model properties and require types

      model: require('../mvc/model'),
      view: require('../mvc/view'),
      controller: require('../mvc/controller')

    },

    shortcuts = require('./shortcuts'),
    extend = require('./extend'),
    form = require('./form');

module.exports = $.extend(defaultPrototype, shortcuts, extend, form);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../mvc/controller":3,"../mvc/model":7,"../mvc/view":8,"./container":9,"./events":10,"./extend":11,"./form":12,"./shortcuts":14}],14:[function(require,module,exports){

/*---------------------------------------------
 *
 * Object shortcuts
 *
 */

module.exports = {

  destroy: function() {
    this.trigger('destroy', this._id); // parent must listen to 'remove' event and handle container removal!
    // can't return this as it might not exist anymore!
  },
  parent: function(){
    return this._parent;
  },
  
  //
  // _container shortcuts
  //
  append: function(){
    this._container.append.apply(this, arguments);
    return this; // for chainable calls
  },
  prepend: function(){
    this._container.prepend.apply(this, arguments);
    return this; // for chainable calls
  },
  after: function(){
    this._container.after.apply(this, arguments);
    return this; // for chainable calls
  },
  before: function(){
    this._container.before.apply(this, arguments);
    return this; // for chainable calls
  },
  remove: function(){
    this._container.remove.apply(this, arguments);
    return this; // for chainable calls
  },
  size: function(){
    return this._container.size.apply(this, arguments);
  },
  each: function(){
    return this._container.each.apply(this, arguments);
  },
  empty: function(){
    return this._container.empty.apply(this, arguments);
  },

  //
  // _events shortcuts
  //
  bind: function(){
    this._events.bind.apply(this, arguments);
    return this; // for chainable calls
  },
  on: function(){ // Alias
    this._events.bind.apply(this, arguments);
    return this; // for chainable calls
  },
  trigger: function(){
    this._events.trigger.apply(this, arguments);
    return this; // for chainable calls
  },

};

},{}],15:[function(require,module,exports){

/*---------------------------------------------
 *
 * Shim for: Object.create and Object.getPrototypeOf
 *
 */


/*jslint proto: true */

// Modified from Douglas Crockford's Object.create()
// The condition below ensures we override other manual implementations
if (!Object.create || Object.create.toString().search(/native code/i)<0) {
  Object.create = function(obj){
    var Aux = function(){};
    $.extend(Aux.prototype, obj); // simply setting Aux.prototype = obj somehow messes with constructor, so getPrototypeOf wouldn't work in IE
    return new Aux();
  };
}

// Modified from John Resig's Object.getPrototypeOf()
// The condition below ensures we override other manual implementations
if (!Object.getPrototypeOf || Object.getPrototypeOf.toString().search(/native code/i)<0) {
  if ( typeof "test".__proto__ === "object" ) {
    Object.getPrototypeOf = function(object){
      return object.__proto__;
    };
  } else {
    Object.getPrototypeOf = function(object){
      // May break if the constructor has been tampered with
      return object.constructor.prototype;
    };
  }
}

},{}],16:[function(require,module,exports){
(function (global){
/*---------------------------------------------
 *
 * Timed functions
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null);

var timers = {},
    defaultInterval = 10000;

$.fn.timedClass = function( className, duration ) {

  var $self = $(this);

  return $(this).timedFn(
    function(){ $self.addClass( className ); },
    function(){ $self.removeClass( className ); },
    duration || defaultInterval
  );
};

$.fn.timedText = function( txt, duration ) {

  var $self = $(this);

  return $(this).timedFn(
    function(){ $self.text( txt ); },
    function(){ $self.text(''); },
    duration || defaultInterval
  );
};

$.fn.timedFn = function( id, start, end, duration ) {

  duration = duration || defaultInterval;

  // ID skipped
  if ( typeof id === 'function' ) {

    duration = end || duration;
    end = start;
    start = id;

    new Timer(function(){
      end();
    }, duration );

    return start();

  // If timer ID is set and one is already going, add to the duration
  } else if ( typeof timers[id] !== 'undefined' && ! timers[id].finished ) {

    timers[id].add( duration );

  } else {

    timers[id] = new Timer(function(){
      end();
    }, duration );

    return start();
  }
};


function Timer(callback, time) {
    this.setTimeout(callback, time);
}

Timer.prototype.setTimeout = function(callback, time) {

    var self = this;

    this.finished = false;
    this.callback = callback;
    this.time = time;

    if(this.timer) {
        clearTimeout(this.timer);
    }
    this.timer = setTimeout(function() {
      self.finished = true;
      self.callback();
    }, time);
    this.start = Date.now();
};

Timer.prototype.add = function(time) {
   if(!this.finished) {
       // add time to time left
       time = this.time - (Date.now() - this.start) + time;
       this.setTimeout(this.callback, time);
   }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],17:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * util.*
 *
 * isAgility
 * proxyAll
 * reverseEvents
 * size
 * extendController
 *
 * $.outerHTML
 * $.isEmpty
 * 
 */

/*jslint loopfunc: true */

var util = {},
    $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null);

// Checks if provided obj is an agility object
util.isAgility = function(obj){
 return obj._agility === true;
};

// Scans object for functions (depth=2) and proxies their 'this' to dest.
// * To ensure it works with previously proxied objects, we save the original function as 
//   a '._preProxy' method and when available always use that as the proxy source.
// * To skip a given method, create a sub-method called '_noProxy'.
util.proxyAll = function(obj, dest){
  if (!obj || !dest) {
    throw "agility.js: util.proxyAll needs two arguments";
  }
  for (var attr1 in obj) {
    var proxied = obj[attr1];
    // Proxy root methods
    if (typeof obj[attr1] === 'function' ) {

      proxied = obj[attr1]._noProxy ? obj[attr1] : $.proxy(obj[attr1]._preProxy || obj[attr1], dest);
      proxied._preProxy = obj[attr1]._noProxy ? undefined : (obj[attr1]._preProxy || obj[attr1]); // save original
      obj[attr1] = proxied;

    }
    // Proxy sub-methods (model.*, view.*, etc) -- except for jQuery object
    else if (typeof obj[attr1] === 'object' && !(obj[attr1] instanceof jQuery) ) {
      for (var attr2 in obj[attr1]) {
        var proxied2 = obj[attr1][attr2];
        if (typeof obj[attr1][attr2] === 'function') {
          proxied2 = obj[attr1][attr2]._noProxy ? obj[attr1][attr2] : $.proxy(obj[attr1][attr2]._preProxy || obj[attr1][attr2], dest);
          proxied2._preProxy = obj[attr1][attr2]._noProxy ? undefined : (obj[attr1][attr2]._preProxy || obj[attr1][attr2]); // save original
          proxied[attr2] = proxied2;
        }
      } // for attr2
      obj[attr1] = proxied;
    } // if not func
  } // for attr1
}; // proxyAll


// Determines # of attributes of given object (prototype inclusive)
util.size = function(obj){
  var size = 0, key;
  for (key in obj) {
    size++;
  }
  return size;
};

// Find controllers to be extended (with syntax '~'), redefine those to encompass previously defined controllers
// Example:
//   var a = $$({}, '<button>A</button>', {'click &': function(){ alert('A'); }});
//   var b = $$(a, {}, '<button>B</button>', {'~click &': function(){ alert('B'); }});
// Clicking on button B will alert both 'A' and 'B'.
util.extendController = function(object) {
  for (var controllerName in object.controller) {

    // new scope as we need one new function handler per controller
    (function(){
      var matches, extend, eventName,
          previousHandler, currentHandler, newHandler;

      if (typeof object.controller[controllerName] === 'function') {
        matches = controllerName.match(/^(\~)*(.+)/); // 'click button', '~click button', '_create', etc
        extend = matches[1];
        eventName = matches[2];
      
        if (!extend) return; // nothing to do

        // Redefine controller:
        // '~click button' ---> 'click button' = previousHandler + currentHandler
        previousHandler = object.controller[eventName] ? (object.controller[eventName]._preProxy || object.controller[eventName]) : undefined;
        currentHandler = object.controller[controllerName];
        newHandler = function() {
          if (previousHandler) previousHandler.apply(this, arguments);
          if (currentHandler) currentHandler.apply(this, arguments);
        };

        object.controller[eventName] = newHandler;
        delete object.controller[controllerName]; // delete '~click button'
      } // if function
    })();
  } // for controllerName
};

module.exports = util;


/*---------------------------------------------
 *
 * jQuery utility functions
 *
 */

// Get element including wrapping tag
window.jQuery.fn.outerHTML = function(s) {
  if (s) {
    return this.before(s).remove();
  } else {
    var doc = this[0] ? this[0].ownerDocument : document;
    return jQuery('<div>', doc).append(this.eq(0).clone()).html();
  }
};

window.jQuery.isEmpty = function( data ) {

  if(typeof(data) == 'number' || typeof(data) == 'boolean') {
    return false;
  }
  if(typeof(data) == 'undefined' || data === null) {
    return true;
  }
  if(typeof(data.length) != 'undefined') {
    return data.length == 0;
  }

  var count = 0;
  for(var i in data) {
    if(data.hasOwnProperty(i)) {
      count ++;
    }
  }
  return count == 0;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],18:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * wp.action
 * 
 * - get, save
 * - login, logout, go, reload
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null);
var wpAjax = require('./ajax.js');

module.exports = $.extend( window.wp.action || {}, {

  /**
   *
   * get( [type,] { query } )
   * 
   * @param {string} type   Content type: posts, users
   * @param {object} query  Query arguments
   * 
   * @todo taxonomy, comments
   *
   */

  get : function() {

    // Default: get_posts
    var type = 'posts';

    // For other content types: get_user, get_taxonomy, ...
    var nonPostTypes = [ 'user', 'users', 'taxonomy', 'field', 'fields' ];

    // Create array of arguments
    var args = Array.prototype.slice.call(arguments, 0);

    if ( args.length === 0 )
      throw "wp.action.get needs an object";

    if ( typeof args[0] === 'string' ) {
      type = args[0];
      args.shift();
    }

    request = args[0] || {};
    success = args[1] || {};
    error = args[2] || {};

    if ( typeof request.type !== 'undefined' && $.inArray(request.type, nonPostTypes) > -1 ) {
      type = request.type;
      delete request.type;
    }

    return wpAjax( 'get_'+type, request, success, error );
  },


  /**
   *
   * save( [type,] { data } )
   * 
   * @param {string} type   Content type: post, user
   * @param {object} data   Data
   * 
   * @todo taxonomy, comments..
   *
   */

  save: function() {

    // For post, page, custom post type: save_post
    var type = 'post';

    // For other content types: save_user, save_taxonomy, ...
    var nonPostTypes = [ 'user', 'users', 'taxonomy', 'field', 'fields' ];

    // Create array of arguments
    var args = Array.prototype.slice.call(arguments, 0);

    if ( args.length === 0 )
      throw "wp.action.save needs an object";

    if ( typeof args[0] === 'string' ) {
      type = args[0];
      args.shift();
    }

    request = args[0] || {};
    success = args[1] || {};
    error = args[2] || {};

    if ( typeof request.type !== 'undefined' && $.inArray(request.type, nonPostTypes) > -1 ) {
      type = request.type;
      delete request.type;
    } else if ( type == 'post' && $.isArray( request ) ) {
      type = 'posts';
    }

    return wpAjax( 'save_'+type, request, success, error );
  },


  /**
   *
   * login, logout, go, reload
   *
   * @todo register
   *
   */


  login : function( request, success, error ) {

    return wpAjax( 'login', request, success, error );
  },

  logout : function( redirect ) {

    var logout = wp.url.logout;

    if ( typeof redirect === 'undefined' ) redirect = wp.current.request;

    logout += '&redirect_to='+wp.url.site+redirect;
    location.href = logout;
  },

  go : function( route ) {
    location.href = wp.url.site+route;
  },

  reload : function() {
    location.href = wp.current.url;
  },

  /**
   *
   * email
   * 
   */

  mail : function( mailObj ) {

    // Default: get_posts
    var type = 'mail';

    // Create array of arguments
    var args = Array.prototype.slice.call(arguments, 0);

    if ( args.length === 0 )
      throw "wp.action.mail needs an object";

    request = args[0] || {};
    success = args[1] || {};
    error = args[2] || {};

    return wpAjax( 'send_email', request, success, error );
  }


});


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./ajax.js":19}],19:[function(require,module,exports){
(function (global){
/* global wp.current.nonce, wp.url.ajax */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null);

function wpAjax( action, request, success, error ) {

  var req = {
    type: 'POST',
    url: wp.url.ajax, // AJAX URL from server-side
    data: {
      action: 'agility_'+action, // Prefix
      nonce: wp.current.nonce, // Nonce from server-side
      data: request // The real data
    },
    beforeSend: '',
    success: '',
    error: ''
  };

  // Based on wp-util.js
  return $.Deferred( function( deferred ) {

    // Transfer success/error callbacks.
    if ( success )
      deferred.done( success );
    if ( error )
      deferred.fail( error );

    // Option to force return fail before Ajax request
    if ( action === 'fail' )
      deferred.rejectWith( this, arguments );

    // Use with PHP's wp_send_json_success() and wp_send_json_error()
    $.ajax( req ).done( function( response ) {

      // Treat a response of `1` as successful for backwards compatibility
      if ( response === '1' || response === 1 )
        response = { success: true };

      if ( typeof response.data === 'undefined' )
        response.data = 'empty';

      if ( typeof response === 'object' && ( typeof response.success !== 'undefined' ) )
        deferred[ response.success ? 'resolveWith' : 'rejectWith' ]( this, [response.data] );
      else{
        deferred.rejectWith( this, arguments ); // [response.data]
      }
    }).fail( function() {
      deferred.rejectWith( this, arguments );
    });
  }).promise();

}

module.exports = wpAjax;


/**
 * Shim for "fixing" IE's lack of support (IE < 9) for applying slice
 * on host objects like NamedNodeMap, NodeList, and HTMLCollection
 * (technically, since host objects have been implementation-dependent,
 * at least before ES6, IE hasn't needed to work this way).
 * Also works on strings, fixes IE < 9 to allow an explicit undefined
 * for the 2nd argument (as in Firefox), and prevents errors when
 * called on other DOM objects.

(function () {
  'use strict';
  var _slice = Array.prototype.slice;

  try {
    // Can't be used with DOM elements in IE < 9
    _slice.call(document.documentElement);
  } catch (e) { // Fails in IE < 9
    // This will work for genuine arrays, array-like objects, 
    // NamedNodeMap (attributes, entities, notations),
    // NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes),
    // and will not fail on other DOM objects (as do DOM elements in IE < 9)
    Array.prototype.slice = function(begin, end) {
      // IE < 9 gets unhappy with an undefined end argument
      end = (typeof end !== 'undefined') ? end : this.length;

      // For native Array objects, we use the native slice function
      if (Object.prototype.toString.call(this) === '[object Array]'){
        return _slice.call(this, begin, end); 
      }

      // For array like object we handle it ourselves.
      var i, cloned = [],
        size, len = this.length;

      // Handle negative value for "begin"
      var start = begin || 0;
      start = (start >= 0) ? start: len + start;

      // Handle negative value for "end"
      var upTo = (end) ? end : len;
      if (end < 0) {
        upTo = len + end;
      }

      // Actual expected size of the slice
      size = upTo - start;

      if (size > 0) {
        cloned = new Array(size);
        if (this.charAt) {
          for (i = 0; i < size; i++) {
            cloned[i] = this.charAt(start + i);
          }
        } else {
          for (i = 0; i < size; i++) {
            cloned[i] = this[start + i];
          }
        }
      }

      return cloned;
    };
  }
}());
 */


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYi9zeXMvY29uZi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwianMvc3JjL2luZGV4LmpzIiwianMvc3JjL2FnaWxpdHkvaW5kZXguanMiLCJqcy9zcmMvYWdpbGl0eS9tdmMvY29udHJvbGxlci5qcyIsImpzL3NyYy9hZ2lsaXR5L212Yy9tb2RlbC1nZXQuanMiLCJqcy9zcmMvYWdpbGl0eS9tdmMvbW9kZWwtc2V0LmpzIiwianMvc3JjL2FnaWxpdHkvbXZjL21vZGVsLXZhbGlkYXRlLmpzIiwianMvc3JjL2FnaWxpdHkvbXZjL21vZGVsLmpzIiwianMvc3JjL2FnaWxpdHkvbXZjL3ZpZXcuanMiLCJqcy9zcmMvYWdpbGl0eS9wcm90b3R5cGUvY29udGFpbmVyLmpzIiwianMvc3JjL2FnaWxpdHkvcHJvdG90eXBlL2V2ZW50cy5qcyIsImpzL3NyYy9hZ2lsaXR5L3Byb3RvdHlwZS9leHRlbmQuanMiLCJqcy9zcmMvYWdpbGl0eS9wcm90b3R5cGUvZm9ybS5qcyIsImpzL3NyYy9hZ2lsaXR5L3Byb3RvdHlwZS9pbmRleC5qcyIsImpzL3NyYy9hZ2lsaXR5L3Byb3RvdHlwZS9zaG9ydGN1dHMuanMiLCJqcy9zcmMvYWdpbGl0eS91dGlsL29iamVjdC1zaGltLmpzIiwianMvc3JjL2FnaWxpdHkvdXRpbC90aW1lZC5qcyIsImpzL3NyYy9hZ2lsaXR5L3V0aWwvdXRpbC5qcyIsImpzL3NyYy93cC9hY3Rpb24uanMiLCJqcy9zcmMvd3AvYWpheC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJ3cC1hZ2lsaXR5Lm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXG53aW5kb3cuJCQgPSByZXF1aXJlKCcuL2FnaWxpdHkvaW5kZXguanMnKTtcbndpbmRvdy53cCA9IHdpbmRvdy53cCB8fCB7fTtcbndpbmRvdy53cC5hY3Rpb24gPSByZXF1aXJlKCcuL3dwL2FjdGlvbi5qcycpO1xuIiwiLyoqXG4gKiBcbiAqIEFnaWxpdHkuanMgLSB2MC4yLjJcbiAqIFxuICogRm9ya2VkIGFuZCBleHRlbmRlZCBmcm9tOiBBZ2lsaXR5LmpzIDAuMS4zIGJ5IEFydHVyIEIuIEFkaWIgLSBodHRwOi8vYWdpbGl0eWpzLmNvbVxuICogXG4gKiBTZXBhcmF0ZWQgaW50byBDb21tb25KUyBtb2R1bGVzXG4gKiBcbiAqIE1lcmdlZCBwdWxsIHJlcXVlc3RzXG4gKiAtIFN1cHBvcnQgbmVzdGVkIG1vZGVsIHByb3BlcnRpZXNcbiAqIC0gRWZmaWNpZW50IGhhbmRsaW5nIG9mIHN0eWxlXG4gKiBcbiAqIEV4dGVuZGVkIGZlYXR1cmVzXG4gKiAtIE9ubHkgcmVuZGVyIGNoYW5nZWQgbW9kZWwgcHJvcGVydGllc1xuICogLSBGb3JtIGhlbHBlcnNcbiAqIFxuICovXG5cbi8qanNsaW50IGxvb3BmdW5jOiB0cnVlICovXG5cbihmdW5jdGlvbih3aW5kb3csIHVuZGVmaW5lZCl7XG5cbiAgaWYgKCF3aW5kb3cualF1ZXJ5KSB7XG4gICAgdGhyb3cgXCJhZ2lsaXR5LmpzOiBqUXVlcnkgbm90IGZvdW5kXCI7XG4gIH1cbiAgXG4gIC8vIExvY2FsIHJlZmVyZW5jZXNcbiAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxuICAgICAgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24sXG4gICAgICAkICAgICAgICA9IGpRdWVyeSxcblxuICAgICAgYWdpbGl0eSwgLy8gTWFpbiBhZ2lsaXR5IG9iamVjdCBidWlsZGVyXG5cbiAgICAgIHV0aWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL3V0aWwvdXRpbCcpLCAgICAgICAgIC8vIEludGVybmFsIHV0aWxpdHkgZnVuY3Rpb25zXG4gICAgICBzaGltICAgICAgICAgICAgID0gcmVxdWlyZSgnLi91dGlsL29iamVjdC1zaGltJyksICAvLyBPYmplY3QuY3JlYXRlIGFuZCBnZXRQcm90b3R5cGVPZlxuICAgICAgdGltZWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbC90aW1lZCcpLCAgICAgICAgLy8gVGltZWQgZnVuY3Rpb25zXG4gICAgICBkZWZhdWx0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9wcm90b3R5cGUvaW5kZXgnKSwgICAvLyBEZWZhdWx0IG9iamVjdCBwcm90b3R5cGVcbiAgICAgIGlkQ291bnRlciAgICAgICAgPSAwOyAvLyBHbG9iYWwgb2JqZWN0IGNvdW50ZXJcblxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIE1haW4gb2JqZWN0IGNvbnN0cnVjdG9yXG4gICAqXG4gICAqL1xuICBcbiAgYWdpbGl0eSA9IGZ1bmN0aW9uKCkge1xuICAgIFxuICAgIC8vIFJlYWwgYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLFxuICAgIFxuICAgIC8vIE9iamVjdCB0byBiZSByZXR1cm5lZCBieSBidWlsZGVyXG4gICAgb2JqZWN0ID0ge30sXG5cbiAgICAkcm9vdCwgLy8gVXNlZCB3aGVuIHRlbXBsYXRlIGlzIGZyb20gRE9NXG5cbiAgICBwcm90b3R5cGUgPSBkZWZhdWx0UHJvdG90eXBlO1xuXG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqXG4gICAgICogQ3JlYXRlIG9iamVjdCBmcm9tIHByb3RvdHlwZVxuICAgICAqXG4gICAgICovXG5cbiAgICAvLyBJZiBmaXJzdCBhcmcgaXMgb2JqZWN0LCB1c2UgaXQgYXMgcHJvdG90eXBlXG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSBcIm9iamVjdFwiICYmIHV0aWwuaXNBZ2lsaXR5KGFyZ3NbMF0pKSB7XG5cbiAgICAgIHByb3RvdHlwZSA9IGFyZ3NbMF07ICAgIFxuICAgICAgYXJncy5zaGlmdCgpOyAvLyByZW1haW5pbmcgYXJncyBub3cgd29yayBhcyB0aG91Z2ggb2JqZWN0IHdhc24ndCBzcGVjaWZpZWRcblxuICAgIH1cblxuICAgIC8vIEJ1aWxkIG9iamVjdCBmcm9tIHByb3RvdHlwZSBhcyB3ZWxsIGFzIHRoZSBpbmRpdmlkdWFsIHByb3RvdHlwZSBwYXJ0c1xuICAgIC8vIFRoaXMgZW5hYmxlcyBkaWZmZXJlbnRpYWwgaW5oZXJpdGFuY2UgYXQgdGhlIHN1Yi1vYmplY3QgbGV2ZWwsIGUuZy4gb2JqZWN0LnZpZXcuZm9ybWF0XG4gICAgb2JqZWN0ID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xuICAgIG9iamVjdC5tb2RlbCA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlLm1vZGVsKTtcbiAgICBvYmplY3QudmlldyA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlLnZpZXcpO1xuICAgIG9iamVjdC5jb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUuY29udHJvbGxlcik7XG4gICAgb2JqZWN0Ll9jb250YWluZXIgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZS5fY29udGFpbmVyKTtcbiAgICBvYmplY3QuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlLl9ldmVudHMpO1xuXG5cbiAgICAvLyBJbnN0YW5jZSBwcm9wZXJ0aWVzLCBpLmUuIG5vdCBpbmhlcml0ZWRcbiAgICBvYmplY3QuX2lkID0gaWRDb3VudGVyKys7XG4gICAgb2JqZWN0Ll9wYXJlbnQgPSBudWxsO1xuICAgIG9iamVjdC5fZXZlbnRzLmRhdGEgPSB7fTsgLy8gZXZlbnQgYmluZGluZ3Mgd2lsbCBoYXBwZW4gYmVsb3dcbiAgICBvYmplY3QuX2NvbnRhaW5lci5jaGlsZHJlbiA9IHt9O1xuICAgIG9iamVjdC52aWV3LiRyb290ID0gJCgpOyAvLyBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cblxuICAgIC8vIENsb25lIG93biBwcm9wZXJ0aWVzXG4gICAgLy8gaS5lLiBwcm9wZXJ0aWVzIHRoYXQgYXJlIGluaGVyaXRlZCBieSBkaXJlY3QgY29weSBpbnN0ZWFkIG9mIGJ5IHByb3RvdHlwZSBjaGFpblxuICAgIC8vIFRoaXMgcHJldmVudHMgY2hpbGRyZW4gZnJvbSBhbHRlcmluZyBwYXJlbnRzIG1vZGVsc1xuICAgIG9iamVjdC5tb2RlbC5fZGF0YSA9IHByb3RvdHlwZS5tb2RlbC5fZGF0YSA/ICQuZXh0ZW5kKHRydWUsIHt9LCBwcm90b3R5cGUubW9kZWwuX2RhdGEpIDoge307XG4gICAgb2JqZWN0Ll9kYXRhID0gcHJvdG90eXBlLl9kYXRhID8gJC5leHRlbmQodHJ1ZSwge30sIHByb3RvdHlwZS5fZGF0YSkgOiB7fTtcblxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKlxuICAgICAqIEV4dGVuZCBtb2RlbCwgdmlldywgY29udHJvbGxlciBiYXNlZCBvbiBnaXZlbiBhcmd1bWVudHNcbiAgICAgKlxuICAgICAqL1xuXG4gICAgLy8gSnVzdCB0aGUgZGVmYXVsdCBwcm90b3R5cGUge31cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICB9XG5cbiAgICAvLyAoIHZpZXcuZm9ybWF0IFsseyBtZXRob2Q6ZnVuY3Rpb24sIC4uLiB9XSApXG4gICAgZWxzZSBpZiAoIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyApIHtcblxuICAgICAgLy8gR2V0IHRlbXBsYXRlIGZyb20gJyNpZCdcbiAgICAgIGlmICggYXJnc1swXVswXSA9PT0gJyMnICkge1xuXG4gICAgICAgICRyb290ID0gJChhcmdzWzBdKTtcblxuICAgICAgICAvLyBUZW1wbGF0ZSBmcm9tIHNjcmlwdCB0YWdcbiAgICAgICAgaWYgKCAkcm9vdC5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSA9PT0gJ3NjcmlwdCcgKSB7XG5cbiAgICAgICAgICBvYmplY3Qudmlldy5mb3JtYXQgPSAkcm9vdC5odG1sKCk7XG5cbiAgICAgICAgLy8gVGVtcGxhdGUgZnJvbSBleGlzdGluZyBET01cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIEluY2x1ZGUgY29udGFpbmVyIGl0c2VsZlxuICAgICAgICAgIG9iamVjdC52aWV3LmZvcm1hdCA9ICRyb290Lm91dGVySFRNTCgpO1xuICAgICAgICAgIC8vIEFzc2lnbiByb290IHRvIGV4aXN0aW5nIERPTSBlbGVtZW50XG4gICAgICAgICAgb2JqZWN0LnZpZXcuJHJvb3QgPSAkcm9vdDtcbiAgICAgICAgICBvYmplY3QuX3RlbXBsYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICAvLyBvciAnPHRlbXBsYXRlPicgc3RyaW5nXG4gICAgICBlbHNlIG9iamVjdC52aWV3LmZvcm1hdCA9IGFyZ3NbMF07XG5cbiAgICAgIC8vIENvbnRyb2xsZXIgZnJvbSBvYmplY3RcbiAgICAgIGlmICggYXJncy5sZW5ndGggPiAxICYmIHR5cGVvZiBhcmdzWzFdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAkLmV4dGVuZChvYmplY3QuY29udHJvbGxlciwgYXJnc1sxXSk7XG4gICAgICAgIHV0aWwuZXh0ZW5kQ29udHJvbGxlcihvYmplY3QpO1xuICAgICAgfVxuXG4gICAgfSAvLyBzaW5nbGUgdmlldyBhcmdcblxuICAgIC8vIFByb3RvdHlwZSBkaWZmZXJlbnRpYWwgZnJvbSBzaW5nbGUge21vZGVsLHZpZXcsY29udHJvbGxlcn0gb2JqZWN0XG4gICAgZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnICYmIChhcmdzWzBdLm1vZGVsIHx8IGFyZ3NbMF0udmlldykgKSB7XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gYXJnc1swXSkge1xuXG4gICAgICAgIGlmIChwcm9wID09PSAnbW9kZWwnKSB7XG5cbiAgICAgICAgICAkLmV4dGVuZChvYmplY3QubW9kZWwuX2RhdGEsIGFyZ3NbMF0ubW9kZWwpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ3ZpZXcnKSB7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0udmlldyA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgICAgLy8gR2V0IHRlbXBsYXRlIGZyb20gJyNpZCdcbiAgICAgICAgICAgIGlmICggYXJnc1swXS52aWV3WzBdID09PSAnIycgKSB7XG5cbiAgICAgICAgICAgICAgJHJvb3QgPSAkKGFyZ3NbMF0udmlldyk7XG5cbiAgICAgICAgICAgICAgb2JqZWN0LnZpZXcuZm9ybWF0ID0gJHJvb3QuaHRtbCgpO1xuXG4gICAgICAgICAgICAgIC8vIFRlbXBsYXRlIGZyb20gc2NyaXB0IHRhZ1xuICAgICAgICAgICAgICBpZiAoICRyb290LnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpID09PSAnc2NyaXB0JyApIHtcblxuICAgICAgICAgICAgICAgIG9iamVjdC52aWV3LmZvcm1hdCA9ICRyb290Lmh0bWwoKTtcblxuICAgICAgICAgICAgICAvLyBUZW1wbGF0ZSBmcm9tIGV4aXN0aW5nIERPTVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gSW5jbHVkZSBjb250YWluZXIgaXRzZWxmXG4gICAgICAgICAgICAgICAgb2JqZWN0LnZpZXcuZm9ybWF0ID0gJHJvb3Qub3V0ZXJIVE1MKCk7XG4gICAgICAgICAgICAgICAgLy8gQXNzaWduIHJvb3QgdG8gZXhpc3RpbmcgRE9NIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBvYmplY3Qudmlldy4kcm9vdCA9ICRyb290O1xuICAgICAgICAgICAgICAgIG9iamVjdC5fdGVtcGxhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9yICc8dGVtcGxhdGU+JyBzdHJpbmdcbiAgICAgICAgICAgIGVsc2Ugb2JqZWN0LnZpZXcuZm9ybWF0ID0gYXJnc1swXS52aWV3O1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgJC5leHRlbmQob2JqZWN0LnZpZXcsIGFyZ3NbMF0udmlldyk7IC8vIHZpZXc6e2Zvcm1hdDp7fSxzdHlsZTp7fX1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggcHJvcCA9PT0gJ2NvbnRyb2xsZXInIHx8IHByb3AgPT09ICdldmVudHMnICkge1xuICAgICAgICAgICQuZXh0ZW5kKG9iamVjdC5jb250cm9sbGVyLCBhcmdzWzBdW3Byb3BdKTtcbiAgICAgICAgICB1dGlsLmV4dGVuZENvbnRyb2xsZXIob2JqZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZXItZGVmaW5lZCBtZXRob2RzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG9iamVjdFtwcm9wXSA9IGFyZ3NbMF1bcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHNpbmdsZSB7bW9kZWwsIHZpZXcsIGNvbnRyb2xsZXJ9IGFyZ1xuXG4gICAgLy8gUHJvdG90eXBlIGRpZmZlcmVudGlhbCBmcm9tIHNlcGFyYXRlIHttb2RlbH0sIHt2aWV3fSwge2NvbnRyb2xsZXJ9IGFyZ3VtZW50c1xuICAgIGVsc2Uge1xuICAgICAgXG4gICAgICAvLyBNb2RlbCBvYmplY3RcbiAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgJC5leHRlbmQob2JqZWN0Lm1vZGVsLl9kYXRhLCBhcmdzWzBdKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyZ3NbMF0pIHtcbiAgICAgICAgdGhyb3cgXCJhZ2lsaXR5LmpzOiB1bmtub3duIGFyZ3VtZW50IHR5cGUgKG1vZGVsKVwiO1xuICAgICAgfVxuXG4gICAgICAvLyBWaWV3IGZvcm1hdCBmcm9tIHNob3J0aGFuZCBzdHJpbmcgKC4uLiwgJzxkaXY+d2hhdGV2ZXI8L2Rpdj4nLCAuLi4pXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgLy8gQGV4dGVuZCBHZXQgdGVtcGxhdGUgZnJvbSBJRFxuICAgICAgICBpZiAoIGFyZ3NbMV1bMF0gPT09ICcjJyApIHtcblxuICAgICAgICAgIC8vIG9iamVjdC52aWV3LmZvcm1hdCA9ICQoYXJnc1sxXSkuaHRtbCgpO1xuXG4gICAgICAgICAgJHJvb3QgPSAkKGFyZ3NbMV0pO1xuXG4gICAgICAgICAgLy8gVGVtcGxhdGUgZnJvbSBzY3JpcHQgdGFnXG4gICAgICAgICAgaWYgKCAkcm9vdC5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSA9PT0gJ3NjcmlwdCcgKSB7XG5cbiAgICAgICAgICAgIG9iamVjdC52aWV3LmZvcm1hdCA9ICRyb290Lmh0bWwoKTtcblxuICAgICAgICAgIC8vIFRlbXBsYXRlIGZyb20gZXhpc3RpbmcgRE9NXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gSW5jbHVkZSBjb250YWluZXIgaXRzZWxmXG4gICAgICAgICAgICBvYmplY3Qudmlldy5mb3JtYXQgPSAkcm9vdC5vdXRlckhUTUwoKTtcbiAgICAgICAgICAgIC8vIEFzc2lnbiByb290IHRvIGV4aXN0aW5nIERPTSBlbGVtZW50XG4gICAgICAgICAgICBvYmplY3Qudmlldy4kcm9vdCA9ICRyb290O1xuICAgICAgICAgICAgb2JqZWN0Ll90ZW1wbGF0ZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvYmplY3Qudmlldy5mb3JtYXQgPSBhcmdzWzFdOyAvLyBleHRlbmQgdmlldyB3aXRoIC5mb3JtYXRcbiAgICAgIH0gIFxuICAgICAgLy8gVmlldyBmcm9tIG9iamVjdCAoLi4uLCB7Zm9ybWF0Oic8ZGl2PndoYXRldmVyPC9kaXY+J30sIC4uLilcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAkLmV4dGVuZChvYmplY3QudmlldywgYXJnc1sxXSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmdzWzFdKSB7XG4gICAgICAgIHRocm93IFwiYWdpbGl0eS5qczogdW5rbm93biBhcmd1bWVudCB0eXBlICh2aWV3KVwiO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWaWV3IHN0eWxlIGZyb20gc2hvcnRoYW5kIHN0cmluZyAoLi4uLCAuLi4sICdwIHtjb2xvcjpyZWR9JywgLi4uKVxuXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMl0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9iamVjdC52aWV3LnN0eWxlID0gYXJnc1syXTtcbiAgICAgICAgYXJncy5zcGxpY2UoMiwgMSk7IC8vIHNvIHRoYXQgY29udHJvbGxlciBjb2RlIGJlbG93IHdvcmtzXG4gICAgICB9XG5cbiAgICAgIC8vIENvbnRyb2xsZXIgZnJvbSBvYmplY3QgKC4uLiwgLi4uLCB7bWV0aG9kOmZ1bmN0aW9uKCl7fX0pXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMl0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICQuZXh0ZW5kKG9iamVjdC5jb250cm9sbGVyLCBhcmdzWzJdKTtcbiAgICAgICAgdXRpbC5leHRlbmRDb250cm9sbGVyKG9iamVjdCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmdzWzJdKSB7XG4gICAgICAgIHRocm93IFwiYWdpbGl0eS5qczogdW5rbm93biBhcmd1bWVudCB0eXBlIChjb250cm9sbGVyKVwiO1xuICAgICAgfVxuICAgICAgXG4gICAgfSAvLyBzZXBhcmF0ZSAoe21vZGVsfSwge3ZpZXd9LCB7Y29udHJvbGxlcn0pIGFyZ3NcblxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKlxuICAgICAqIExhdW5jaCBzZXF1ZW5jZTogQmluZGluZ3MsIGluaXRpYWxpemF0aW9ucywgZXRjXG4gICAgICpcbiAgICAgKi9cbiAgICBcbiAgICAvLyBTYXZlIG1vZGVsJ3MgaW5pdGlhbCBzdGF0ZSAoc28gaXQgY2FuIGJlIC5yZXNldCgpIGxhdGVyKVxuICAgIG9iamVjdC5tb2RlbC5faW5pdERhdGEgPSAkLmV4dGVuZCh7fSwgb2JqZWN0Lm1vZGVsLl9kYXRhKTtcblxuICAgIC8vIG9iamVjdC4qIHdpbGwgaGF2ZSB0aGVpciAndGhpcycgPT09IG9iamVjdC4gVGhpcyBzaG91bGQgY29tZSBiZWZvcmUgY2FsbCB0byBvYmplY3QuKiBiZWxvdy5cbiAgICB1dGlsLnByb3h5QWxsKG9iamVjdCwgb2JqZWN0KTtcblxuICBcbiAgICAvLyBJbml0aWFsaXplICRyb290LCBuZWVkZWQgZm9yIERPTSBldmVudHMgYmluZGluZyBiZWxvd1xuICAgIG9iamVjdC52aWV3LnJlbmRlcigpO1xuICBcblxuICAgIC8vIEJpbmQgYWxsIGNvbnRyb2xsZXJzIHRvIHRoZWlyIGV2ZW50c1xuXG4gICAgdmFyIGJpbmRFdmVudCA9IGZ1bmN0aW9uKGV2LCBoYW5kbGVyKXtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmplY3QuYmluZChldiwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGV2ZW50U3RyIGluIG9iamVjdC5jb250cm9sbGVyKSB7XG4gICAgICB2YXIgZXZlbnRzID0gZXZlbnRTdHIuc3BsaXQoJzsnKTtcbiAgICAgIHZhciBoYW5kbGVyID0gb2JqZWN0LmNvbnRyb2xsZXJbZXZlbnRTdHJdO1xuICAgICAgJC5lYWNoKGV2ZW50cywgZnVuY3Rpb24oaSwgZXYpe1xuICAgICAgICBldiA9ICQudHJpbShldik7XG4gICAgICAgIGJpbmRFdmVudChldiwgaGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBdXRvLXRyaWdnZXJzIGNyZWF0ZSBldmVudFxuICAgIG9iamVjdC50cmlnZ2VyKCdjcmVhdGUnKTsgICAgXG4gICAgXG4gICAgcmV0dXJuIG9iamVjdDtcbiAgICBcbiAgfTsgLy8gYWdpbGl0eVxuXG5cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBHbG9iYWwgcHJvcGVydGllc1xuICAgKlxuICAgKi9cblxuICBcbiAgLy8gJCQuZG9jdW1lbnQgaXMgYSBzcGVjaWFsIEFnaWxpdHkgb2JqZWN0LCB3aG9zZSB2aWV3IGlzIGF0dGFjaGVkIHRvIDxib2R5PlxuICAvLyBUaGlzIG9iamVjdCBpcyB0aGUgbWFpbiBlbnRyeSBwb2ludCBmb3IgYWxsIERPTSBvcGVyYXRpb25zXG4gIGFnaWxpdHkuZG9jdW1lbnQgPSBhZ2lsaXR5KHtcbiAgICBfZG9jdW1lbnQgOiB0cnVlLFxuICAgIHZpZXc6IHtcbiAgICAgICQ6IGZ1bmN0aW9uKHNlbGVjdG9yKXsgcmV0dXJuIHNlbGVjdG9yID8gJChzZWxlY3RvciwgJ2JvZHknKSA6ICQoJ2JvZHknKTsgfVxuICAgIH0sXG4gICAgY29udHJvbGxlcjoge1xuICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdCBjb250cm9sbGVyIChkb24ndCByZW5kZXIsIGRvbid0IHN0eWxpemUsIGV0YylcbiAgICAgIF9jcmVhdGU6IGZ1bmN0aW9uKCl7fVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gU2hvcnRjdXQgdG8gcHJvdG90eXBlIGZvciBwbHVnaW5zXG4gIGFnaWxpdHkuZm4gPSBkZWZhdWx0UHJvdG90eXBlO1xuXG4gIC8vIE5hbWVzcGFjZSB0byBkZWNsYXJlIHJldXNhYmxlIEFnaWxpdHkgb2JqZWN0c1xuICAvLyBVc2U6IGFwcC5hcHBlbmQoICQkLm1vZHVsZS5zb21ldGhpbmcgKSBvciAkJCggJCQubW9kdWxlLnNvbWV0aGluZywge20sdixjfSApXG4gIGFnaWxpdHkubW9kdWxlID0ge307XG5cbiAgLy8gaXNBZ2lsaXR5IHRlc3RcbiAgYWdpbGl0eS5pc0FnaWxpdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC5pc0FnaWxpdHkob2JqKTtcbiAgfTtcblxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIEV4cG9ydCBpdFxuICAgKlxuICAgKi9cblxuICAvLyBBTUQsIENvbW1vbkpTLCB0aGVuIGdsb2JhbFxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQHRvZG8gSXMgdGhpcyBjb3JyZWN0P1xuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGFnaWxpdHk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGFnaWxpdHk7XG4gIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuJCQgPSBhZ2lsaXR5O1xuICB9XG5cbn0pKHdpbmRvdyk7XG4iLCJcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogQ29udHJvbGxlclxuICpcbiAqICBEZWZhdWx0IGNvbnRyb2xsZXJzLCBpLmUuIGV2ZW50IGhhbmRsZXJzLiBFdmVudCBoYW5kbGVycyB0aGF0IHN0YXJ0XG4gKiAgd2l0aCAnXycgYXJlIG9mIGludGVybmFsIHVzZSBvbmx5LCBhbmQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgYW55IG90aGVyXG4gKiAgaGFuZGxlciB3aXRob3V0IHRoYXQgcHJlZml4LiBTZWU6IHRyaWdnZXIoKVxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvLyBUcmlnZ2VyZWQgYWZ0ZXIgc2VsZiBjcmVhdGlvblxuICBfY3JlYXRlOiBmdW5jdGlvbihldmVudCl7XG4gICAgdGhpcy52aWV3LnN0eWxpemUoKTtcbiAgICB0aGlzLnZpZXcuYmluZGluZ3MoKTsgLy8gTW9kZWwtVmlldyBiaW5kaW5nc1xuICAgIHRoaXMudmlldy5zeW5jKCk7IC8vIHN5bmNzIFZpZXcgd2l0aCBNb2RlbFxuICB9LFxuXG4gIC8vIFRyaWdnZXJlZCB1cG9uIHJlbW92aW5nIHNlbGZcbiAgX2Rlc3Ryb3k6IGZ1bmN0aW9uKGV2ZW50KXtcblxuICAgIC8vIEBwdWxsICM5NSBSZW1vdmUgZ2VuZXJhdGVkIHN0eWxlIHVwb24gZGVzdHJ1Y3Rpb24gb2Ygb2JqZWN0c1xuICAgIC8vIEBleHRlbmQgT25seSBpZiB1c2luZyBzdHlsZSBhdHRyaWJ1dGVcblxuICAgIGlmICh0aGlzLnZpZXcuc3R5bGUpIHtcbiAgICAgIHZhciBvYmpDbGFzcyA9ICdhZ2lsaXR5XycgKyB0aGlzLl9pZDtcbiAgICAgICQoJ2hlYWQgIycrb2JqQ2xhc3MsIHdpbmRvdy5kb2N1bWVudCkucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgLy8gZGVzdHJveSBhbnkgYXBwZW5kZWQgYWdpbGl0eSBvYmplY3RzXG4gICAgdGhpcy5fY29udGFpbmVyLmVtcHR5KCk7XG5cbiAgICAvLyBkZXN0cm95IHNlbGZcbiAgICB0aGlzLnZpZXcuJCgpLnJlbW92ZSgpO1xuICB9LFxuXG4gIC8vIFRyaWdnZXJlZCBhZnRlciBjaGlsZCBvYmogaXMgYXBwZW5kZWQgdG8gY29udGFpbmVyXG4gIF9hcHBlbmQ6IGZ1bmN0aW9uKGV2ZW50LCBvYmosIHNlbGVjdG9yKXtcbiAgICB0aGlzLnZpZXcuJChzZWxlY3RvcikuYXBwZW5kKG9iai52aWV3LiQoKSk7XG4gIH0sXG5cbiAgLy8gVHJpZ2dlcmVkIGFmdGVyIGNoaWxkIG9iaiBpcyBwcmVwZW5kZWQgdG8gY29udGFpbmVyXG4gIF9wcmVwZW5kOiBmdW5jdGlvbihldmVudCwgb2JqLCBzZWxlY3Rvcil7XG4gICAgdGhpcy52aWV3LiQoc2VsZWN0b3IpLnByZXBlbmQob2JqLnZpZXcuJCgpKTtcbiAgfSxcblxuICAvLyBUcmlnZ2VyZWQgYWZ0ZXIgY2hpbGQgb2JqIGlzIGluc2VydGVkIGluIHRoZSBjb250YWluZXJcbiAgX2JlZm9yZTogZnVuY3Rpb24oZXZlbnQsIG9iaiwgc2VsZWN0b3Ipe1xuICAgIGlmICghc2VsZWN0b3IpIHRocm93ICdhZ2lsaXR5LmpzOiBfYmVmb3JlIG5lZWRzIGEgc2VsZWN0b3InO1xuICAgIHRoaXMudmlldy4kKHNlbGVjdG9yKS5iZWZvcmUob2JqLnZpZXcuJCgpKTtcbiAgfSxcblxuICAvLyBUcmlnZ2VyZWQgYWZ0ZXIgY2hpbGQgb2JqIGlzIGluc2VydGVkIGluIHRoZSBjb250YWluZXJcbiAgX2FmdGVyOiBmdW5jdGlvbihldmVudCwgb2JqLCBzZWxlY3Rvcil7XG4gICAgaWYgKCFzZWxlY3RvcikgdGhyb3cgJ2FnaWxpdHkuanM6IF9hZnRlciBuZWVkcyBhIHNlbGVjdG9yJztcbiAgICB0aGlzLnZpZXcuJChzZWxlY3RvcikuYWZ0ZXIob2JqLnZpZXcuJCgpKTtcbiAgfSxcblxuICAvLyBUcmlnZ2VyZWQgYWZ0ZXIgYSBjaGlsZCBvYmogaXMgcmVtb3ZlZCBmcm9tIGNvbnRhaW5lciAob3Igc2VsZi1yZW1vdmVkKVxuICBfcmVtb3ZlOiBmdW5jdGlvbihldmVudCwgaWQpeyAgICAgICAgXG4gIH0sXG5cbiAgLy8gVHJpZ2dlcmVkIGFmdGVyIG1vZGVsIGlzIGNoYW5nZWRcbiAgJ19jaGFuZ2UnOiBmdW5jdGlvbihldmVudCl7XG4gIH1cbiAgXG59O1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBHZXRcbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXQoIGFyZyApIHtcblxuICAvLyBHZXQgd2hvbGUgbW9kZWxcbiAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWwuX2RhdGE7XG4gIH1cblxuICAvLyBHZXQgYXR0cmlidXRlXG4gIC8vIEBwdWxsICM5MSBBZGQgc3VwcG9ydCBmb3IgbmVzdGVkIG1vZGVsczogcGFyZW50LmNoaWxkXG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBwYXRocyA9IGFyZy5zcGxpdCgnLicpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwuX2RhdGFbcGF0aHNbMF1dO1xuICAgIC8vY2hlY2sgZm9yIG5lc3RlZCBvYmplY3RzXG4gICAgaWYgKCQuaXNQbGFpbk9iamVjdCh2YWx1ZSkpe1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwYXRocy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QodmFsdWUpICYmIHZhbHVlW3BhdGhzW2ldXSl7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVtwYXRoc1tpXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVtwYXRocy5zcGxpY2UoaSkuam9pbignLicpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL2RpcmVjdCBrZXkgYWNjZXNzXG4gICAgICB2YWx1ZSA9IHRoaXMubW9kZWwuX2RhdGFbYXJnXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdGhyb3cgJ2FnaWxpdHkuanM6IHVua25vd24gYXJndW1lbnQgZm9yIGdldHRlcic7XG59O1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBTZXQ6IHNldCBtb2RlbCBhdHRyaWJ1dGVzIGFuZCB0cmlnZ2VyIGNoYW5nZSBldmVudHNcbiAqIFxuICogQHRvZG8gUGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbnNcbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXQoIGFyZywgcGFyYW1zLCB0aGlyZCApIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBtb2RpZmllZCA9IFtdOyAvLyBsaXN0IG9mIG1vZGlmaWVkIG1vZGVsIGF0dHJpYnV0ZXNcbiAgdmFyIHByZXZpb3VzID0ge307IC8vIGxpc3Qgb2YgcHJldmlvdXMgdmFsdWVzXG5cbiAgLy8gU2V0IGluZGl2aWR1YWwgbW9kZWwgcHJvcGVydHk6IG1vZGVsLnNldCggcHJvcCwgdmFsdWUgKVxuICBpZiAoIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIHBhcmFtcyApIHtcbiAgICBhcmcgPSB7IGFyZzogcGFyYW1zIH07XG4gICAgcGFyYW1zID0gdGhpcmQgfHwge307XG4gIH1cblxuICBpZiAoIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICkge1xuXG4gICAgdmFyIF9jbG9uZSA9IHt9O1xuXG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMucmVzZXQpIHtcbiAgICAgIF9jbG9uZSA9IHRoaXMubW9kZWwuX2RhdGE7IC8vIGhvbGQgb24gdG8gZGF0YSBmb3IgY2hhbmdlIGV2ZW50c1xuICAgICAgdGhpcy5tb2RlbC5fZGF0YSA9ICQuZXh0ZW5kKHt9LCBhcmcpOyAvLyBlcmFzZXMgcHJldmlvdXMgbW9kZWwgYXR0cmlidXRlcyB3aXRob3V0IHBvaW50aW5nIHRvIG9iamVjdFxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgLy8gQGV4dGVuZCBDb21wYXJlIGFuZCBvbmx5IHRyaWdnZXIgY2hhbmdlIGV2ZW50IGZvciBtb2RpZmllZCBrZXlzXG4gICAgICBfY2xvbmUgPSAkLmV4dGVuZCh7fSwgdGhpcy5tb2RlbC5fZGF0YSk7XG5cbiAgICAgIC8vIEBwdWxsICM5MSBBZGQgc3VwcG9ydCBmb3IgbmVzdGVkIG1vZGVsc1xuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHByb3BlcnRpZXMgYW5kIGZpbmQgbmVzdGVkIGRlY2xhcmF0aW9uc1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIGFyZyl7XG4gICAgICAgIGlmIChwcm9wLmluZGV4T2YoJy4nKSA+IC0xKXtcbiAgICAgICAgICB2YXIgcGF0aCA9IHByb3Auc3BsaXQoJy4nKTtcbiAgICAgICAgICB2YXIgY3VycmVudF9ub2RlID0gdGhpcy5tb2RlbC5fZGF0YVtwYXRoWzBdXTtcbiAgICAgICAgICBpZiAoIWN1cnJlbnRfbm9kZSl7XG4gICAgICAgICAgICBjdXJyZW50X25vZGUgPSB0aGlzLm1vZGVsLl9kYXRhW3BhdGhbMF1dID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuZXh0X25vZGU7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKyl7XG4gICAgICAgICAgICBuZXh0X25vZGUgPSBjdXJyZW50X25vZGVbcGF0aFtpXV07XG4gICAgICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KG5leHRfbm9kZSkpe1xuICAgICAgICAgICAgIGN1cnJlbnRfbm9kZSA9IG5leHRfbm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgY3VycmVudF9ub2RlW3BhdGhbaV1dID0ge307XG4gICAgICAgICAgICAgY3VycmVudF9ub2RlID0gY3VycmVudF9ub2RlW3BhdGhbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGFzdF9wcm9wZXJ0eSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QoYXJnW2tleV0pICYmICQuaXNQbGFpbk9iamVjdChjdXJyZW50X25vZGVbbGFzdF9wcm9wZXJ0eV0pKXtcbiAgICAgICAgICAgLy9pZiB3ZSdyZSBhc3NpZ25pbmcgb2JqZWN0cywgZXh0ZW5kIHJhdGhlciB0aGFuIHJlcGxhY2VcbiAgICAgICAgICAgJC5leHRlbmQoY3VycmVudF9ub2RlW2xhc3RfcHJvcGVydHldLCBhcmdbcHJvcF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIGN1cnJlbnRfbm9kZVtsYXN0X3Byb3BlcnR5XSA9IGFyZ1twcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgbW9kaWZpZWQucHVzaChwcm9wKTtcbiAgICAgICAgICBwcmV2aW91c1twcm9wXSA9IF9jbG9uZVtwcm9wXTtcbiAgICAgICAgICBkZWxldGUgX2Nsb25lWyBwcm9wIF07IC8vIG5vIG5lZWQgdG8gZmlyZSBjaGFuZ2UgdHdpY2VcbiAgICAgICAgICBkZWxldGUgYXJnW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICQuZXh0ZW5kKHRoaXMubW9kZWwuX2RhdGEsIGFyZyk7IC8vIGRlZmF1bHQgaXMgZXh0ZW5kXG4gICAgfVxuXG4gICAgLy8gR2l2ZW4gb2JqZWN0XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG4gICAgICAvLyBDaGVjayBpZiBjaGFuZ2VkXG4gICAgICBpZiAodGhpcy5tb2RlbC5fZGF0YVtrZXldICE9PSBfY2xvbmVba2V5XSApIHtcbiAgICAgICAgbW9kaWZpZWQucHVzaChrZXkpO1xuICAgICAgICBwcmV2aW91c1trZXldID0gX2Nsb25lWyBrZXkgXTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBfY2xvbmVbIGtleSBdOyAvLyBubyBuZWVkIHRvIGZpcmUgY2hhbmdlIHR3aWNlXG4gICAgfVxuXG4gICAgLy8gUHJldmlvdXMgb2JqZWN0XG5cbiAgICBmb3IgKGtleSBpbiBfY2xvbmUpIHtcbiAgICAgIC8vIENoZWNrIGlmIGNoYW5nZWRcbiAgICAgIGlmICh0aGlzLm1vZGVsLl9kYXRhW2tleV0gIT09IF9jbG9uZVtrZXldICkge1xuICAgICAgICBtb2RpZmllZC5wdXNoKGtleSk7XG4gICAgICAgIHByZXZpb3VzW2tleV0gPSBfY2xvbmVbIGtleSBdO1xuICAgICAgfVxuICAgIH1cblxuICB9IGVsc2Uge1xuXG4gICAgLy8gTm90IGFuIG9iamVjdFxuICAgIHRocm93IFwiYWdpbGl0eS5qczogdW5rbm93biBhcmd1bWVudCB0eXBlIGluIG1vZGVsLnNldCgpXCI7XG4gIH1cblxuICAvLyBUaWdnZXIgY2hhbmdlIGV2ZW50c1xuXG4gIGlmIChwYXJhbXMgJiYgcGFyYW1zLnNpbGVudD09PXRydWUpIHJldHVybiB0aGlzOyAvLyBkbyBub3QgZmlyZSBldmVudHNcblxuICAvLyBAZXh0ZW5kIFBhc3MgYXJyYXkgb2YgbW9kaWZpZWQgbW9kZWwga2V5c1xuXG4gIC8vICQoKS50cmlnZ2VyIHBhcnNlcyB0aGUgc2Vjb25kIHBhcmFtZXRlciBhcyBzZXBhcmF0ZSBhcmd1bWVudHMsXG4gIC8vIHNvIHdlIHB1dCBpdCBpbiBhbiBhcnJheVxuXG4gIHRoaXMudHJpZ2dlcignY2hhbmdlJywgW21vZGlmaWVkLCBwcmV2aW91c10pO1xuXG4gICQuZWFjaChtb2RpZmllZCwgZnVuY3Rpb24oaW5kZXgsIGtleSl7XG4gICAgc2VsZi50cmlnZ2VyKCdjaGFuZ2U6JytrZXksIHByZXZpb3VzW2tleV0pO1xuICB9KTtcblxuICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluYWJsZSBjYWxsc1xuXG59O1xuIiwiXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFZhbGlkYXRlIG1vZGVsIHByb3BlcnRpZXMgYmFzZWQgb24gb2JqZWN0LnJlcXVpcmVkXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIG1vZGVsLmludmFsaWQoKVxuICAgKiBcbiAgICogQHJldHVybiBBbiBhcnJheSBvZiBpbnZhbGlkIGtleXNcbiAgICpcbiAgICovXG5cbiAgaW52YWxpZCA6IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGludmFsaWQgPSBbXTtcblxuICAgIC8vIENoZWNrIGVhY2ggcmVxdWlyZWQga2V5XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5yZXF1aXJlZCkge1xuICAgICAgaWYgKCAhIHRoaXMubW9kZWwuaXNWYWxpZEtleSgga2V5ICkgKVxuICAgICAgICBpbnZhbGlkLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW52YWxpZDtcbiAgfSxcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBpc1ZhbGlkXG4gICAqXG4gICAqIGlzVmFsaWQoKSBWYWxpZGF0ZSB3aG9sZSBtb2RlbFxuICAgKiBpc1ZhbGlkKCBrZXkgKSBWYWxpZGF0ZSBrZXlcbiAgICpcbiAgICogQHJldHVybiBib29sZWFuXG4gICAqXG4gICAqL1xuICBcblxuICBpc1ZhbGlkIDogZnVuY3Rpb24oIGtleSApIHtcblxuICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAvLyBDaGVjayB0aGUgd2hvbGUgbW9kZWxcbiAgICAgIHJldHVybiAoIHRoaXMubW9kZWwuaW52YWxpZCgpLmxlbmd0aCA9PT0gMCk7XG5cbiAgICB9IGVsc2UgcmV0dXJuIHRoaXMubW9kZWwuaXNWYWxpZEtleSgga2V5ICk7XG5cbiAgfSxcblxuICBpc1ZhbGlkS2V5IDogZnVuY3Rpb24oIGtleSApIHtcblxuICAgIGlmICggdHlwZW9mIHRoaXMucmVxdWlyZWRba2V5XSA9PT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgdmFsID0gdGhpcy5tb2RlbC5nZXQoIGtleSApLFxuICAgICAgICByZXF1aXJlVHlwZSA9IHRoaXMucmVxdWlyZWRbIGtleSBdO1xuXG4gICAgaWYgKCByZXF1aXJlVHlwZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgcmV0dXJuICEgJC5pc0VtcHR5KCB2YWwgKTtcblxuICAgIH0gZWxzZSBpZiAoIHJlcXVpcmVUeXBlID09PSAnZW1haWwnICkge1xuXG4gICAgICByZXR1cm4gJC5pc0VtYWlsKCB2YWwgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIE90aGVyIHR5cGVzIG9mIHJlcXVpcmVkOiBib29sZWFuLCBjaGVja2VkLCBjdXN0b20gY29uZGl0aW9uLi4/XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTsgLy8gUGFzc2VkIGFsbCByZXF1aXJlbWVudHNcbiAgfVxuXG59O1xuXG4kLmlzRW1wdHkgPSBmdW5jdGlvbiggbWl4ZWRfdmFyICkge1xuXG4gIC8vIEVtcHR5OiBudWxsLCB1bmRlZmluZWQsICcnLCBbXSwge31cbiAgLy8gTm90IGVtcHR5OiAwLCB0cnVlLCBmYWxzZVxuICAvLyBXaGF0IGFib3V0IGpRdWVyeSBvYmplY3Q/XG5cbiAgdmFyIHVuZGVmLCBrZXksIGksIGxlbjtcbiAgdmFyIGVtcHR5VmFsdWVzID0gW3VuZGVmLCBudWxsLCAnJ107XG5cbiAgZm9yIChpID0gMCwgbGVuID0gZW1wdHlWYWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAobWl4ZWRfdmFyID09PSBlbXB0eVZhbHVlc1tpXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBtaXhlZF92YXIgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChrZXkgaW4gbWl4ZWRfdmFyKSB7XG4gICAgICAvLyBJbmhlcml0ZWQgcHJvcGVydGllcyBjb3VudD9cbiAgICAgIC8vIGlmIChtaXhlZF92YXIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAvLyB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG4vLyBWYWxpZGF0ZSBlLW1haWxcbiQuaXNFbWFpbCA9IGZ1bmN0aW9uKCBlbWFpbCApIHtcblxuICBpZiAoICQuaXNFbXB0eSggZW1haWwgKSApIHJldHVybiBmYWxzZTtcblxuICB2YXIgcmVnZXggPSAvXihbYS16QS1aMC05Xy4rLV0pK1xcQCgoW2EtekEtWjAtOS1dKStcXC4pKyhbYS16QS1aMC05XXsyLDR9KSskLztcbiAgcmV0dXJuIHJlZ2V4LnRlc3QoZW1haWwpO1xufTtcbiIsIlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBNb2RlbCBBUElcbiAqXG4gKiBnZXRcbiAqIHNldFxuICogcmVzZXRcbiAqIHNpemVcbiAqIGVhY2hcbiAqIFxuICogaW52YWxpZFxuICogaXNWYWxpZFxuICogaXNWYWxpZEtleVxuICpcbiAqL1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmpRdWVyeSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwualF1ZXJ5IDogbnVsbCksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpLFxuICAgIG1vZGVsVmFsaWRhdGUgPSByZXF1aXJlKCcuL21vZGVsLXZhbGlkYXRlJyksXG4gICAgbW9kZWwgPSB7XG5cbiAgICAgIGdldDogcmVxdWlyZSgnLi9tb2RlbC1nZXQnKSxcbiAgICAgIHNldDogcmVxdWlyZSgnLi9tb2RlbC1zZXQnKSxcblxuICAgICAgLy8gUmVzZXR0ZXIgKHRvIGluaXRpYWwgbW9kZWwgdXBvbiBvYmplY3QgaW5pdGlhbGl6YXRpb24pXG4gICAgICByZXNldDogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQodGhpcy5tb2RlbC5faW5pdERhdGEsIHtyZXNldDp0cnVlfSk7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5hYmxlIGNhbGxzXG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBOdW1iZXIgb2YgbW9kZWwgcHJvcGVydGllc1xuICAgICAgc2l6ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHV0aWwuc2l6ZSh0aGlzLm1vZGVsLl9kYXRhKTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIC0gbG9vcHMgb3ZlciBlYWNoIG1vZGVsIHByb3BlcnR5XG4gICAgICBlYWNoOiBmdW5jdGlvbihmbil7XG4gICAgICAgIC8vIFByb3h5IHRoaXMgb2JqZWN0XG4gICAgICAgICQuZWFjaCh0aGlzLm1vZGVsLl9kYXRhLCAkLnByb3h5KGZuLHRoaXMpICk7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5hYmxlIGNhbGxzXG4gICAgICB9XG5cbiAgICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9ICQuZXh0ZW5kKCBtb2RlbCwgbW9kZWxWYWxpZGF0ZSApO1xuIiwiXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFZpZXcgQVBJXG4gKlxuICogdmlldy4kXG4gKiByZW5kZXJcbiAqIGJpbmRpbmdzXG4gKiBzeW5jXG4gKiBzdHlsaXplXG4gKiAkYm91bmRcbiAqXG4gKi9cblxudmFyIFJPT1RfU0VMRUNUT1IgPSAnJic7IC8vIEFsc28gaW4gbXZjL3ZpZXcuanNcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgXG4gIC8vIERlZmF1bHRzXG4gIGZvcm1hdDogJzxkaXYvPicsXG4gIHN0eWxlOiAnJyxcbiAgXG4gIC8vIFNob3J0Y3V0IHRvIHZpZXcuJHJvb3Qgb3Igdmlldy4kcm9vdC5maW5kKCksIGRlcGVuZGluZyBvbiBzZWxlY3RvciBwcmVzZW5jZVxuICAkOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHJldHVybiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBST09UX1NFTEVDVE9SKSA/IHRoaXMudmlldy4kcm9vdCA6IHRoaXMudmlldy4kcm9vdC5maW5kKHNlbGVjdG9yKTtcbiAgfSxcbiAgXG5cbiAgLy8gUmVuZGVyICRyb290XG4gIC8vIE9ubHkgZnVuY3Rpb24gdG8gYWNjZXNzICRyb290IGRpcmVjdGx5IG90aGVyIHRoYW4gJCgpXG4gIHJlbmRlcjogZnVuY3Rpb24oKXtcblxuICAgIC8vIFdpdGhvdXQgZm9ybWF0IHRoZXJlIGlzIG5vIHZpZXdcbiAgICBpZiAodGhpcy52aWV3LmZvcm1hdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IFwiYWdpbGl0eS5qczogZW1wdHkgZm9ybWF0IGluIHZpZXcucmVuZGVyKClcIjtcbiAgICB9ICAgICAgICAgICAgICAgIFxuXG4gICAgaWYgKCB0aGlzLnZpZXcuJHJvb3QgaW5zdGFuY2VvZiBqUXVlcnkgJiYgdGhpcy5fdGVtcGxhdGUgKSB7XG5cbiAgICAgIC8vIFRlbXBsYXRlIGZyb20gRE9NIC0gZG9uJ3Qgb3ZlcndyaXRlIGl0XG5cbiAgICB9IGVsc2UgaWYgKCB0aGlzLnZpZXcuJHJvb3Quc2l6ZSgpID09PSAwICkge1xuXG4gICAgICB0aGlzLnZpZXcuJHJvb3QgPSAkKHRoaXMudmlldy5mb3JtYXQpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gZG9uJ3Qgb3ZlcndyaXRlICRyb290IGFzIHRoaXMgd291bGQgcmVzZXQgaXRzIHByZXNlbmNlIGluIHRoZSBET01cbiAgICAgIC8vIGFuZCBhbGwgZXZlbnRzIGFscmVhZHkgYm91bmRcblxuICAgICAgdGhpcy52aWV3LiRyb290Lmh0bWwoICQodGhpcy52aWV3LmZvcm1hdCkuaHRtbCgpICk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHdlIGhhdmUgYSB2YWxpZCAobm9uLWVtcHR5KSAkcm9vdFxuICAgIGlmICggISh0aGlzLnZpZXcuJHJvb3QgaW5zdGFuY2VvZiBqUXVlcnkpICYmIHRoaXMudmlldy4kcm9vdC5zaXplKCkgPT09IDAgKSB7XG4gICAgICB0aHJvdyAnYWdpbGl0eS5qczogY291bGQgbm90IGdlbmVyYXRlIGh0bWwgZnJvbSBmb3JtYXQnO1xuICAgIH1cblxuICAgIHRoaXMuJHZpZXcgPSB0aGlzLnZpZXcuJHJvb3Q7XG4gICAgdGhpcy4kID0gdGhpcy52aWV3LiQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sIC8vIHJlbmRlclxuXG5cblxuICAvLyBQYXJzZSBkYXRhLWJpbmQgc3RyaW5nIG9mIHRoZSB0eXBlICdbYXR0cmlidXRlXVs9XSB2YXJpYWJsZVssIFthdHRyaWJ1dGVdWz1dIHZhcmlhYmxlIF0uLi4nXG4gIC8vIElmIHRoZSB2YXJpYWJsZSBpcyBub3QgYW4gYXR0cmlidXRlLCBpdCBtdXN0IG9jY3VyIGJ5IGl0c2VsZlxuICAvLyAgIGFsbCBwYWlycyBpbiB0aGUgbGlzdCBhcmUgYXNzdW1lZCB0byBiZSBhdHRyaWJ1dGVzXG4gIC8vIFJldHVybnMgeyBrZXk6J21vZGVsIGtleScsIGF0dHI6IFsge2F0dHIgOiAnYXR0cmlidXRlJywgYXR0clZhciA6ICd2YXJpYWJsZScgfS4uLiBdIH1cbiAgX3BhcnNlQmluZFN0cjogZnVuY3Rpb24oc3RyKXtcbiAgICB2YXIgb2JqID0ge2tleTpudWxsLCBhdHRyOltdfSxcbiAgICAgICAgcGFpcnMgPSBzdHIuc3BsaXQoJywnKSxcbiAgICAgICAgLy8gcmVnZXggPSAvKFthLXpBLVowLTlfXFwtXSspKD86W1xccz1dKyhbYS16QS1aMC05X1xcLV0rKSk/LyxcbiAgICAgICAgLy8gQHB1bGwgIzkxIEFkZCBzdXBwb3J0IGZvciBuZXN0ZWQgbW9kZWxzOiBrZXkucHJvcFxuICAgICAgICByZWdleCA9IC8oW2EtekEtWjAtOV9cXC1cXC5dKykoPzpbXFxzPV0rKFthLXpBLVowLTlfXFwtXSspKT8vLFxuICAgICAgICBrZXlBc3NpZ25lZCA9IGZhbHNlLFxuICAgICAgICBtYXRjaGVkO1xuICAgIFxuICAgIGlmIChwYWlycy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hdGNoZWQgPSBwYWlyc1tpXS5tYXRjaChyZWdleCk7XG4gICAgICAgIC8vIFsgXCJhdHRyaWJ1dGUgdmFyaWFibGVcIiwgXCJhdHRyaWJ1dGVcIiwgXCJ2YXJpYWJsZVwiIF1cbiAgICAgICAgLy8gb3IgWyBcImF0dHJpYnV0ZT12YXJpYWJsZVwiLCBcImF0dHJpYnV0ZVwiLCBcInZhcmlhYmxlXCIgXVxuICAgICAgICAvLyBvclxuICAgICAgICAvLyBbIFwidmFyaWFibGVcIiwgXCJ2YXJpYWJsZVwiLCB1bmRlZmluZWQgXVxuICAgICAgICAvLyBpbiBzb21lIElFIGl0IHdpbGwgYmUgWyBcInZhcmlhYmxlXCIsIFwidmFyaWFibGVcIiwgXCJcIiBdXG4gICAgICAgIC8vIG9yXG4gICAgICAgIC8vIG51bGxcbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mKG1hdGNoZWRbMl0pID09PSBcInVuZGVmaW5lZFwiIHx8IG1hdGNoZWRbMl0gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGlmIChrZXlBc3NpZ25lZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbWF5IHNwZWNpZnkgb25seSBvbmUga2V5IChcIiArIFxuICAgICAgICAgICAgICAgIGtleUFzc2lnbmVkICsgXCIgaGFzIGFscmVhZHkgYmVlbiBzcGVjaWZpZWQgaW4gZGF0YS1iaW5kPVwiICsgXG4gICAgICAgICAgICAgICAgc3RyICsgXCIpXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAga2V5QXNzaWduZWQgPSBtYXRjaGVkWzFdO1xuICAgICAgICAgICAgICBvYmoua2V5ID0gbWF0Y2hlZFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqLmF0dHIucHVzaCh7YXR0cjogbWF0Y2hlZFsxXSwgYXR0clZhcjogbWF0Y2hlZFsyXX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBpZiAobWF0Y2hlZClcbiAgICAgIH0gLy8gZm9yIChwYWlycy5sZW5ndGgpXG4gICAgfSAvLyBpZiAocGFpcnMubGVuZ3RoID4gMClcbiAgICBcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICpcbiAgICogQmluZGluZ3NcbiAgICpcbiAgICogIEFwcGx5IHR3by13YXkgKERPTSA8LS0+IE1vZGVsKSBiaW5kaW5ncyB0byBlbGVtZW50cyB3aXRoICdkYXRhLWJpbmQnIGF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHRvZG8gU2VwYXJhdGUgdG8gaXRzIG93biBtb2R1bGVcbiAgICpcbiAgICovXG5cbiAgYmluZGluZ3M6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciAkcm9vdE5vZGUgPSB0aGlzLnZpZXcuJCgpLmZpbHRlcignW2RhdGEtYmluZF0nKTtcbiAgICB2YXIgJGNoaWxkTm9kZXMgPSB0aGlzLnZpZXcuJCgnW2RhdGEtYmluZF0nKTtcbiAgICB2YXIgY3JlYXRlQXR0cmlidXRlUGFpckNsb3N1cmUgPSBmdW5jdGlvbihiaW5kRGF0YSwgbm9kZSwgaSkge1xuICAgICAgdmFyIGF0dHJQYWlyID0gYmluZERhdGEuYXR0cltpXTsgLy8gY2FwdHVyZSB0aGUgYXR0cmlidXRlIHBhaXIgaW4gY2xvc3VyZVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBub2RlLmF0dHIoYXR0clBhaXIuYXR0ciwgc2VsZi5tb2RlbC5nZXQoYXR0clBhaXIuYXR0clZhcikpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgJHJvb3ROb2RlLmFkZCgkY2hpbGROb2RlcykuZWFjaChmdW5jdGlvbigpe1xuXG4gICAgICB2YXIgJG5vZGUgPSAkKHRoaXMpO1xuICAgICAgdmFyIGJpbmREYXRhID0gc2VsZi52aWV3Ll9wYXJzZUJpbmRTdHIoICRub2RlLmRhdGEoJ2JpbmQnKSApO1xuICAgICAgdmFyIHJlcXVpcmVkID0gJG5vZGUuZGF0YSgncmVxdWlyZWQnKTtcblxuICAgICAgdmFyIGJpbmRBdHRyaWJ1dGVzT25lV2F5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIDEtd2F5IGF0dHJpYnV0ZSBiaW5kaW5nXG4gICAgICAgIGlmIChiaW5kRGF0YS5hdHRyKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5kRGF0YS5hdHRyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxmLmJpbmQoJ19jaGFuZ2U6JytiaW5kRGF0YS5hdHRyW2ldLmF0dHJWYXIsXG4gICAgICAgICAgICAgIGNyZWF0ZUF0dHJpYnV0ZVBhaXJDbG9zdXJlKGJpbmREYXRhLCAkbm9kZSwgaSkpO1xuICAgICAgICAgIH0gLy8gZm9yIChiaW5kRGF0YS5hdHRyKVxuICAgICAgICB9IC8vIGlmIChiaW5kRGF0YS5hdHRyKVxuICAgICAgfTsgLy8gYmluZEF0dHJpYnV0ZXNPbmVXYXkoKVxuICAgICAgXG4gICAgICAvLyA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCI+OiAyLXdheSBiaW5kaW5nXG4gICAgICBpZiAoJG5vZGUuaXMoJ2lucHV0OmNoZWNrYm94JykpIHtcbiAgICAgICAgLy8gTW9kZWwgLS0+IERPTVxuICAgICAgICBzZWxmLmJpbmQoJ19jaGFuZ2U6JytiaW5kRGF0YS5rZXksIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgJG5vZGUucHJvcChcImNoZWNrZWRcIiwgc2VsZi5tb2RlbC5nZXQoYmluZERhdGEua2V5KSk7IC8vIHRoaXMgd29uJ3QgZmlyZSBhIERPTSAnY2hhbmdlJyBldmVudCwgc2F2aW5nIHVzIGZyb20gYW4gaW5maW5pdGUgZXZlbnQgbG9vcCAoTW9kZWwgPC0tPiBET00pXG4gICAgICAgIH0pOyAgICAgICAgICAgIFxuICAgICAgICAvLyBET00gLS0+IE1vZGVsXG4gICAgICAgICRub2RlLmNoYW5nZShmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgICBvYmpbYmluZERhdGEua2V5XSA9ICQodGhpcykucHJvcChcImNoZWNrZWRcIik7XG4gICAgICAgICAgc2VsZi5tb2RlbC5zZXQob2JqKTsgLy8gbm90IHNpbGVudCBhcyB1c2VyIG1pZ2h0IGJlIGxpc3RlbmluZyB0byBjaGFuZ2UgZXZlbnRzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyAxLXdheSBhdHRyaWJ1dGUgYmluZGluZ1xuICAgICAgICBiaW5kQXR0cmlidXRlc09uZVdheSgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyA8c2VsZWN0PjogMi13YXkgYmluZGluZ1xuICAgICAgZWxzZSBpZiAoJG5vZGUuaXMoJ3NlbGVjdCcpKSB7XG4gICAgICAgIC8vIE1vZGVsIC0tPiBET01cbiAgICAgICAgc2VsZi5iaW5kKCdfY2hhbmdlOicrYmluZERhdGEua2V5LCBmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciBub2RlTmFtZSA9ICRub2RlLmF0dHIoJ25hbWUnKTtcbiAgICAgICAgICB2YXIgbW9kZWxWYWx1ZSA9IHNlbGYubW9kZWwuZ2V0KGJpbmREYXRhLmtleSk7XG4gICAgICAgICAgJG5vZGUudmFsKG1vZGVsVmFsdWUpO1xuICAgICAgICB9KTsgICAgICAgICAgICBcbiAgICAgICAgLy8gRE9NIC0tPiBNb2RlbFxuICAgICAgICAkbm9kZS5jaGFuZ2UoZnVuY3Rpb24oKXtcbiAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgb2JqW2JpbmREYXRhLmtleV0gPSAkbm9kZS52YWwoKTtcbiAgICAgICAgICBzZWxmLm1vZGVsLnNldChvYmopOyAvLyBub3Qgc2lsZW50IGFzIHVzZXIgbWlnaHQgYmUgbGlzdGVuaW5nIHRvIGNoYW5nZSBldmVudHNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIDEtd2F5IGF0dHJpYnV0ZSBiaW5kaW5nXG4gICAgICAgIGJpbmRBdHRyaWJ1dGVzT25lV2F5KCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIDxpbnB1dCB0eXBlPVwicmFkaW9cIj46IDItd2F5IGJpbmRpbmdcbiAgICAgIGVsc2UgaWYgKCRub2RlLmlzKCdpbnB1dDpyYWRpbycpKSB7XG5cbiAgICAgICAgLy8gTW9kZWwgLS0+IERPTVxuICAgICAgICBzZWxmLmJpbmQoJ19jaGFuZ2U6JytiaW5kRGF0YS5rZXksIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgdmFyIG5vZGVOYW1lID0gJG5vZGUuYXR0cignbmFtZScpO1xuICAgICAgICAgIHZhciBtb2RlbFZhbHVlID0gc2VsZi5tb2RlbC5nZXQoYmluZERhdGEua2V5KTtcblxuICAgICAgICAgICAgLy8gJG5vZGUuc2libGluZ3MoJ2lucHV0W25hbWU9XCInK25vZGVOYW1lKydcIl0nKS5maWx0ZXIoJ1t2YWx1ZT1cIicrbW9kZWxWYWx1ZSsnXCJdJykucHJvcChcImNoZWNrZWRcIiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIEBwdWxsICMxMTAgQmluZGluZyBmb3IgcmFkaW8gYnV0dG9uc1xuICAgICAgICAgICAgLy8gVGhleSdyZSBub3QgYWx3YXlzIHNpYmxpbmdzLCBzbyBzdGFydCBmcm9tICRyb290XG4gICAgICAgICAgICBzZWxmLnZpZXcuJHJvb3QuZmluZCgnaW5wdXRbbmFtZT1cIicrbm9kZU5hbWUrJ1wiXScpXG4gICAgICAgICAgICAgIC5maWx0ZXIoJ1t2YWx1ZT1cIicrbW9kZWxWYWx1ZSsnXCJdJylcbiAgICAgICAgICAgICAgLnByb3AoXCJjaGVja2VkXCIsIHRydWUpOyAvLyB0aGlzIHdvbid0IGZpcmUgYSBET00gJ2NoYW5nZScgZXZlbnQsIHNhdmluZyB1cyBmcm9tIGFuIGluZmluaXRlIGV2ZW50IGxvb3AgKE1vZGVsIDwtLT4gRE9NKVxuICAgICAgICB9KTsgICAgICAgICAgICBcblxuICAgICAgICAvLyBET00gLS0+IE1vZGVsXG4gICAgICAgICRub2RlLmNoYW5nZShmdW5jdGlvbigpe1xuICAgICAgICAgIGlmICghJG5vZGUucHJvcChcImNoZWNrZWRcIikpIHJldHVybjsgLy8gb25seSBoYW5kbGVzIGNoZWNrPXRydWUgZXZlbnRzXG4gICAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICAgIG9ialtiaW5kRGF0YS5rZXldID0gJG5vZGUudmFsKCk7XG4gICAgICAgICAgc2VsZi5tb2RlbC5zZXQob2JqKTsgLy8gbm90IHNpbGVudCBhcyB1c2VyIG1pZ2h0IGJlIGxpc3RlbmluZyB0byBjaGFuZ2UgZXZlbnRzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyAxLXdheSBhdHRyaWJ1dGUgYmluZGluZ1xuICAgICAgICBiaW5kQXR0cmlidXRlc09uZVdheSgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyA8aW5wdXQgdHlwZT1cInNlYXJjaFwiPiAobW9kZWwgaXMgdXBkYXRlZCBhZnRlciBldmVyeSBrZXlwcmVzcyBldmVudClcbiAgICAgIGVsc2UgaWYgKCRub2RlLmlzKCdpbnB1dFt0eXBlPVwic2VhcmNoXCJdJykpIHtcblxuICAgICAgICAvLyBNb2RlbCAtLT4gRE9NXG4gICAgICAgIHNlbGYuYmluZCgnX2NoYW5nZTonK2JpbmREYXRhLmtleSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAkbm9kZS52YWwoc2VsZi5tb2RlbC5nZXQoYmluZERhdGEua2V5KSk7IC8vIHRoaXMgd29uJ3QgZmlyZSBhIERPTSAnY2hhbmdlJyBldmVudCwgc2F2aW5nIHVzIGZyb20gYW4gaW5maW5pdGUgZXZlbnQgbG9vcCAoTW9kZWwgPC0tPiBET00pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE1vZGVsIDwtLSBET01cbiAgICAgICAgJG5vZGUua2V5cHJlc3MoZnVuY3Rpb24oKXtcbiAgICAgICAgICAvLyBXaXRob3V0IHRpbWVvdXQgJG5vZGUudmFsKCkgbWlzc2VzIHRoZSBsYXN0IGVudGVyZWQgY2hhcmFjdGVyXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICAgICAgb2JqW2JpbmREYXRhLmtleV0gPSAkbm9kZS52YWwoKTtcbiAgICAgICAgICAgIHNlbGYubW9kZWwuc2V0KG9iaik7IC8vIG5vdCBzaWxlbnQgYXMgdXNlciBtaWdodCBiZSBsaXN0ZW5pbmcgdG8gY2hhbmdlIGV2ZW50c1xuICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIDEtd2F5IGF0dHJpYnV0ZSBiaW5kaW5nXG4gICAgICAgIGJpbmRBdHRyaWJ1dGVzT25lV2F5KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGV4dFwiPiwgPGlucHV0PiwgYW5kIDx0ZXh0YXJlYT46IDItd2F5IGJpbmRpbmdcbiAgICAgIGVsc2UgaWYgKCRub2RlLmlzKCdpbnB1dDp0ZXh0LCBpbnB1dFt0eXBlIT1cInNlYXJjaFwiXSwgdGV4dGFyZWEnKSkge1xuICAgICAgICAvLyBNb2RlbCAtLT4gRE9NXG4gICAgICAgIHNlbGYuYmluZCgnX2NoYW5nZTonK2JpbmREYXRhLmtleSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAkbm9kZS52YWwoc2VsZi5tb2RlbC5nZXQoYmluZERhdGEua2V5KSk7IC8vIHRoaXMgd29uJ3QgZmlyZSBhIERPTSAnY2hhbmdlJyBldmVudCwgc2F2aW5nIHVzIGZyb20gYW4gaW5maW5pdGUgZXZlbnQgbG9vcCAoTW9kZWwgPC0tPiBET00pXG4gICAgICAgIH0pOyAgICAgICAgICAgIFxuICAgICAgICAvLyBNb2RlbCA8LS0gRE9NXG4gICAgICAgICRub2RlLmNoYW5nZShmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgICBvYmpbYmluZERhdGEua2V5XSA9ICQodGhpcykudmFsKCk7XG4gICAgICAgICAgc2VsZi5tb2RlbC5zZXQob2JqKTsgLy8gbm90IHNpbGVudCBhcyB1c2VyIG1pZ2h0IGJlIGxpc3RlbmluZyB0byBjaGFuZ2UgZXZlbnRzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyAxLXdheSBhdHRyaWJ1dGUgYmluZGluZ1xuICAgICAgICBiaW5kQXR0cmlidXRlc09uZVdheSgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBhbGwgb3RoZXIgPHRhZz5zOiAxLXdheSBiaW5kaW5nIChNb2RlbCAtPiBET00pXG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGJpbmREYXRhLmtleSkge1xuICAgICAgICAgIHNlbGYuYmluZCgnX2NoYW5nZTonK2JpbmREYXRhLmtleSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBrZXkgPSBzZWxmLm1vZGVsLmdldChiaW5kRGF0YS5rZXkpO1xuICAgICAgICAgICAgaWYgKGtleSB8fCBrZXk9PT0wKSB7XG4gICAgICAgICAgICAgICRub2RlLnRleHQoc2VsZi5tb2RlbC5nZXQoYmluZERhdGEua2V5KS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRub2RlLnRleHQoJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJpbmRBdHRyaWJ1dGVzT25lV2F5KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIGJpbmRpbmcgbWFwIGZvciBsYXRlciByZWZlcmVuY2VcblxuICAgICAgc2VsZi4kbm9kZVsgYmluZERhdGEua2V5IF0gPSAkbm9kZTtcbiAgICAgIHNlbGYua2V5WyAkbm9kZSBdID0gYmluZERhdGEua2V5OyAvLyBVbm5lY2Vzc2FyeT9cblxuICAgICAgaWYgKCB0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICBzZWxmLnJlcXVpcmVkWyBiaW5kRGF0YS5rZXkgXSA9IHJlcXVpcmVkO1xuICAgICAgfVxuXG4gICAgfSk7IC8vIG5vZGVzLmVhY2goKVxuICAgIHJldHVybiB0aGlzO1xuICB9LCAvLyBiaW5kaW5ncygpXG4gIFxuXG4gIC8vIFRyaWdnZXJzIF9jaGFuZ2UgYW5kIF9jaGFuZ2U6KiBldmVudHMgc28gdGhhdCB2aWV3IGlzIHVwZGF0ZWQgYXMgcGVyIHZpZXcuYmluZGluZ3MoKVxuICBzeW5jOiBmdW5jdGlvbigpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBUcmlnZ2VyIGNoYW5nZSBldmVudHMgc28gdGhhdCB2aWV3IGlzIHVwZGF0ZWQgYWNjb3JkaW5nIHRvIG1vZGVsXG4gICAgdGhpcy5tb2RlbC5lYWNoKGZ1bmN0aW9uKGtleSwgdmFsKXtcbiAgICAgIHNlbGYudHJpZ2dlcignX2NoYW5nZTonK2tleSk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMubW9kZWwuc2l6ZSgpID4gMCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdfY2hhbmdlJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLy8gQXBwbGllcyBzdHlsZSBkeW5hbWljYWxseVxuICBzdHlsaXplOiBmdW5jdGlvbigpe1xuICAgIHZhciBvYmpDbGFzcyxcbiAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKFJPT1RfU0VMRUNUT1IsICdnJyk7XG4gICAgaWYgKHRoaXMudmlldy5zdHlsZS5sZW5ndGggPT09IDAgfHwgdGhpcy52aWV3LiQoKS5zaXplKCkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gT3duIHN0eWxlXG4gICAgLy8gT2JqZWN0IGdldHMgb3duIGNsYXNzIG5hbWUgXCIuYWdpbGl0eV8xMjNcIiwgYW5kIDxoZWFkPiBnZXRzIGEgY29ycmVzcG9uZGluZyA8c3R5bGU+XG4gICAgaWYgKHRoaXMudmlldy5oYXNPd25Qcm9wZXJ0eSgnc3R5bGUnKSkge1xuICAgICAgb2JqQ2xhc3MgPSAnYWdpbGl0eV8nICsgdGhpcy5faWQ7XG4gICAgICB2YXIgc3R5bGVTdHIgPSB0aGlzLnZpZXcuc3R5bGUucmVwbGFjZShyZWdleCwgJy4nK29iakNsYXNzKTtcbiAgICAgIC8vICQoJ2hlYWQnLCB3aW5kb3cuZG9jdW1lbnQpLmFwcGVuZCgnPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPicrc3R5bGVTdHIrJzwvc3R5bGU+Jyk7XG5cbiAgICAgIC8vIEBwdWxsICM5NSBBZGQgSUQgc28gbGF0ZXIgd2UgY2FuIHJlbW92ZSBnZW5lcmF0ZWQgc3R5bGVcbiAgICAgIC8vIHVwb24gZGVzdHJ1Y3Rpb24gb2Ygb2JqZWN0c1xuICAgICAgJCgnaGVhZCcsIHdpbmRvdy5kb2N1bWVudCkuYXBwZW5kKCc8c3R5bGUgaWQ9XCInKyBvYmpDbGFzcyArJ1wiIHR5cGU9XCJ0ZXh0L2Nzc1wiPicrXG4gICAgICAgIHN0eWxlU3RyKyc8L3N0eWxlPicpO1xuICAgICAgdGhpcy52aWV3LiQoKS5hZGRDbGFzcyhvYmpDbGFzcyk7XG4gICAgfVxuICAgIC8vIEluaGVyaXRlZCBzdHlsZVxuICAgIC8vIE9iamVjdCBpbmhlcml0cyBDU1MgY2xhc3MgbmFtZSBmcm9tIGZpcnN0IGFuY2VzdG9yIHRvIGhhdmUgb3duIHZpZXcuc3R5bGVcbiAgICBlbHNlIHtcbiAgICAgIC8vIFJldHVybnMgaWQgb2YgZmlyc3QgYW5jZXN0b3IgdG8gaGF2ZSAnb3duJyB2aWV3LnN0eWxlXG4gICAgICB2YXIgYW5jZXN0b3JXaXRoU3R5bGUgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgd2hpbGUgKG9iamVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG9iamVjdCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgICAgIGlmIChvYmplY3Qudmlldy5oYXNPd25Qcm9wZXJ0eSgnc3R5bGUnKSlcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QuX2lkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9OyAvLyBhbmNlc3RvcldpdGhTdHlsZVxuXG4gICAgICB2YXIgYW5jZXN0b3JJZCA9IGFuY2VzdG9yV2l0aFN0eWxlKHRoaXMpO1xuICAgICAgb2JqQ2xhc3MgPSAnYWdpbGl0eV8nICsgYW5jZXN0b3JJZDtcbiAgICAgIHRoaXMudmlldy4kKCkuYWRkQ2xhc3Mob2JqQ2xhc3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIEV4dGVuZGVkXG4gICAqXG4gICAqL1xuXG4gIC8vIFJldHVybiBlbGVtZW50KHMpIGJvdW5kIHRvIGEgbW9kZWwgcHJvcGVydHlcblxuICAvLyBAdG9kbyBQcm92aWRlIGEgcmV2ZXJzZSBmdW5jdGlvbiBmcm9tIGVsZW1lbnRzIC0+IG1vZGVsIHByb3BlcnR5P1xuXG4gICRib3VuZDogZnVuY3Rpb24oIGtleSApIHtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLnZpZXcuJCgnW2RhdGEtYmluZF0nKS5maWx0ZXIoZnVuY3Rpb24oKXtcblxuICAgICAgdmFyIGJpbmREYXRhID0gc2VsZi52aWV3Ll9wYXJzZUJpbmRTdHIoICQodGhpcykuZGF0YSgnYmluZCcpICk7XG5cbiAgICAgIC8vIFdoYXQgYWJvdXQgbXVsdGlwbGUgb3IgbmVzdGVkIGJpbmRpbmdzP1xuICAgICAgcmV0dXJuICggYmluZERhdGEua2V5ID09IGtleSApO1xuICAgIH0pO1xuICB9XG5cbn07XG4iLCJcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogX2NvbnRhaW5lclxuICpcbiAqIEFQSSBhbmQgcmVsYXRlZCBhdXhpbGlhcnkgZnVuY3Rpb25zIGZvciBzdG9yaW5nIGNoaWxkIEFnaWxpdHkgb2JqZWN0cy5cbiAqIE5vdCBhbGwgbWV0aG9kcyBhcmUgZXhwb3NlZC4gU2VlICdzaG9ydGN1dHMnIGJlbG93IGZvciBleHBvc2VkIG1ldGhvZHMuXG4gKlxuICovXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cualF1ZXJ5IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5qUXVlcnkgOiBudWxsKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8vIEFkZHMgY2hpbGQgb2JqZWN0IHRvIGNvbnRhaW5lciwgYXBwZW5kcy9wcmVwZW5kcy9ldGMgdmlldywgbGlzdGVucyBmb3IgY2hpbGQgcmVtb3ZhbFxuICBfaW5zZXJ0T2JqZWN0OiBmdW5jdGlvbihvYmosIHNlbGVjdG9yLCBtZXRob2Qpe1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICghdXRpbC5pc0FnaWxpdHkob2JqKSkge1xuICAgICAgdGhyb3cgXCJhZ2lsaXR5LmpzOiBhcHBlbmQgYXJndW1lbnQgaXMgbm90IGFuIGFnaWxpdHkgb2JqZWN0XCI7XG4gICAgfVxuXG4gICAgdGhpcy5fY29udGFpbmVyLmNoaWxkcmVuW29iai5faWRdID0gb2JqOyAvLyBjaGlsZHJlbiBpcyAqbm90KiBhbiBhcnJheTsgdGhpcyBpcyBmb3Igc2ltcGxlciBsb29rdXBzIGJ5IGdsb2JhbCBvYmplY3QgaWRcbiAgICB0aGlzLnRyaWdnZXIobWV0aG9kLCBbb2JqLCBzZWxlY3Rvcl0pO1xuICAgIG9iai5fcGFyZW50ID0gdGhpcztcbiAgICAvLyBlbnN1cmVzIG9iamVjdCBpcyByZW1vdmVkIGZyb20gY29udGFpbmVyIHdoZW4gZGVzdHJveWVkOlxuICAgIG9iai5iaW5kKCdkZXN0cm95JywgZnVuY3Rpb24oZXZlbnQsIGlkKXsgXG4gICAgICBzZWxmLl9jb250YWluZXIucmVtb3ZlKGlkKTtcbiAgICB9KTtcbiAgICAvLyBUcmlnZ2VyIGV2ZW50IGZvciBjaGlsZCB0byBsaXN0ZW4gdG9cbiAgICBvYmoudHJpZ2dlcigncGFyZW50OicrbWV0aG9kKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBhcHBlbmQ6IGZ1bmN0aW9uKG9iaiwgc2VsZWN0b3IpIHsgXG4gICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyLl9pbnNlcnRPYmplY3QuY2FsbCh0aGlzLCBvYmosIHNlbGVjdG9yLCAnYXBwZW5kJyk7IFxuICB9LFxuXG4gIHByZXBlbmQ6IGZ1bmN0aW9uKG9iaiwgc2VsZWN0b3IpIHsgXG4gICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyLl9pbnNlcnRPYmplY3QuY2FsbCh0aGlzLCBvYmosIHNlbGVjdG9yLCAncHJlcGVuZCcpOyBcbiAgfSxcblxuICBhZnRlcjogZnVuY3Rpb24ob2JqLCBzZWxlY3RvcikgeyBcbiAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXIuX2luc2VydE9iamVjdC5jYWxsKHRoaXMsIG9iaiwgc2VsZWN0b3IsICdhZnRlcicpOyBcbiAgfSxcblxuICBiZWZvcmU6IGZ1bmN0aW9uKG9iaiwgc2VsZWN0b3IpIHsgXG4gICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyLl9pbnNlcnRPYmplY3QuY2FsbCh0aGlzLCBvYmosIHNlbGVjdG9yLCAnYmVmb3JlJyk7IFxuICB9LFxuICBcbiAgLy8gUmVtb3ZlcyBjaGlsZCBvYmplY3QgZnJvbSBjb250YWluZXJcbiAgcmVtb3ZlOiBmdW5jdGlvbihpZCl7XG4gICAgZGVsZXRlIHRoaXMuX2NvbnRhaW5lci5jaGlsZHJlbltpZF07XG4gICAgdGhpcy50cmlnZ2VyKCdyZW1vdmUnLCBpZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gSXRlcmF0ZXMgb3ZlciBhbGwgY2hpbGQgb2JqZWN0cyBpbiBjb250YWluZXJcbiAgZWFjaDogZnVuY3Rpb24oZm4pe1xuICAgICQuZWFjaCh0aGlzLl9jb250YWluZXIuY2hpbGRyZW4sIGZuKTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluYWJsZSBjYWxsc1xuICB9LFxuXG4gIC8vIFJlbW92ZXMgYWxsIG9iamVjdHMgaW4gY29udGFpbmVyXG4gIGVtcHR5OiBmdW5jdGlvbigpe1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIFxuICAvLyBOdW1iZXIgb2YgY2hpbGRyZW5cbiAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0aWwuc2l6ZSh0aGlzLl9jb250YWluZXIuY2hpbGRyZW4pO1xuICB9XG4gIFxufTtcbiIsIlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBfZXZlbnRzIEFQSSBhbmQgYXV4aWxpYXJ5IGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgZXZlbnRzXG4gKlxuICovXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cualF1ZXJ5IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5qUXVlcnkgOiBudWxsKSxcbiAgICBST09UX1NFTEVDVE9SID0gJyYnOyAvLyBBbHNvIGluIG12Yy92aWV3LmpzXG5cbi8vIFJldmVyc2VzIHRoZSBvcmRlciBvZiBldmVudHMgYXR0YWNoZWQgdG8gYW4gb2JqZWN0XG5mdW5jdGlvbiByZXZlcnNlRXZlbnRzKG9iaiwgZXZlbnRUeXBlKXtcbiAgdmFyIGV2ZW50cyA9ICQob2JqKS5kYXRhKCdldmVudHMnKTtcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkICYmIGV2ZW50c1tldmVudFR5cGVdICE9PSB1bmRlZmluZWQpe1xuICAgIC8vIGNhbid0IHJldmVyc2Ugd2hhdCdzIG5vdCB0aGVyZVxuICAgIHZhciByZXZlcnNlZEV2ZW50cyA9IFtdO1xuICAgIGZvciAodmFyIGUgaW4gZXZlbnRzW2V2ZW50VHlwZV0pe1xuICAgICAgaWYgKCFldmVudHNbZXZlbnRUeXBlXS5oYXNPd25Qcm9wZXJ0eShlKSkgY29udGludWU7XG4gICAgICByZXZlcnNlZEV2ZW50cy51bnNoaWZ0KGV2ZW50c1tldmVudFR5cGVdW2VdKTtcbiAgICB9XG4gICAgZXZlbnRzW2V2ZW50VHlwZV0gPSByZXZlcnNlZEV2ZW50cztcbiAgfVxufSAvL3JldmVyc2VFdmVudHNcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvLyBQYXJzZXMgZXZlbnQgc3RyaW5nIGxpa2U6XG4gIC8vICAgICdldmVudCcgICAgICAgICAgOiBjdXN0b20gZXZlbnRcbiAgLy8gICAgJ2V2ZW50IHNlbGVjdG9yJyA6IERPTSBldmVudCB1c2luZyAnc2VsZWN0b3InXG4gIC8vIFJldHVybnMgeyB0eXBlOidldmVudCcgWywgc2VsZWN0b3I6J3NlbGVjdG9yJ10gfVxuICBwYXJzZUV2ZW50U3RyOiBmdW5jdGlvbihldmVudFN0cil7XG4gICAgdmFyIGV2ZW50T2JqID0geyB0eXBlOmV2ZW50U3RyIH0sIFxuICAgICAgICBzcGFjZVBvcyA9IGV2ZW50U3RyLnNlYXJjaCgvXFxzLyk7XG4gICAgLy8gRE9NIGV2ZW50ICdldmVudCBzZWxlY3RvcicsIGUuZy4gJ2NsaWNrIGJ1dHRvbidcbiAgICBpZiAoc3BhY2VQb3MgPiAtMSkge1xuICAgICAgZXZlbnRPYmoudHlwZSA9IGV2ZW50U3RyLnN1YnN0cigwLCBzcGFjZVBvcyk7XG4gICAgICBldmVudE9iai5zZWxlY3RvciA9IGV2ZW50U3RyLnN1YnN0cihzcGFjZVBvcysxKTtcbiAgICB9IGVsc2UgaWYgKCBldmVudFN0ciA9PT0gJ2NsaWNrJyB8fCBldmVudFN0ciA9PT0gJ3N1Ym1pdCcgKSB7XG4gICAgICAvLyBAZXh0ZW5kIFNob3J0Y3V0IGZvciAnY2xpY2sgJicgYW5kICdzdWJtaXQgJidcbiAgICAgIGV2ZW50T2JqLnR5cGUgPSBldmVudFN0cjtcbiAgICAgIGV2ZW50T2JqLnNlbGVjdG9yID0gUk9PVF9TRUxFQ1RPUjtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50T2JqO1xuICB9LFxuXG4gIC8vIEJpbmRzIGV2ZW50U3RyIHRvIGZuLiBldmVudFN0ciBpcyBwYXJzZWQgYXMgcGVyIHBhcnNlRXZlbnRTdHIoKVxuICBiaW5kOiBmdW5jdGlvbihldmVudFN0ciwgZm4pe1xuXG4gICAgdmFyIGV2ZW50T2JqID0gdGhpcy5fZXZlbnRzLnBhcnNlRXZlbnRTdHIoZXZlbnRTdHIpO1xuXG4gICAgLy8gRE9NIGV2ZW50ICdldmVudCBzZWxlY3RvcicsIGUuZy4gJ2NsaWNrIGJ1dHRvbidcbiAgICBpZiAoZXZlbnRPYmouc2VsZWN0b3IpIHtcblxuICAgICAgLy8gS2VlcCBjbGljayBhbmQgc3VibWl0IGxvY2FsaXplZFxuICAgICAgdmFyIGZueCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGZuKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBQcmV2ZW50IGRlZmF1bHQgJiBidWJibGluZ1xuICAgICAgICAvLyBvciBqdXN0IGRlZmF1bHQ/IGlmICggISBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBNYW51YWxseSBvdmVycmlkZSByb290IHNlbGVjdG9yLCBhcyBqUXVlcnkgc2VsZWN0b3JzIGNhbid0IHNlbGVjdCBzZWxmIG9iamVjdFxuICAgICAgaWYgKGV2ZW50T2JqLnNlbGVjdG9yID09PSBST09UX1NFTEVDVE9SKSB7XG5cblxuICAgICAgICBpZiAoIGV2ZW50T2JqLnR5cGUgPT09ICdjbGljaycgfHwgZXZlbnRPYmoudHlwZSA9PT0gJ3N1Ym1pdCcgKSB7XG4gICAgICAgICAgdGhpcy52aWV3LiQoKS5vbihldmVudE9iai50eXBlLCBmbngpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudmlldy4kKCkub24oZXZlbnRPYmoudHlwZSwgZm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQGV4dGVuZCBSZXBsYWNlICQoKS5iaW5kIHdpdGggJCgpLm9uXG4gICAgICAgIC8vIHRoaXMudmlldy4kKCkuYmluZChldmVudE9iai50eXBlLCBmbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcblxuICAgICAgICBpZiAoIGV2ZW50T2JqLnR5cGUgPT09ICdjbGljaycgfHwgZXZlbnRPYmoudHlwZSA9PT0gJ3N1Ym1pdCcgKSB7XG4gICAgICAgICAgdGhpcy52aWV3LiQoKS5vbihldmVudE9iai50eXBlLCBldmVudE9iai5zZWxlY3RvciwgZm54KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnZpZXcuJCgpLm9uKGV2ZW50T2JqLnR5cGUsIGV2ZW50T2JqLnNlbGVjdG9yLCBmbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAZXh0ZW5kIFJlcGxhY2UgJCgpLmRlbGVnYXRlIHdpdGggJCgpLm9uXG4gICAgICAgIC8vIHRoaXMudmlldy4kKCkuZGVsZWdhdGUoZXZlbnRPYmouc2VsZWN0b3IsIGV2ZW50T2JqLnR5cGUsIGZuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ3VzdG9tIGV2ZW50XG4gICAgZWxzZSB7XG5cbiAgICAgIC8vIEBleHRlbmQgUmVwbGFjZSAkKCkuYmluZCB3aXRoICQoKS5vblxuICAgICAgJCh0aGlzLl9ldmVudHMuZGF0YSkub24oZXZlbnRPYmoudHlwZSwgZm4pO1xuICAgICAgLy8gJCh0aGlzLl9ldmVudHMuZGF0YSkuYmluZChldmVudE9iai50eXBlLCBmbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5hYmxlIGNhbGxzXG4gIH0sIC8vIGJpbmRcblxuXG4gIC8vIFRyaWdnZXJzIGV2ZW50U3RyLiBTeW50YXggZm9yIGV2ZW50U3RyIGlzIHNhbWUgYXMgdGhhdCBmb3IgYmluZCgpXG4gIHRyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50U3RyLCBwYXJhbXMpe1xuICAgIHZhciBldmVudE9iaiA9IHRoaXMuX2V2ZW50cy5wYXJzZUV2ZW50U3RyKGV2ZW50U3RyKTtcbiAgICAvLyBET00gZXZlbnQgJ2V2ZW50IHNlbGVjdG9yJywgZS5nLiAnY2xpY2sgYnV0dG9uJ1xuICAgIGlmIChldmVudE9iai5zZWxlY3Rvcikge1xuICAgICAgLy8gTWFudWFsbHkgb3ZlcnJpZGUgcm9vdCBzZWxlY3RvciwgYXMgalF1ZXJ5IHNlbGVjdG9ycyBjYW4ndCBzZWxlY3Qgc2VsZiBvYmplY3RcbiAgICAgIGlmIChldmVudE9iai5zZWxlY3RvciA9PT0gUk9PVF9TRUxFQ1RPUikge1xuICAgICAgICB0aGlzLnZpZXcuJCgpLnRyaWdnZXIoZXZlbnRPYmoudHlwZSwgcGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgeyAgICAgICAgICBcbiAgICAgICAgdGhpcy52aWV3LiQoKS5maW5kKGV2ZW50T2JqLnNlbGVjdG9yKS50cmlnZ2VyKGV2ZW50T2JqLnR5cGUsIHBhcmFtcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEN1c3RvbSBldmVudFxuICAgIGVsc2Uge1xuICAgICAgJCh0aGlzLl9ldmVudHMuZGF0YSkudHJpZ2dlcignXycrZXZlbnRPYmoudHlwZSwgcGFyYW1zKTtcbiAgICAgIC8vIGZpcmUgJ3ByZScgaG9va3MgaW4gcmV2ZXJzZSBhdHRhY2htZW50IG9yZGVyICggbGFzdCBmaXJzdCApIHRoZW4gcHV0IHRoZW0gYmFja1xuICAgICAgcmV2ZXJzZUV2ZW50cyh0aGlzLl9ldmVudHMuZGF0YSwgJ3ByZTonICsgZXZlbnRPYmoudHlwZSk7XG4gICAgICAkKHRoaXMuX2V2ZW50cy5kYXRhKS50cmlnZ2VyKCdwcmU6JyArIGV2ZW50T2JqLnR5cGUsIHBhcmFtcyk7XG4gICAgICByZXZlcnNlRXZlbnRzKHRoaXMuX2V2ZW50cy5kYXRhLCAncHJlOicgKyBldmVudE9iai50eXBlKTtcblxuICAgICAgJCh0aGlzLl9ldmVudHMuZGF0YSkudHJpZ2dlcihldmVudE9iai50eXBlLCBwYXJhbXMpO1xuXG4gICAgICAvLyBUcmlnZ2VyIGV2ZW50IGZvciBwYXJlbnRcbiAgICAgIGlmICh0aGlzLnBhcmVudCgpKVxuICAgICAgICB0aGlzLnBhcmVudCgpLnRyaWdnZXIoKGV2ZW50T2JqLnR5cGUubWF0Y2goL15jaGlsZDovKSA/ICcnIDogJ2NoaWxkOicpICsgZXZlbnRPYmoudHlwZSwgcGFyYW1zKTtcbiAgICAgICQodGhpcy5fZXZlbnRzLmRhdGEpLnRyaWdnZXIoJ3Bvc3Q6JyArIGV2ZW50T2JqLnR5cGUsIHBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5hYmxlIGNhbGxzXG4gIH0gLy8gdHJpZ2dlclxuICBcbn07XG4iLCJcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogRXh0ZW5kZWQgc2hvcnRjdXRzXG4gKlxuICovXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cualF1ZXJ5IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5qUXVlcnkgOiBudWxsKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgZ2V0IDogZnVuY3Rpb24oIGFyZyApIHtcbiAgICB0aGlzLm1vZGVsLmdldCggYXJnICk7XG4gIH0sXG5cbiAgc2V0IDogZnVuY3Rpb24oIGFyZywgcGFyYW1zLCB0aGlyZCApIHtcbiAgICB0aGlzLm1vZGVsLnNldCggYXJnLCBwYXJhbXMsIHRoaXJkICApO1xuICB9LFxuXG4gIHJlcGxhY2U6IGZ1bmN0aW9uKCBvYmosIHNlbGVjdG9yICl7XG4gICAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnICkge1xuICAgICAgdGhpcy52aWV3LiQoc2VsZWN0b3IpLmh0bWwoJycpO1xuICAgIH1cbiAgICB0aGlzLmVtcHR5KCkuX2NvbnRhaW5lci5hcHBlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluYWJsZSBjYWxsc1xuICB9LFxuXG4gIC8vIFJldHVybiBudGggY2hpbGQgb2JqZWN0XG4gIGNoaWxkOiBmdW5jdGlvbihuKXtcbiAgICB2YXIgaSA9IDA7XG4gICAgbiA9IG4gfHwgMDtcblxuICAgIGZvciAodmFyIGogaW4gdGhpcy5fY29udGFpbmVyLmNoaWxkcmVuKSB7XG4gICAgICBpZiAoIHRoaXMuX2NvbnRhaW5lci5jaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShqKSApIHtcbiAgICAgICAgaWYgKCBpID09IG4gKVxuICAgICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXIuY2hpbGRyZW5bal07XG4gICAgICAgIGVsc2UgaWYgKCBpID4gbiApXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGkrKzsgLy8gQ29udGludWUgc2VhcmNoaW5nXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvLyBSZXR1cm4gYWxsIGNoaWxkIG9iamVjdHNcbiAgY2hpbGRyZW46IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lci5jaGlsZHJlbjsgLy8geyBpZDogY2hpbGQsIC4uIH1cbiAgfSxcblxuICAvLyBSZXBsYWNlIGNoaWxkcmVuIG1vZGVscyAtIGFwcGVuZCBpZiB0aGVyZSdzIG1vcmUsIGRlc3Ryb3kgaWYgbGVzc1xuICBsb2FkOiBmdW5jdGlvbiggcHJvdG8sIG1vZGVscywgc2VsZWN0b3IgKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIG1heE1vZGVscyA9IG1vZGVscy5sZW5ndGgsXG4gICAgICAgIG1heENoaWxkcmVuID0gdGhpcy5zaXplKCk7XG5cbiAgICAkLmVhY2gobW9kZWxzLCBmdW5jdGlvbihpbmRleCwgbW9kZWwpIHtcbiAgICAgIGlmICggc2VsZi5jaGlsZChpbmRleCkgKSB7XG4gICAgICAgIHNlbGYuY2hpbGQoaW5kZXgpLm1vZGVsLnNldCggbW9kZWwgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICQkIG5vdCBkZWZpbmVkIHlldD9cbiAgICAgICAgc2VsZi5hcHBlbmQoICQkKCBwcm90bywgbW9kZWwgKSwgc2VsZWN0b3IgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChtYXhDaGlsZHJlbiA+IG1heE1vZGVscykge1xuICAgICAgZm9yICh2YXIgaSA9IG1heE1vZGVsczsgaSA8IG1heENoaWxkcmVuOyBpKyspIHtcbiAgICAgICAgLy8gQ2hpbGQncyBpbmRleCBzdGF5cyB0aGUgc2FtZSwgc2luY2UgZWFjaCBvbmUgaXMgZGVzdHJveWVkXG4gICAgICAgIHNlbGYuY2hpbGQobWF4TW9kZWxzKS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufTtcbiIsIlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBGb3JtIGhlbHBlcnNcbiAqXG4gKi9cblxudmFyICQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5qUXVlcnkgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmpRdWVyeSA6IG51bGwpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBmb3JtIDoge1xuXG4gICAgLy8gQ2xlYXIgdGhlIGZvcm1cbiAgICBjbGVhciA6IGZ1bmN0aW9uKCkge1xuXG4gICAgICByZXR1cm4gdGhpcy4kdmlldy5maW5kKCc6aW5wdXQnKVxuICAgICAgICAubm90KCc6YnV0dG9uLCA6c3VibWl0LCA6cmVzZXQsIDpoaWRkZW4nKS5yZW1vdmVBdHRyKCdjaGVja2VkJykucmVtb3ZlQXR0cignc2VsZWN0ZWQnKVxuICAgICAgICAubm90KCc6Y2hlY2tib3gsIDpyYWRpbywgc2VsZWN0JykudmFsKCcnKTtcbiAgICB9LFxuXG4gICAgLy8gVmFsaWRhdGUgbW9kZWwsIGluc3RlYWQgb2YgZm9ybSBpbiB0aGUgRE9NIGRpcmVjdGx5XG4gICAgLy8gQHJldHVybiBBbiBhcnJheSBvZiBpbnZhbGlkIG1vZGVsIHByb3BlcnRpZXNcbiAgICBpbnZhbGlkIDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHJldHVybiB0aGlzLm1vZGVsLmludmFsaWQoKTtcbiAgICB9XG4gIH1cblxufTtcblxuIiwiXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIENvbnN0cnVjdCBkZWZhdWx0IG9iamVjdCBwcm90b3R5cGVcbiAqXG4gKi9cblxudmFyICQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5qUXVlcnkgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmpRdWVyeSA6IG51bGwpLFxuXG4gICAgZGVmYXVsdFByb3RvdHlwZSA9IHtcblxuICAgICAgX2FnaWxpdHk6IHRydWUsXG4gICAgICBfY29udGFpbmVyOiByZXF1aXJlKCcuL2NvbnRhaW5lcicpLFxuICAgICAgX2V2ZW50czogcmVxdWlyZSgnLi9ldmVudHMnKSxcblxuICAgICAgJG5vZGU6IHt9LCAvLyBNYXAgb2YgbW9kZWwgcHJvcGVydGllcyAtPiBib3VuZCBlbGVtZW50c1xuICAgICAga2V5OiB7fSwgLy8gTWFwIG9mIGVsZW1lbnRzIC0+IGJvdW5kIG1vZGVsIHByb3BlcnRpZXNcbiAgICAgIHJlcXVpcmVkOiB7fSwgLy8gTWFwIG9mIHJlcXVpcmVkIG1vZGVsIHByb3BlcnRpZXMgYW5kIHJlcXVpcmUgdHlwZXNcblxuICAgICAgbW9kZWw6IHJlcXVpcmUoJy4uL212Yy9tb2RlbCcpLFxuICAgICAgdmlldzogcmVxdWlyZSgnLi4vbXZjL3ZpZXcnKSxcbiAgICAgIGNvbnRyb2xsZXI6IHJlcXVpcmUoJy4uL212Yy9jb250cm9sbGVyJylcblxuICAgIH0sXG5cbiAgICBzaG9ydGN1dHMgPSByZXF1aXJlKCcuL3Nob3J0Y3V0cycpLFxuICAgIGV4dGVuZCA9IHJlcXVpcmUoJy4vZXh0ZW5kJyksXG4gICAgZm9ybSA9IHJlcXVpcmUoJy4vZm9ybScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICQuZXh0ZW5kKGRlZmF1bHRQcm90b3R5cGUsIHNob3J0Y3V0cywgZXh0ZW5kLCBmb3JtKTtcbiIsIlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBPYmplY3Qgc2hvcnRjdXRzXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudHJpZ2dlcignZGVzdHJveScsIHRoaXMuX2lkKTsgLy8gcGFyZW50IG11c3QgbGlzdGVuIHRvICdyZW1vdmUnIGV2ZW50IGFuZCBoYW5kbGUgY29udGFpbmVyIHJlbW92YWwhXG4gICAgLy8gY2FuJ3QgcmV0dXJuIHRoaXMgYXMgaXQgbWlnaHQgbm90IGV4aXN0IGFueW1vcmUhXG4gIH0sXG4gIHBhcmVudDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICB9LFxuICBcbiAgLy9cbiAgLy8gX2NvbnRhaW5lciBzaG9ydGN1dHNcbiAgLy9cbiAgYXBwZW5kOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluYWJsZSBjYWxsc1xuICB9LFxuICBwcmVwZW5kOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX2NvbnRhaW5lci5wcmVwZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmFibGUgY2FsbHNcbiAgfSxcbiAgYWZ0ZXI6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fY29udGFpbmVyLmFmdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmFibGUgY2FsbHNcbiAgfSxcbiAgYmVmb3JlOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX2NvbnRhaW5lci5iZWZvcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluYWJsZSBjYWxsc1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5hYmxlIGNhbGxzXG4gIH0sXG4gIHNpemU6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lci5zaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGVhY2g6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lci5lYWNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGVtcHR5OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9jb250YWluZXIuZW1wdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvL1xuICAvLyBfZXZlbnRzIHNob3J0Y3V0c1xuICAvL1xuICBiaW5kOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX2V2ZW50cy5iaW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmFibGUgY2FsbHNcbiAgfSxcbiAgb246IGZ1bmN0aW9uKCl7IC8vIEFsaWFzXG4gICAgdGhpcy5fZXZlbnRzLmJpbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluYWJsZSBjYWxsc1xuICB9LFxuICB0cmlnZ2VyOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX2V2ZW50cy50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmFibGUgY2FsbHNcbiAgfSxcblxufTtcbiIsIlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBTaGltIGZvcjogT2JqZWN0LmNyZWF0ZSBhbmQgT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gKlxuICovXG5cblxuLypqc2xpbnQgcHJvdG86IHRydWUgKi9cblxuLy8gTW9kaWZpZWQgZnJvbSBEb3VnbGFzIENyb2NrZm9yZCdzIE9iamVjdC5jcmVhdGUoKVxuLy8gVGhlIGNvbmRpdGlvbiBiZWxvdyBlbnN1cmVzIHdlIG92ZXJyaWRlIG90aGVyIG1hbnVhbCBpbXBsZW1lbnRhdGlvbnNcbmlmICghT2JqZWN0LmNyZWF0ZSB8fCBPYmplY3QuY3JlYXRlLnRvU3RyaW5nKCkuc2VhcmNoKC9uYXRpdmUgY29kZS9pKTwwKSB7XG4gIE9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbihvYmope1xuICAgIHZhciBBdXggPSBmdW5jdGlvbigpe307XG4gICAgJC5leHRlbmQoQXV4LnByb3RvdHlwZSwgb2JqKTsgLy8gc2ltcGx5IHNldHRpbmcgQXV4LnByb3RvdHlwZSA9IG9iaiBzb21laG93IG1lc3NlcyB3aXRoIGNvbnN0cnVjdG9yLCBzbyBnZXRQcm90b3R5cGVPZiB3b3VsZG4ndCB3b3JrIGluIElFXG4gICAgcmV0dXJuIG5ldyBBdXgoKTtcbiAgfTtcbn1cblxuLy8gTW9kaWZpZWQgZnJvbSBKb2huIFJlc2lnJ3MgT2JqZWN0LmdldFByb3RvdHlwZU9mKClcbi8vIFRoZSBjb25kaXRpb24gYmVsb3cgZW5zdXJlcyB3ZSBvdmVycmlkZSBvdGhlciBtYW51YWwgaW1wbGVtZW50YXRpb25zXG5pZiAoIU9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YudG9TdHJpbmcoKS5zZWFyY2goL25hdGl2ZSBjb2RlL2kpPDApIHtcbiAgaWYgKCB0eXBlb2YgXCJ0ZXN0XCIuX19wcm90b19fID09PSBcIm9iamVjdFwiICkge1xuICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gICAgICByZXR1cm4gb2JqZWN0Ll9fcHJvdG9fXztcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gICAgICAvLyBNYXkgYnJlYWsgaWYgdGhlIGNvbnN0cnVjdG9yIGhhcyBiZWVuIHRhbXBlcmVkIHdpdGhcbiAgICAgIHJldHVybiBvYmplY3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIH07XG4gIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogVGltZWQgZnVuY3Rpb25zXG4gKlxuICovXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cualF1ZXJ5IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5qUXVlcnkgOiBudWxsKTtcblxudmFyIHRpbWVycyA9IHt9LFxuICAgIGRlZmF1bHRJbnRlcnZhbCA9IDEwMDAwO1xuXG4kLmZuLnRpbWVkQ2xhc3MgPSBmdW5jdGlvbiggY2xhc3NOYW1lLCBkdXJhdGlvbiApIHtcblxuICB2YXIgJHNlbGYgPSAkKHRoaXMpO1xuXG4gIHJldHVybiAkKHRoaXMpLnRpbWVkRm4oXG4gICAgZnVuY3Rpb24oKXsgJHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApOyB9LFxuICAgIGZ1bmN0aW9uKCl7ICRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTsgfSxcbiAgICBkdXJhdGlvbiB8fCBkZWZhdWx0SW50ZXJ2YWxcbiAgKTtcbn07XG5cbiQuZm4udGltZWRUZXh0ID0gZnVuY3Rpb24oIHR4dCwgZHVyYXRpb24gKSB7XG5cbiAgdmFyICRzZWxmID0gJCh0aGlzKTtcblxuICByZXR1cm4gJCh0aGlzKS50aW1lZEZuKFxuICAgIGZ1bmN0aW9uKCl7ICRzZWxmLnRleHQoIHR4dCApOyB9LFxuICAgIGZ1bmN0aW9uKCl7ICRzZWxmLnRleHQoJycpOyB9LFxuICAgIGR1cmF0aW9uIHx8IGRlZmF1bHRJbnRlcnZhbFxuICApO1xufTtcblxuJC5mbi50aW1lZEZuID0gZnVuY3Rpb24oIGlkLCBzdGFydCwgZW5kLCBkdXJhdGlvbiApIHtcblxuICBkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IGRlZmF1bHRJbnRlcnZhbDtcblxuICAvLyBJRCBza2lwcGVkXG4gIGlmICggdHlwZW9mIGlkID09PSAnZnVuY3Rpb24nICkge1xuXG4gICAgZHVyYXRpb24gPSBlbmQgfHwgZHVyYXRpb247XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSBpZDtcblxuICAgIG5ldyBUaW1lcihmdW5jdGlvbigpe1xuICAgICAgZW5kKCk7XG4gICAgfSwgZHVyYXRpb24gKTtcblxuICAgIHJldHVybiBzdGFydCgpO1xuXG4gIC8vIElmIHRpbWVyIElEIGlzIHNldCBhbmQgb25lIGlzIGFscmVhZHkgZ29pbmcsIGFkZCB0byB0aGUgZHVyYXRpb25cbiAgfSBlbHNlIGlmICggdHlwZW9mIHRpbWVyc1tpZF0gIT09ICd1bmRlZmluZWQnICYmICEgdGltZXJzW2lkXS5maW5pc2hlZCApIHtcblxuICAgIHRpbWVyc1tpZF0uYWRkKCBkdXJhdGlvbiApO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB0aW1lcnNbaWRdID0gbmV3IFRpbWVyKGZ1bmN0aW9uKCl7XG4gICAgICBlbmQoKTtcbiAgICB9LCBkdXJhdGlvbiApO1xuXG4gICAgcmV0dXJuIHN0YXJ0KCk7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gVGltZXIoY2FsbGJhY2ssIHRpbWUpIHtcbiAgICB0aGlzLnNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWUpO1xufVxuXG5UaW1lci5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aW1lKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMudGltZSA9IHRpbWU7XG5cbiAgICBpZih0aGlzLnRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICB9XG4gICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHNlbGYuY2FsbGJhY2soKTtcbiAgICB9LCB0aW1lKTtcbiAgICB0aGlzLnN0YXJ0ID0gRGF0ZS5ub3coKTtcbn07XG5cblRpbWVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih0aW1lKSB7XG4gICBpZighdGhpcy5maW5pc2hlZCkge1xuICAgICAgIC8vIGFkZCB0aW1lIHRvIHRpbWUgbGVmdFxuICAgICAgIHRpbWUgPSB0aGlzLnRpbWUgLSAoRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnQpICsgdGltZTtcbiAgICAgICB0aGlzLnNldFRpbWVvdXQodGhpcy5jYWxsYmFjaywgdGltZSk7XG4gICB9XG59O1xuIiwiXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIHV0aWwuKlxuICpcbiAqIGlzQWdpbGl0eVxuICogcHJveHlBbGxcbiAqIHJldmVyc2VFdmVudHNcbiAqIHNpemVcbiAqIGV4dGVuZENvbnRyb2xsZXJcbiAqXG4gKiAkLm91dGVySFRNTFxuICogJC5pc0VtcHR5XG4gKiBcbiAqL1xuXG4vKmpzbGludCBsb29wZnVuYzogdHJ1ZSAqL1xuXG52YXIgdXRpbCA9IHt9LFxuICAgICQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5qUXVlcnkgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmpRdWVyeSA6IG51bGwpO1xuXG4vLyBDaGVja3MgaWYgcHJvdmlkZWQgb2JqIGlzIGFuIGFnaWxpdHkgb2JqZWN0XG51dGlsLmlzQWdpbGl0eSA9IGZ1bmN0aW9uKG9iail7XG4gcmV0dXJuIG9iai5fYWdpbGl0eSA9PT0gdHJ1ZTtcbn07XG5cbi8vIFNjYW5zIG9iamVjdCBmb3IgZnVuY3Rpb25zIChkZXB0aD0yKSBhbmQgcHJveGllcyB0aGVpciAndGhpcycgdG8gZGVzdC5cbi8vICogVG8gZW5zdXJlIGl0IHdvcmtzIHdpdGggcHJldmlvdXNseSBwcm94aWVkIG9iamVjdHMsIHdlIHNhdmUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGFzIFxuLy8gICBhICcuX3ByZVByb3h5JyBtZXRob2QgYW5kIHdoZW4gYXZhaWxhYmxlIGFsd2F5cyB1c2UgdGhhdCBhcyB0aGUgcHJveHkgc291cmNlLlxuLy8gKiBUbyBza2lwIGEgZ2l2ZW4gbWV0aG9kLCBjcmVhdGUgYSBzdWItbWV0aG9kIGNhbGxlZCAnX25vUHJveHknLlxudXRpbC5wcm94eUFsbCA9IGZ1bmN0aW9uKG9iaiwgZGVzdCl7XG4gIGlmICghb2JqIHx8ICFkZXN0KSB7XG4gICAgdGhyb3cgXCJhZ2lsaXR5LmpzOiB1dGlsLnByb3h5QWxsIG5lZWRzIHR3byBhcmd1bWVudHNcIjtcbiAgfVxuICBmb3IgKHZhciBhdHRyMSBpbiBvYmopIHtcbiAgICB2YXIgcHJveGllZCA9IG9ialthdHRyMV07XG4gICAgLy8gUHJveHkgcm9vdCBtZXRob2RzXG4gICAgaWYgKHR5cGVvZiBvYmpbYXR0cjFdID09PSAnZnVuY3Rpb24nICkge1xuXG4gICAgICBwcm94aWVkID0gb2JqW2F0dHIxXS5fbm9Qcm94eSA/IG9ialthdHRyMV0gOiAkLnByb3h5KG9ialthdHRyMV0uX3ByZVByb3h5IHx8IG9ialthdHRyMV0sIGRlc3QpO1xuICAgICAgcHJveGllZC5fcHJlUHJveHkgPSBvYmpbYXR0cjFdLl9ub1Byb3h5ID8gdW5kZWZpbmVkIDogKG9ialthdHRyMV0uX3ByZVByb3h5IHx8IG9ialthdHRyMV0pOyAvLyBzYXZlIG9yaWdpbmFsXG4gICAgICBvYmpbYXR0cjFdID0gcHJveGllZDtcblxuICAgIH1cbiAgICAvLyBQcm94eSBzdWItbWV0aG9kcyAobW9kZWwuKiwgdmlldy4qLCBldGMpIC0tIGV4Y2VwdCBmb3IgalF1ZXJ5IG9iamVjdFxuICAgIGVsc2UgaWYgKHR5cGVvZiBvYmpbYXR0cjFdID09PSAnb2JqZWN0JyAmJiAhKG9ialthdHRyMV0gaW5zdGFuY2VvZiBqUXVlcnkpICkge1xuICAgICAgZm9yICh2YXIgYXR0cjIgaW4gb2JqW2F0dHIxXSkge1xuICAgICAgICB2YXIgcHJveGllZDIgPSBvYmpbYXR0cjFdW2F0dHIyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmpbYXR0cjFdW2F0dHIyXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHByb3hpZWQyID0gb2JqW2F0dHIxXVthdHRyMl0uX25vUHJveHkgPyBvYmpbYXR0cjFdW2F0dHIyXSA6ICQucHJveHkob2JqW2F0dHIxXVthdHRyMl0uX3ByZVByb3h5IHx8IG9ialthdHRyMV1bYXR0cjJdLCBkZXN0KTtcbiAgICAgICAgICBwcm94aWVkMi5fcHJlUHJveHkgPSBvYmpbYXR0cjFdW2F0dHIyXS5fbm9Qcm94eSA/IHVuZGVmaW5lZCA6IChvYmpbYXR0cjFdW2F0dHIyXS5fcHJlUHJveHkgfHwgb2JqW2F0dHIxXVthdHRyMl0pOyAvLyBzYXZlIG9yaWdpbmFsXG4gICAgICAgICAgcHJveGllZFthdHRyMl0gPSBwcm94aWVkMjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3IgYXR0cjJcbiAgICAgIG9ialthdHRyMV0gPSBwcm94aWVkO1xuICAgIH0gLy8gaWYgbm90IGZ1bmNcbiAgfSAvLyBmb3IgYXR0cjFcbn07IC8vIHByb3h5QWxsXG5cblxuLy8gRGV0ZXJtaW5lcyAjIG9mIGF0dHJpYnV0ZXMgb2YgZ2l2ZW4gb2JqZWN0IChwcm90b3R5cGUgaW5jbHVzaXZlKVxudXRpbC5zaXplID0gZnVuY3Rpb24ob2JqKXtcbiAgdmFyIHNpemUgPSAwLCBrZXk7XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIHNpemUrKztcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn07XG5cbi8vIEZpbmQgY29udHJvbGxlcnMgdG8gYmUgZXh0ZW5kZWQgKHdpdGggc3ludGF4ICd+JyksIHJlZGVmaW5lIHRob3NlIHRvIGVuY29tcGFzcyBwcmV2aW91c2x5IGRlZmluZWQgY29udHJvbGxlcnNcbi8vIEV4YW1wbGU6XG4vLyAgIHZhciBhID0gJCQoe30sICc8YnV0dG9uPkE8L2J1dHRvbj4nLCB7J2NsaWNrICYnOiBmdW5jdGlvbigpeyBhbGVydCgnQScpOyB9fSk7XG4vLyAgIHZhciBiID0gJCQoYSwge30sICc8YnV0dG9uPkI8L2J1dHRvbj4nLCB7J35jbGljayAmJzogZnVuY3Rpb24oKXsgYWxlcnQoJ0InKTsgfX0pO1xuLy8gQ2xpY2tpbmcgb24gYnV0dG9uIEIgd2lsbCBhbGVydCBib3RoICdBJyBhbmQgJ0InLlxudXRpbC5leHRlbmRDb250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGZvciAodmFyIGNvbnRyb2xsZXJOYW1lIGluIG9iamVjdC5jb250cm9sbGVyKSB7XG5cbiAgICAvLyBuZXcgc2NvcGUgYXMgd2UgbmVlZCBvbmUgbmV3IGZ1bmN0aW9uIGhhbmRsZXIgcGVyIGNvbnRyb2xsZXJcbiAgICAoZnVuY3Rpb24oKXtcbiAgICAgIHZhciBtYXRjaGVzLCBleHRlbmQsIGV2ZW50TmFtZSxcbiAgICAgICAgICBwcmV2aW91c0hhbmRsZXIsIGN1cnJlbnRIYW5kbGVyLCBuZXdIYW5kbGVyO1xuXG4gICAgICBpZiAodHlwZW9mIG9iamVjdC5jb250cm9sbGVyW2NvbnRyb2xsZXJOYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtYXRjaGVzID0gY29udHJvbGxlck5hbWUubWF0Y2goL14oXFx+KSooLispLyk7IC8vICdjbGljayBidXR0b24nLCAnfmNsaWNrIGJ1dHRvbicsICdfY3JlYXRlJywgZXRjXG4gICAgICAgIGV4dGVuZCA9IG1hdGNoZXNbMV07XG4gICAgICAgIGV2ZW50TmFtZSA9IG1hdGNoZXNbMl07XG4gICAgICBcbiAgICAgICAgaWYgKCFleHRlbmQpIHJldHVybjsgLy8gbm90aGluZyB0byBkb1xuXG4gICAgICAgIC8vIFJlZGVmaW5lIGNvbnRyb2xsZXI6XG4gICAgICAgIC8vICd+Y2xpY2sgYnV0dG9uJyAtLS0+ICdjbGljayBidXR0b24nID0gcHJldmlvdXNIYW5kbGVyICsgY3VycmVudEhhbmRsZXJcbiAgICAgICAgcHJldmlvdXNIYW5kbGVyID0gb2JqZWN0LmNvbnRyb2xsZXJbZXZlbnROYW1lXSA/IChvYmplY3QuY29udHJvbGxlcltldmVudE5hbWVdLl9wcmVQcm94eSB8fCBvYmplY3QuY29udHJvbGxlcltldmVudE5hbWVdKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY3VycmVudEhhbmRsZXIgPSBvYmplY3QuY29udHJvbGxlcltjb250cm9sbGVyTmFtZV07XG4gICAgICAgIG5ld0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAocHJldmlvdXNIYW5kbGVyKSBwcmV2aW91c0hhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBpZiAoY3VycmVudEhhbmRsZXIpIGN1cnJlbnRIYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb2JqZWN0LmNvbnRyb2xsZXJbZXZlbnROYW1lXSA9IG5ld0hhbmRsZXI7XG4gICAgICAgIGRlbGV0ZSBvYmplY3QuY29udHJvbGxlcltjb250cm9sbGVyTmFtZV07IC8vIGRlbGV0ZSAnfmNsaWNrIGJ1dHRvbidcbiAgICAgIH0gLy8gaWYgZnVuY3Rpb25cbiAgICB9KSgpO1xuICB9IC8vIGZvciBjb250cm9sbGVyTmFtZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsO1xuXG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogalF1ZXJ5IHV0aWxpdHkgZnVuY3Rpb25zXG4gKlxuICovXG5cbi8vIEdldCBlbGVtZW50IGluY2x1ZGluZyB3cmFwcGluZyB0YWdcbndpbmRvdy5qUXVlcnkuZm4ub3V0ZXJIVE1MID0gZnVuY3Rpb24ocykge1xuICBpZiAocykge1xuICAgIHJldHVybiB0aGlzLmJlZm9yZShzKS5yZW1vdmUoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZG9jID0gdGhpc1swXSA/IHRoaXNbMF0ub3duZXJEb2N1bWVudCA6IGRvY3VtZW50O1xuICAgIHJldHVybiBqUXVlcnkoJzxkaXY+JywgZG9jKS5hcHBlbmQodGhpcy5lcSgwKS5jbG9uZSgpKS5odG1sKCk7XG4gIH1cbn07XG5cbndpbmRvdy5qUXVlcnkuaXNFbXB0eSA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXG4gIGlmKHR5cGVvZihkYXRhKSA9PSAnbnVtYmVyJyB8fCB0eXBlb2YoZGF0YSkgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmKHR5cGVvZihkYXRhKSA9PSAndW5kZWZpbmVkJyB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYodHlwZW9mKGRhdGEubGVuZ3RoKSAhPSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBkYXRhLmxlbmd0aCA9PSAwO1xuICB9XG5cbiAgdmFyIGNvdW50ID0gMDtcbiAgZm9yKHZhciBpIGluIGRhdGEpIHtcbiAgICBpZihkYXRhLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBjb3VudCArKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50ID09IDA7XG59O1xuIiwiXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIHdwLmFjdGlvblxuICogXG4gKiAtIGdldCwgc2F2ZVxuICogLSBsb2dpbiwgbG9nb3V0LCBnbywgcmVsb2FkXG4gKlxuICovXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cualF1ZXJ5IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5qUXVlcnkgOiBudWxsKTtcbnZhciB3cEFqYXggPSByZXF1aXJlKCcuL2FqYXguanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAkLmV4dGVuZCggd2luZG93LndwLmFjdGlvbiB8fCB7fSwge1xuXG4gIC8qKlxuICAgKlxuICAgKiBnZXQoIFt0eXBlLF0geyBxdWVyeSB9IClcbiAgICogXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICAgQ29udGVudCB0eXBlOiBwb3N0cywgdXNlcnNcbiAgICogQHBhcmFtIHtvYmplY3R9IHF1ZXJ5ICBRdWVyeSBhcmd1bWVudHNcbiAgICogXG4gICAqIEB0b2RvIHRheG9ub215LCBjb21tZW50c1xuICAgKlxuICAgKi9cblxuICBnZXQgOiBmdW5jdGlvbigpIHtcblxuICAgIC8vIERlZmF1bHQ6IGdldF9wb3N0c1xuICAgIHZhciB0eXBlID0gJ3Bvc3RzJztcblxuICAgIC8vIEZvciBvdGhlciBjb250ZW50IHR5cGVzOiBnZXRfdXNlciwgZ2V0X3RheG9ub215LCAuLi5cbiAgICB2YXIgbm9uUG9zdFR5cGVzID0gWyAndXNlcicsICd1c2VycycsICd0YXhvbm9teScsICdmaWVsZCcsICdmaWVsZHMnIF07XG5cbiAgICAvLyBDcmVhdGUgYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgaWYgKCBhcmdzLmxlbmd0aCA9PT0gMCApXG4gICAgICB0aHJvdyBcIndwLmFjdGlvbi5nZXQgbmVlZHMgYW4gb2JqZWN0XCI7XG5cbiAgICBpZiAoIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyApIHtcbiAgICAgIHR5cGUgPSBhcmdzWzBdO1xuICAgICAgYXJncy5zaGlmdCgpO1xuICAgIH1cblxuICAgIHJlcXVlc3QgPSBhcmdzWzBdIHx8IHt9O1xuICAgIHN1Y2Nlc3MgPSBhcmdzWzFdIHx8IHt9O1xuICAgIGVycm9yID0gYXJnc1syXSB8fCB7fTtcblxuICAgIGlmICggdHlwZW9mIHJlcXVlc3QudHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiYgJC5pbkFycmF5KHJlcXVlc3QudHlwZSwgbm9uUG9zdFR5cGVzKSA+IC0xICkge1xuICAgICAgdHlwZSA9IHJlcXVlc3QudHlwZTtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0LnR5cGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdwQWpheCggJ2dldF8nK3R5cGUsIHJlcXVlc3QsIHN1Y2Nlc3MsIGVycm9yICk7XG4gIH0sXG5cblxuICAvKipcbiAgICpcbiAgICogc2F2ZSggW3R5cGUsXSB7IGRhdGEgfSApXG4gICAqIFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAgIENvbnRlbnQgdHlwZTogcG9zdCwgdXNlclxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAgIERhdGFcbiAgICogXG4gICAqIEB0b2RvIHRheG9ub215LCBjb21tZW50cy4uXG4gICAqXG4gICAqL1xuXG4gIHNhdmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gRm9yIHBvc3QsIHBhZ2UsIGN1c3RvbSBwb3N0IHR5cGU6IHNhdmVfcG9zdFxuICAgIHZhciB0eXBlID0gJ3Bvc3QnO1xuXG4gICAgLy8gRm9yIG90aGVyIGNvbnRlbnQgdHlwZXM6IHNhdmVfdXNlciwgc2F2ZV90YXhvbm9teSwgLi4uXG4gICAgdmFyIG5vblBvc3RUeXBlcyA9IFsgJ3VzZXInLCAndXNlcnMnLCAndGF4b25vbXknLCAnZmllbGQnLCAnZmllbGRzJyBdO1xuXG4gICAgLy8gQ3JlYXRlIGFycmF5IG9mIGFyZ3VtZW50c1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIGlmICggYXJncy5sZW5ndGggPT09IDAgKVxuICAgICAgdGhyb3cgXCJ3cC5hY3Rpb24uc2F2ZSBuZWVkcyBhbiBvYmplY3RcIjtcblxuICAgIGlmICggdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnICkge1xuICAgICAgdHlwZSA9IGFyZ3NbMF07XG4gICAgICBhcmdzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdCA9IGFyZ3NbMF0gfHwge307XG4gICAgc3VjY2VzcyA9IGFyZ3NbMV0gfHwge307XG4gICAgZXJyb3IgPSBhcmdzWzJdIHx8IHt9O1xuXG4gICAgaWYgKCB0eXBlb2YgcmVxdWVzdC50eXBlICE9PSAndW5kZWZpbmVkJyAmJiAkLmluQXJyYXkocmVxdWVzdC50eXBlLCBub25Qb3N0VHlwZXMpID4gLTEgKSB7XG4gICAgICB0eXBlID0gcmVxdWVzdC50eXBlO1xuICAgICAgZGVsZXRlIHJlcXVlc3QudHlwZTtcbiAgICB9IGVsc2UgaWYgKCB0eXBlID09ICdwb3N0JyAmJiAkLmlzQXJyYXkoIHJlcXVlc3QgKSApIHtcbiAgICAgIHR5cGUgPSAncG9zdHMnO1xuICAgIH1cblxuICAgIHJldHVybiB3cEFqYXgoICdzYXZlXycrdHlwZSwgcmVxdWVzdCwgc3VjY2VzcywgZXJyb3IgKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKlxuICAgKiBsb2dpbiwgbG9nb3V0LCBnbywgcmVsb2FkXG4gICAqXG4gICAqIEB0b2RvIHJlZ2lzdGVyXG4gICAqXG4gICAqL1xuXG5cbiAgbG9naW4gOiBmdW5jdGlvbiggcmVxdWVzdCwgc3VjY2VzcywgZXJyb3IgKSB7XG5cbiAgICByZXR1cm4gd3BBamF4KCAnbG9naW4nLCByZXF1ZXN0LCBzdWNjZXNzLCBlcnJvciApO1xuICB9LFxuXG4gIGxvZ291dCA6IGZ1bmN0aW9uKCByZWRpcmVjdCApIHtcblxuICAgIHZhciBsb2dvdXQgPSB3cC51cmwubG9nb3V0O1xuXG4gICAgaWYgKCB0eXBlb2YgcmVkaXJlY3QgPT09ICd1bmRlZmluZWQnICkgcmVkaXJlY3QgPSB3cC5jdXJyZW50LnJlcXVlc3Q7XG5cbiAgICBsb2dvdXQgKz0gJyZyZWRpcmVjdF90bz0nK3dwLnVybC5zaXRlK3JlZGlyZWN0O1xuICAgIGxvY2F0aW9uLmhyZWYgPSBsb2dvdXQ7XG4gIH0sXG5cbiAgZ28gOiBmdW5jdGlvbiggcm91dGUgKSB7XG4gICAgbG9jYXRpb24uaHJlZiA9IHdwLnVybC5zaXRlK3JvdXRlO1xuICB9LFxuXG4gIHJlbG9hZCA6IGZ1bmN0aW9uKCkge1xuICAgIGxvY2F0aW9uLmhyZWYgPSB3cC5jdXJyZW50LnVybDtcbiAgfSxcblxuICAvKipcbiAgICpcbiAgICogZW1haWxcbiAgICogXG4gICAqL1xuXG4gIG1haWwgOiBmdW5jdGlvbiggbWFpbE9iaiApIHtcblxuICAgIC8vIERlZmF1bHQ6IGdldF9wb3N0c1xuICAgIHZhciB0eXBlID0gJ21haWwnO1xuXG4gICAgLy8gQ3JlYXRlIGFycmF5IG9mIGFyZ3VtZW50c1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIGlmICggYXJncy5sZW5ndGggPT09IDAgKVxuICAgICAgdGhyb3cgXCJ3cC5hY3Rpb24ubWFpbCBuZWVkcyBhbiBvYmplY3RcIjtcblxuICAgIHJlcXVlc3QgPSBhcmdzWzBdIHx8IHt9O1xuICAgIHN1Y2Nlc3MgPSBhcmdzWzFdIHx8IHt9O1xuICAgIGVycm9yID0gYXJnc1syXSB8fCB7fTtcblxuICAgIHJldHVybiB3cEFqYXgoICdzZW5kX2VtYWlsJywgcmVxdWVzdCwgc3VjY2VzcywgZXJyb3IgKTtcbiAgfVxuXG5cbn0pO1xuXG4iLCIvKiBnbG9iYWwgd3AuY3VycmVudC5ub25jZSwgd3AudXJsLmFqYXggKi9cblxudmFyICQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5qUXVlcnkgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmpRdWVyeSA6IG51bGwpO1xuXG5mdW5jdGlvbiB3cEFqYXgoIGFjdGlvbiwgcmVxdWVzdCwgc3VjY2VzcywgZXJyb3IgKSB7XG5cbiAgdmFyIHJlcSA9IHtcbiAgICB0eXBlOiAnUE9TVCcsXG4gICAgdXJsOiB3cC51cmwuYWpheCwgLy8gQUpBWCBVUkwgZnJvbSBzZXJ2ZXItc2lkZVxuICAgIGRhdGE6IHtcbiAgICAgIGFjdGlvbjogJ2FnaWxpdHlfJythY3Rpb24sIC8vIFByZWZpeFxuICAgICAgbm9uY2U6IHdwLmN1cnJlbnQubm9uY2UsIC8vIE5vbmNlIGZyb20gc2VydmVyLXNpZGVcbiAgICAgIGRhdGE6IHJlcXVlc3QgLy8gVGhlIHJlYWwgZGF0YVxuICAgIH0sXG4gICAgYmVmb3JlU2VuZDogJycsXG4gICAgc3VjY2VzczogJycsXG4gICAgZXJyb3I6ICcnXG4gIH07XG5cbiAgLy8gQmFzZWQgb24gd3AtdXRpbC5qc1xuICByZXR1cm4gJC5EZWZlcnJlZCggZnVuY3Rpb24oIGRlZmVycmVkICkge1xuXG4gICAgLy8gVHJhbnNmZXIgc3VjY2Vzcy9lcnJvciBjYWxsYmFja3MuXG4gICAgaWYgKCBzdWNjZXNzIClcbiAgICAgIGRlZmVycmVkLmRvbmUoIHN1Y2Nlc3MgKTtcbiAgICBpZiAoIGVycm9yIClcbiAgICAgIGRlZmVycmVkLmZhaWwoIGVycm9yICk7XG5cbiAgICAvLyBPcHRpb24gdG8gZm9yY2UgcmV0dXJuIGZhaWwgYmVmb3JlIEFqYXggcmVxdWVzdFxuICAgIGlmICggYWN0aW9uID09PSAnZmFpbCcgKVxuICAgICAgZGVmZXJyZWQucmVqZWN0V2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cbiAgICAvLyBVc2Ugd2l0aCBQSFAncyB3cF9zZW5kX2pzb25fc3VjY2VzcygpIGFuZCB3cF9zZW5kX2pzb25fZXJyb3IoKVxuICAgICQuYWpheCggcmVxICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuXG4gICAgICAvLyBUcmVhdCBhIHJlc3BvbnNlIG9mIGAxYCBhcyBzdWNjZXNzZnVsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgaWYgKCByZXNwb25zZSA9PT0gJzEnIHx8IHJlc3BvbnNlID09PSAxIClcbiAgICAgICAgcmVzcG9uc2UgPSB7IHN1Y2Nlc3M6IHRydWUgfTtcblxuICAgICAgaWYgKCB0eXBlb2YgcmVzcG9uc2UuZGF0YSA9PT0gJ3VuZGVmaW5lZCcgKVxuICAgICAgICByZXNwb25zZS5kYXRhID0gJ2VtcHR5JztcblxuICAgICAgaWYgKCB0eXBlb2YgcmVzcG9uc2UgPT09ICdvYmplY3QnICYmICggdHlwZW9mIHJlc3BvbnNlLnN1Y2Nlc3MgIT09ICd1bmRlZmluZWQnICkgKVxuICAgICAgICBkZWZlcnJlZFsgcmVzcG9uc2Uuc3VjY2VzcyA/ICdyZXNvbHZlV2l0aCcgOiAncmVqZWN0V2l0aCcgXSggdGhpcywgW3Jlc3BvbnNlLmRhdGFdICk7XG4gICAgICBlbHNle1xuICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTsgLy8gW3Jlc3BvbnNlLmRhdGFdXG4gICAgICB9XG4gICAgfSkuZmFpbCggZnVuY3Rpb24oKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICB9KTtcbiAgfSkucHJvbWlzZSgpO1xuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gd3BBamF4O1xuXG5cbi8qKlxuICogU2hpbSBmb3IgXCJmaXhpbmdcIiBJRSdzIGxhY2sgb2Ygc3VwcG9ydCAoSUUgPCA5KSBmb3IgYXBwbHlpbmcgc2xpY2VcbiAqIG9uIGhvc3Qgb2JqZWN0cyBsaWtlIE5hbWVkTm9kZU1hcCwgTm9kZUxpc3QsIGFuZCBIVE1MQ29sbGVjdGlvblxuICogKHRlY2huaWNhbGx5LCBzaW5jZSBob3N0IG9iamVjdHMgaGF2ZSBiZWVuIGltcGxlbWVudGF0aW9uLWRlcGVuZGVudCxcbiAqIGF0IGxlYXN0IGJlZm9yZSBFUzYsIElFIGhhc24ndCBuZWVkZWQgdG8gd29yayB0aGlzIHdheSkuXG4gKiBBbHNvIHdvcmtzIG9uIHN0cmluZ3MsIGZpeGVzIElFIDwgOSB0byBhbGxvdyBhbiBleHBsaWNpdCB1bmRlZmluZWRcbiAqIGZvciB0aGUgMm5kIGFyZ3VtZW50IChhcyBpbiBGaXJlZm94KSwgYW5kIHByZXZlbnRzIGVycm9ycyB3aGVuXG4gKiBjYWxsZWQgb24gb3RoZXIgRE9NIG9iamVjdHMuXG5cbihmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIF9zbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICB0cnkge1xuICAgIC8vIENhbid0IGJlIHVzZWQgd2l0aCBET00gZWxlbWVudHMgaW4gSUUgPCA5XG4gICAgX3NsaWNlLmNhbGwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgfSBjYXRjaCAoZSkgeyAvLyBGYWlscyBpbiBJRSA8IDlcbiAgICAvLyBUaGlzIHdpbGwgd29yayBmb3IgZ2VudWluZSBhcnJheXMsIGFycmF5LWxpa2Ugb2JqZWN0cywgXG4gICAgLy8gTmFtZWROb2RlTWFwIChhdHRyaWJ1dGVzLCBlbnRpdGllcywgbm90YXRpb25zKSxcbiAgICAvLyBOb2RlTGlzdCAoZS5nLiwgZ2V0RWxlbWVudHNCeVRhZ05hbWUpLCBIVE1MQ29sbGVjdGlvbiAoZS5nLiwgY2hpbGROb2RlcyksXG4gICAgLy8gYW5kIHdpbGwgbm90IGZhaWwgb24gb3RoZXIgRE9NIG9iamVjdHMgKGFzIGRvIERPTSBlbGVtZW50cyBpbiBJRSA8IDkpXG4gICAgQXJyYXkucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgLy8gSUUgPCA5IGdldHMgdW5oYXBweSB3aXRoIGFuIHVuZGVmaW5lZCBlbmQgYXJndW1lbnRcbiAgICAgIGVuZCA9ICh0eXBlb2YgZW5kICE9PSAndW5kZWZpbmVkJykgPyBlbmQgOiB0aGlzLmxlbmd0aDtcblxuICAgICAgLy8gRm9yIG5hdGl2ZSBBcnJheSBvYmplY3RzLCB3ZSB1c2UgdGhlIG5hdGl2ZSBzbGljZSBmdW5jdGlvblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzKSA9PT0gJ1tvYmplY3QgQXJyYXldJyl7XG4gICAgICAgIHJldHVybiBfc2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTsgXG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBhcnJheSBsaWtlIG9iamVjdCB3ZSBoYW5kbGUgaXQgb3Vyc2VsdmVzLlxuICAgICAgdmFyIGksIGNsb25lZCA9IFtdLFxuICAgICAgICBzaXplLCBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICAgICAgLy8gSGFuZGxlIG5lZ2F0aXZlIHZhbHVlIGZvciBcImJlZ2luXCJcbiAgICAgIHZhciBzdGFydCA9IGJlZ2luIHx8IDA7XG4gICAgICBzdGFydCA9IChzdGFydCA+PSAwKSA/IHN0YXJ0OiBsZW4gKyBzdGFydDtcblxuICAgICAgLy8gSGFuZGxlIG5lZ2F0aXZlIHZhbHVlIGZvciBcImVuZFwiXG4gICAgICB2YXIgdXBUbyA9IChlbmQpID8gZW5kIDogbGVuO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgdXBUbyA9IGxlbiArIGVuZDtcbiAgICAgIH1cblxuICAgICAgLy8gQWN0dWFsIGV4cGVjdGVkIHNpemUgb2YgdGhlIHNsaWNlXG4gICAgICBzaXplID0gdXBUbyAtIHN0YXJ0O1xuXG4gICAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgICAgY2xvbmVkID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgICBpZiAodGhpcy5jaGFyQXQpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjbG9uZWRbaV0gPSB0aGlzLmNoYXJBdChzdGFydCArIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjbG9uZWRbaV0gPSB0aGlzW3N0YXJ0ICsgaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfTtcbiAgfVxufSgpKTtcbiAqL1xuXG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=