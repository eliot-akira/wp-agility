(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

window.$$ = require('./agility/index.js');
window.wp = window.wp || {};
window.wp.action = require('./wp/action.js');

},{"./agility/index.js":2,"./wp/action.js":20}],2:[function(require,module,exports){
/**
 * 
 * Agility.js - v0.2.4
 * 
 * Forked and extended from: Agility.js 0.1.3 by Artur B. Adib - http://agilityjs.com
 * 
 * Separated into CommonJS modules
 * 
 * Merged pull requests
 * - Support nested model properties
 * - Efficient handling of style
 * 
 * Extended features
 * - Only render changed model properties
 * - Form helpers
 * - Numerous improvements to be documented
 * 
 */

/*jslint loopfunc: true */

(function(window, undefined){

  if (!window.jQuery) {
    throw "agility.js: jQuery not found";
  }
  
  // Local references
  var document = window.document,
      location = window.location,
      $        = jQuery,

      agility, // Main agility object builder

      util             = require('./util/util'),         // Internal utility functions
      $util            = require('./util/jquery.util'), // jQuery utility functions
      shim             = require('./util/object-shim'),  // Object.create and getPrototypeOf
      timed            = require('./util/timed'),        // Timed functions
      defaultPrototype = require('./prototype/index'),   // Default object prototype
      idCounter        = 0; // Global object counter


  /*---------------------------------------------
   *
   * Main object constructor
   *
   */
  
  agility = function() {
    
    // Real array of arguments
    var args = Array.prototype.slice.call(arguments, 0),
    
    // Object to be returned by builder
    object = {},

    $root, // Used when template is from DOM

    prototype = defaultPrototype;


    /*---------------------------------------------
     *
     * Create object from prototype
     *
     */

    // If first arg is object, use it as prototype
    if (typeof args[0] === "object" && util.isAgility(args[0])) {

      prototype = args[0];    
      args.shift(); // remaining args now work as though object wasn't specified

    }

    // Build object from prototype as well as the individual prototype parts
    // This enables differential inheritance at the sub-object level, e.g. object.view.format
    object = Object.create(prototype);
    object.model = Object.create(prototype.model);
    object.view = Object.create(prototype.view);
    object.controller = Object.create(prototype.controller);
    object._container = Object.create(prototype._container);
    object._events = Object.create(prototype._events);
    object.form = Object.create(prototype.form);


    // Instance properties, i.e. not inherited
    object._id = idCounter++;
    object._parent = null;
    object._events.data = {}; // event bindings will happen below
    object._container.children = {};
    
    if ( prototype.view.$root instanceof jQuery && prototype._template ) {
      // prototype $root exists: clone its content
      object.view.$root = $( prototype.view.$root.outerHTML()  );
    } else {
      object.view.$root = $(); // empty jQuery object
    }


    // Clone own properties
    // i.e. properties that are inherited by direct copy instead of by prototype chain
    // This prevents children from altering parents models
    object.model._data = prototype.model._data ? $.extend(true, {}, prototype.model._data) : {};
    object._data = prototype._data ? $.extend(true, {}, prototype._data) : {};


    /*---------------------------------------------
     *
     * Extend model, view, controller based on given arguments
     *
     */

    // Just the default prototype {}
    if (args.length === 0) {
    }

    // ( view.format [,{ method:function, ... }] )
    else if ( typeof args[0] === 'string' ) {

      // Get template from '#id'
      if ( args[0][0] === '#' ) {

        $root = $(args[0]);

        // Template from script tag
        if ( $root.prop('tagName').toLowerCase() === 'script' ) {

          object.view.format = $root.html();

        // Template from existing DOM
        } else {

          // Include container itself
          object.view.format = $root.outerHTML();
          // Assign root to existing DOM element
          object.view.$root = $root;
          
          object._template = true;
        }

      }
      // or '<template>' string
      else object.view.format = args[0];

      // Controller from object
      if ( args.length > 1 && typeof args[1] === 'object') {
        $.extend(object.controller, args[1]);
        util.extendController(object);
      }

    } // single view arg

    // Prototype differential from single {model,view,controller} object
    else if (args.length === 1 && typeof args[0] === 'object' && (args[0].model || args[0].view) ) {

      for (var prop in args[0]) {

        if (prop === 'model') {

          $.extend(object.model._data, args[0].model);

        } else if (prop === 'view') {

          if (typeof args[0].view === 'string') {

            // Get template from '#id'
            if ( args[0].view[0] === '#' ) {

              $root = $(args[0].view);

              object.view.format = $root.html();

              // Template from script tag
              if ( $root.prop('tagName').toLowerCase() === 'script' ) {

                object.view.format = $root.html();

              // Template from existing DOM
              } else {

                // Include container itself
                object.view.format = $root.outerHTML();
                // Assign root to existing DOM element
                object.view.$root = $root;
                object._template = true;
              }

            }
            // or '<template>' string
            else object.view.format = args[0].view;

          } else {

            $.extend(object.view, args[0].view); // view:{format:{},style:{}}
          }

        }
        else if ( prop === 'controller' || prop === 'events' ) {
          $.extend(object.controller, args[0][prop]);
          util.extendController(object);
        }

        // User-defined methods
        else {
          object[prop] = args[0][prop];
        }
      }
    } // single {model, view, controller} arg

    // Prototype differential from separate {model}, {view}, {controller} arguments
    else {
      
      // Model object
      if (typeof args[0] === 'object') {
        $.extend(object.model._data, args[0]);
      }
      else if (args[0]) {
        throw "agility.js: unknown argument type (model)";
      }

      // View format from shorthand string (..., '<div>whatever</div>', ...)
      if (typeof args[1] === 'string') {

        // @extend Get template from ID
        if ( args[1][0] === '#' ) {

          // object.view.format = $(args[1]).html();

          $root = $(args[1]);

          // Template from script tag
          if ( $root.prop('tagName').toLowerCase() === 'script' ) {

            object.view.format = $root.html();

          // Template from existing DOM
          } else {

            // Include container itself
            object.view.format = $root.outerHTML();
            // Assign root to existing DOM element
            object.view.$root = $root;
            object._template = true;
          }
        }
        else
          object.view.format = args[1]; // extend view with .format
      }  
      // View from object (..., {format:'<div>whatever</div>'}, ...)
      else if (typeof args[1] === 'object') {
        $.extend(object.view, args[1]);
      }
      else if (args[1]) {
        throw "agility.js: unknown argument type (view)";
      }
      
      // View style from shorthand string (..., ..., 'p {color:red}', ...)

      if (typeof args[2] === 'string') {
        object.view.style = args[2];
        args.splice(2, 1); // so that controller code below works
      }

      // Controller from object (..., ..., {method:function(){}})
      if (typeof args[2] === 'object') {
        $.extend(object.controller, args[2]);
        util.extendController(object);
      }
      else if (args[2]) {
        throw "agility.js: unknown argument type (controller)";
      }
      
    } // separate ({model}, {view}, {controller}) args


    /*---------------------------------------------
     *
     * Launch sequence: Bindings, initializations, etc
     *
     */
    
    // Save model's initial state (so it can be .reset() later)
    object.model._initData = $.extend({}, object.model._data);

    // object.* will have their 'this' === object. This should come before call to object.* below.
    util.proxyAll(object, object);

  
    // Initialize $root, needed for DOM events binding below
    object.view.render();
  

    // Bind all controllers to their events

    var bindEvent = function(ev, handler){
      if (typeof handler === 'function') {
        object.bind(ev, handler);
      }
    };

    for (var eventStr in object.controller) {
      var events = eventStr.split(';');
      var handler = object.controller[eventStr];
      $.each(events, function(i, ev){
        ev = $.trim(ev);
        bindEvent(ev, handler);
      });
    }

    // Auto-triggers create event
    object.trigger('create');    
    
    return object;
    
  }; // agility



  /*---------------------------------------------
   *
   * Global properties
   *
   */

  
  // $$.document is a special Agility object, whose view is attached to <body>
  // This object is the main entry point for all DOM operations
  agility.document = agility({
    _document : true,
    view: {
      $: function(selector){ return selector ? $(selector, 'body') : $('body'); }
    },
    controller: {
      // Override default controller (don't render, don't stylize, etc)
      _create: function(){}
    }
  });

  // Shortcut to prototype for plugins
  agility.fn = defaultPrototype;

  // Namespace to declare reusable Agility objects
  // Use: app.append( $$.module.something ) or $$( $$.module.something, {m,v,c} )
  agility.module = {};

  // isAgility test
  agility.isAgility = function(obj) {
    if (typeof obj !== 'object') return false;
    return util.isAgility(obj);
  };


  /*---------------------------------------------
   *
   * Export it
   *
   */

  // AMD, CommonJS, then global
  if (typeof define === 'function' && define.amd) {
    // @todo Is this correct?
    define([], function(){
        return agility;
    });
  } else if (typeof exports === 'object') {
      module.exports = agility;
  } else {
      window.$$ = agility;
  }

})(window);

},{"./prototype/index":14,"./util/jquery.util":16,"./util/object-shim":17,"./util/timed":18,"./util/util":19}],3:[function(require,module,exports){

/*---------------------------------------------
 *
 * Controller
 *
 * Default controllers, i.e. event handlers. Event handlers that start
 * with '_' are of internal use only, and take precedence over any other
 * handler without that prefix. See: trigger()
 *
 */

module.exports = {

  // Triggered after self creation
  _create: function(event){
    this.view.stylize();
    this.view.bindings(); // Model-View bindings
    this.view.sync(); // syncs View with Model
  },

  // Triggered upon removing self
  _destroy: function(event){

    // @pull #95 Remove generated style upon destruction of objects
    // @extend Only if using style attribute

    if (this.view.style) {
      var objId = 'agility_' + this._id;
      $('head #'+objId, window.document).remove();
    }

    // destroy any appended agility objects
    this._container.empty();

    // destroy self in DOM, removing all events
    this.view.$().remove();
  },

  // Triggered after child obj is appended to container
  _append: function(event, obj, selector){
    this.view.$(selector).append(obj.view.$());
  },

  // Triggered after child obj is prepended to container
  _prepend: function(event, obj, selector){
    this.view.$(selector).prepend(obj.view.$());
  },

  // Triggered after child obj is inserted in the container
  _before: function(event, obj, selector){
    if (!selector) throw 'agility.js: _before needs a selector';
    this.view.$(selector).before(obj.view.$());
  },

  // Triggered after child obj is inserted in the container
  _after: function(event, obj, selector){
    if (!selector) throw 'agility.js: _after needs a selector';
    this.view.$(selector).after(obj.view.$());
  },

  // Triggered after a child obj is removed from container (or self-removed)
  _remove: function(event, id){        
  },

  // Triggered after model is changed
  '_change': function(event){
  }
  
};

},{}],4:[function(require,module,exports){
/*---------------------------------------------
 *
 * Get
 *
 */

module.exports = function get( arg ) {

  // Get whole model
  if (arg === undefined) {
    return this.model._data;
  }

  // Get attribute
  // @pull #91 Add support for nested models: parent.child
  if (typeof arg === 'string') {
    var paths = arg.split('.');
    var value = this.model._data[paths[0]];
    //check for nested objects
    if ($.isPlainObject(value)){
      for (var i = 1; i < paths.length; i++){
        if ($.isPlainObject(value) && value[paths[i]]){
          value = value[paths[i]];
        } else {
          value = value[paths.splice(i).join('.')];
        }
      }
    } else {
      //direct key access
      value = this.model._data[arg];
    }
    return value;
  }

  throw 'agility.js: unknown argument for getter';
};

},{}],5:[function(require,module,exports){
/*---------------------------------------------
 *
 * Set: set model attributes and trigger change events
 * 
 * @todo Performance considerations
 *
 */

module.exports = function set( arg, params, third ) {

  var self = this;
  var attr;
  var modified = []; // list of modified model attributes
  var previous = {}; // list of previous values

  // Set individual model property: model.set( prop, value )
  if ( typeof arg === 'string' && params ) {

    attr = arg;
    arg = {};
    if ( typeof params === 'object' )
      arg[attr] = $.extend({}, params);
    else
      arg[attr] = params;

    params = third || {};
  }

  if ( typeof arg === 'object' ) {

    var _clone = {};

    if (params && params.reset) {
      _clone = this.model._data; // hold on to data for change events
      this.model._data = $.extend({}, arg); // erases previous model attributes without pointing to object
    }
    else {

      // @extend Compare and only trigger change event for modified keys
      _clone = $.extend({}, this.model._data);

      // @pull #91 Add support for nested models
      // Iterate through properties and find nested declarations

      for (var prop in arg){
        if (prop.indexOf('.') > -1){
          var path = prop.split('.');
          var current_node = this.model._data[path[0]];
          if (!current_node){
            current_node = this.model._data[path[0]] = {};
          }
          var next_node;
          for (var i = 1; i < path.length - 1; i++){
            next_node = current_node[path[i]];
            if ($.isPlainObject(next_node)){
             current_node = next_node;
            } else {
             current_node[path[i]] = {};
             current_node = current_node[path[i]];
            }
          }
          var last_property = path[path.length - 1];
         if ($.isPlainObject(arg[key]) && $.isPlainObject(current_node[last_property])){
           //if we're assigning objects, extend rather than replace
           $.extend(current_node[last_property], arg[prop]);
          } else {
           current_node[last_property] = arg[prop];
          }
          
          modified.push(prop);
          previous[prop] = _clone[prop];
          delete _clone[ prop ]; // no need to fire change twice
          delete arg[prop];
        }
      }

      $.extend(this.model._data, arg); // default is extend
    }

    // Given object

    for (var key in arg) {
      // Check if changed
      if (this.model._data[key] !== _clone[key] ) {
        modified.push(key);
        previous[key] = _clone[ key ];
      }
      delete _clone[ key ]; // no need to fire change twice
    }

    // Previous object

    for (key in _clone) {
      // Check if changed
      if (this.model._data[key] !== _clone[key] ) {
        modified.push(key);
        previous[key] = _clone[ key ];
      }
    }

  } else {

    // Not an object
    throw "agility.js: unknown argument type in model.set()";
  }

  // Tigger change events

  if (params && params.silent===true) return this; // do not fire events

  // @extend Pass array of modified model keys

  // $().trigger parses the second parameter as separate arguments,
  // so we put it in an array

  this.trigger('change', [modified, previous]);

  $.each(modified, function(index, key){
    self.trigger('change:'+key, previous[key]);
  });

  return this; // for chainable calls

};

},{}],6:[function(require,module,exports){

/*---------------------------------------------
 *
 * Validate model properties based on object.required
 *
 */

var $util = require('../util/jquery.util');

module.exports = {

  /*---------------------------------------------
   *
   * model.invalid()
   * 
   * @return An array of invalid keys
   *
   */

  invalid : function() {

    var invalid = [];

    // Check each required key

    for (var key in this.required) {
      if ( ! this.model.isValidKey( key ) )
        invalid.push(key);
    }

    return invalid;
  },

  /*---------------------------------------------
   *
   * isValid
   *
   * isValid() Validate whole model
   * isValid( key ) Validate key
   *
   * @return boolean
   *
   */
  

  isValid : function( key ) {

    if (typeof key === 'undefined') {

      // Check the whole model
      return ( this.model.invalid().length === 0);

    } else return this.model.isValidKey( key );

  },

  isValidKey : function( key ) {

    if ( typeof this.required[key] === 'undefined' ) {
      return true;
    }

    var val = this.model.get( key ),
        requireType = this.required[ key ];

    if ( requireType === true ) {

      return ! $.isEmpty( val );

    } else if ( requireType === 'email' ) {

      return $.isEmail( val );

    } else {

      // Other types of required: boolean, checked, custom condition..?

    }

    return true; // Passed all requirements
  }

};


},{"../util/jquery.util":16}],7:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * Model API
 *
 * get
 * set
 * reset
 * size
 * each
 * 
 * invalid
 * isValid
 * isValidKey
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null),
    util = require('../util/util'),
    modelValidate = require('./model-validate'),
    model = {

      get: require('./model-get'),
      set: require('./model-set'),

      // Resetter (to initial model upon object initialization)
      reset: function(){
        this.model.set(this.model._initData, {reset:true});
        return this; // for chainable calls
      },
      
      // Number of model properties
      size: function(){
        return util.size(this.model._data);
      },
      
      // Convenience function - loops over each model property
      each: function(fn){
        // Proxy this object
        $.each(this.model._data, $.proxy(fn,this) );
        return this; // for chainable calls
      }

    };

module.exports = $.extend( model, modelValidate );

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../util/util":19,"./model-get":4,"./model-set":5,"./model-validate":6}],8:[function(require,module,exports){

/*---------------------------------------------
 *
 * View bindings
 *
 *  Apply DOM <-> Model bindings, from elements with 'data-bind' attributes
 *
 */

module.exports = function bindings() {

  var self = this; // Reference to object
  var $rootNode = this.view.$().filter('[data-bind]');
  var $childNodes = this.view.$('[data-bind]');

  var createAttributePairClosure = function(bindData, node, i) {
    var attrPair = bindData.attr[i]; // capture the attribute pair in closure
    return function() {

      if ( attrPair.attr == 'html' ) {
        // Allow inserting HTML content
        node.html(self.model.get(attrPair.attrVar));
      } else {
        // Normal element attributes
        node.attr(attrPair.attr, self.model.get(attrPair.attrVar));
      }

    };
  };

  $rootNode.add( $childNodes ).each( function() {

    var $node = $(this);
    var bindData = _parseBindStr( $node.data('bind') );
    var required = $node.data('required'); // data-required

    var bindAttributesOneWay = function() {
      // 1-way attribute binding
      if (bindData.attr) {
        for (var i = 0; i < bindData.attr.length; i++) {
          self.bind('_change:'+bindData.attr[i].attrVar,
            createAttributePairClosure(bindData, $node, i));
        } // for (bindData.attr)
      } // if (bindData.attr)
    }; // bindAttributesOneWay()
    

    // <input type="checkbox">: 2-way binding

    if ($node.is('input:checkbox')) {
      // Model --> DOM
      self.bind('_change:'+bindData.key, function(){
        $node.prop("checked", self.model.get(bindData.key)); // this won't fire a DOM 'change' event, saving us from an infinite event loop (Model <--> DOM)
      });            
      // DOM --> Model
      $node.change(function(){
        var obj = {};
        obj[bindData.key] = $(this).prop("checked");
        self.model.set(obj); // not silent as user might be listening to change events
      });
      // 1-way attribute binding
      bindAttributesOneWay();
    }
    
    // <select>: 2-way binding

    else if ($node.is('select')) {
      // Model --> DOM
      self.bind('_change:'+bindData.key, function(){
        var nodeName = $node.attr('name');
        var modelValue = self.model.get(bindData.key);
        $node.val(modelValue);
      });            
      // DOM --> Model
      $node.change(function(){
        var obj = {};
        obj[bindData.key] = $node.val();
        self.model.set(obj); // not silent as user might be listening to change events
      });
      // 1-way attribute binding
      bindAttributesOneWay();
    }
    
    // <input type="radio">: 2-way binding

    else if ($node.is('input:radio')) {

      // Model --> DOM
      self.bind('_change:'+bindData.key, function(){
        var nodeName = $node.attr('name');
        var modelValue = self.model.get(bindData.key);

          // $node.siblings('input[name="'+nodeName+'"]').filter('[value="'+modelValue+'"]').prop("checked", true);

          // @pull #110 Binding for radio buttons
          // They're not always siblings, so start from $root
          self.view.$root.find('input[name="'+nodeName+'"]')
            .filter('[value="'+modelValue+'"]')
            .prop("checked", true);
            // this won't fire a DOM 'change' event, saving us from
            // an infinite event loop (Model <--> DOM)
      });            

      // DOM --> Model

      $node.change(function(){
        if (!$node.prop("checked")) return; // only handles check=true events
        var obj = {};
        obj[bindData.key] = $node.val();
        self.model.set(obj); // not silent as user might be listening to change events
      });
      // 1-way attribute binding
      bindAttributesOneWay();
    }
    
    // <input type="search"> (model is updated after every keypress event)

    else if ($node.is('input[type="search"]')) {

      // Model --> DOM
      self.bind('_change:'+bindData.key, function(){
        // this won't fire a DOM 'change' event, saving us from
        // an infinite event loop (Model <--> DOM)
        $node.val(self.model.get(bindData.key));
      });

      // Model <-- DOM
      $node.keypress(function(){
        // Without timeout $node.val() misses the last entered character
        setTimeout(function(){
          var obj = {};
          obj[bindData.key] = $node.val();
          self.model.set(obj); // not silent as user might be listening to change events
        }, 50);
      });
      // 1-way attribute binding
      bindAttributesOneWay();
    }

    // <input type="text">, <input>, and <textarea>: 2-way binding

    else if ($node.is('input:text, input[type!="search"], textarea')) {
      // Model --> DOM
      self.bind('_change:'+bindData.key, function(){
        // this won't fire a DOM 'change' event, saving us from
        // an infinite event loop (Model <--> DOM)
        $node.val(self.model.get(bindData.key));
      });            
      // Model <-- DOM
      $node.change(function(){
        var obj = {};
        obj[bindData.key] = $(this).val();
        self.model.set(obj); // not silent as user might be listening to change events
      });
      // 1-way attribute binding
      bindAttributesOneWay();
    }
    
    // all other <tag>s: 1-way binding, only Model -> DOM

    else {
      if (bindData.key) {
        self.bind('_change:'+bindData.key, function(){
          var key = self.model.get(bindData.key);
          if (key || key===0) {
            $node.text(self.model.get(bindData.key).toString());
          } else {
            $node.text('');
          }
        });
      }
      bindAttributesOneWay();
    }

    // Store binding map for later reference

    self.$node[ bindData.key ] = $node; // Model property -> element
    self.key[ $node ] = bindData.key; // Element -> Model property

    if ( typeof required !== 'undefined' ) {
      self.required[ bindData.key ] = required;
    }

  }); // nodes.each()

  return this;

}; // bindings()



/*---------------------------------------------
 *
 * Parse data-bind string
 * 
 * Syntax:'[attribute][=] variable[, [attribute][=] variable ]...'
 * 
 * All pairs in the list are assumed to be attributes
 * If the variable is not an attribute, it must occur by itself
 *
 * Returns { key:'model key', attr: [ {attr : 'attribute', attrVar : 'variable' }... ] }
 *
 */

function _parseBindStr( str ) {
  var obj = {key:null, attr:[]},
      pairs = str.split(','),
      // regex = /([a-zA-Z0-9_\-]+)(?:[\s=]+([a-zA-Z0-9_\-]+))?/,
      // @pull #91 Add support for nested models: key.prop
      regex = /([a-zA-Z0-9_\-\.]+)(?:[\s=]+([a-zA-Z0-9_\-]+))?/,
      keyAssigned = false,
      matched;
  
  if (pairs.length > 0) {
    for (var i = 0; i < pairs.length; i++) {
      matched = pairs[i].match(regex);
      // [ "attribute variable", "attribute", "variable" ]
      // or [ "attribute=variable", "attribute", "variable" ]
      // or
      // [ "variable", "variable", undefined ]
      // in some IE it will be [ "variable", "variable", "" ]
      // or
      // null
      if (matched) {
        if (typeof(matched[2]) === "undefined" || matched[2] === "") {
          if (keyAssigned) {
            throw new Error("You may specify only one key (" + 
              keyAssigned + " has already been specified in data-bind=" + 
              str + ")");
          } else {
            keyAssigned = matched[1];
            obj.key = matched[1];
          }
        } else {
          obj.attr.push({attr: matched[1], attrVar: matched[2]});
        }
      } // if (matched)
    } // for (pairs.length)
  } // if (pairs.length > 0)
  
  return obj;
}

},{}],9:[function(require,module,exports){

/*---------------------------------------------
 *
 * View API
 *
 * view.format
 * view.style
 * view.$
 * render
 * bindings
 * sync
 * stylize
 * $bound
 *
 */

var viewBind = require('./view-bind'), // View bindings
    ROOT_SELECTOR = '&'; // Also in prototype/events.js

module.exports = {
    
  // Defaults
  format: '<div/>',
  style: '',
  
  // Shortcut to view.$root or view.$root.find(), depending on selector presence
  $: function(selector) {
    return (!selector || selector === ROOT_SELECTOR) ? this.view.$root : this.view.$root.find(selector);
  },
  

  // Render $root
  // Only function to access $root directly other than $()
  render: function(){

    // Without format there is no view
    if (this.view.format.length === 0) {
      throw "agility.js: empty format in view.render()";
    }                

    if ( this.view.$root instanceof jQuery && this._template ) {

      // $root is from DOM already

    } else if ( this.view.$root.size() === 0 ) {

      this.view.$root = $(this.view.format);

    } else {

      // don't overwrite $root as this would reset its presence in the DOM
      // and all events already bound

      this.view.$root.html( $(this.view.format).html() );
    }

    // Ensure we have a valid (non-empty) $root
    if ( !(this.view.$root instanceof jQuery) && this.view.$root.size() === 0 ) {
      throw 'agility.js: could not generate html from format';
    }

    this.$view = this.view.$root;
    this.$ = this.view.$;
    return this;
  }, // render



  // Apply DOM <-> Model bindings

  bindings: viewBind,

  

  // Triggers _change and _change:* events so that view is updated as per view.bindings()
  sync: function(){
    var self = this;
    // Trigger change events so that view is updated according to model
    this.model.each(function(key, val){
      self.trigger('_change:'+key);
    });
    if (this.model.size() > 0) {
      this.trigger('_change');
    }
    return this;
  },


  // Applies style dynamically
  stylize: function(){
    var objClass,
        regex = new RegExp(ROOT_SELECTOR, 'g');
    if (this.view.style.length === 0 || this.view.$().size() === 0) {
      return;
    }
    // Own style
    // Object gets own class name ".agility_123", and <head> gets a corresponding <style>
    if (this.view.hasOwnProperty('style')) {
      objClass = 'agility_' + this._id;
      var styleStr = this.view.style.replace(regex, '.'+objClass);
      // $('head', window.document).append('<style type="text/css">'+styleStr+'</style>');

      // @pull #95 Add ID so later we can remove generated style
      // upon destruction of objects
      $('head', window.document).append('<style id="'+ objClass +'" type="text/css">'+
        styleStr+'</style>');
      this.view.$().addClass(objClass);
    }
    // Inherited style
    // Object inherits CSS class name from first ancestor to have own view.style
    else {
      // Returns id of first ancestor to have 'own' view.style
      var ancestorWithStyle = function(object) {
        while (object !== null) {
          object = Object.getPrototypeOf(object);
          if (object.view.hasOwnProperty('style'))
            return object._id;
        }
        return undefined;
      }; // ancestorWithStyle

      var ancestorId = ancestorWithStyle(this);
      objClass = 'agility_' + ancestorId;
      this.view.$().addClass(objClass);
    }
    return this;
  },


  /*---------------------------------------------
   *
   * Extended
   *
   */

  // Return element(s) bound to a model property
  // Refer to map in main object

  $bound: function( key ) {

    return typeof this.$node[ key ] !== undefined ? this.$node[ key ] : false;

    /* Old way: from DOM
    var self = this;

    return this.view.$('[data-bind]').filter(function(){
      var bindData = self.view._parseBindStr( $(this).data('bind') );
      // What about multiple or nested bindings?
      return ( bindData.key == key );
    }); */
  }

};

},{"./view-bind":8}],10:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * _container
 *
 * API and related auxiliary functions for storing child Agility objects.
 * Not all methods are exposed. See 'shortcuts' below for exposed methods.
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null),
    util = require('../util/util');

module.exports = {

  // Adds child object to container, appends/prepends/etc view, listens for child removal
  _insertObject: function(obj, selector, method){
    var self = this;

    if (!util.isAgility(obj)) {
      throw "agility.js: append argument is not an agility object";
    }

    this._container.children[obj._id] = obj; // children is *not* an array; this is for simpler lookups by global object id
    this.trigger(method, [obj, selector]);
    obj._parent = this;
    // ensures object is removed from container when destroyed:
    obj.bind('destroy', function(event, id){ 
      self._container.remove(id);
    });
    // Trigger event for child to listen to
    obj.trigger('parent:'+method);
    return this;
  },

  append: function(obj, selector) { 
      return this._container._insertObject.call(this, obj, selector, 'append'); 
  },

  prepend: function(obj, selector) { 
      return this._container._insertObject.call(this, obj, selector, 'prepend'); 
  },

  after: function(obj, selector) { 
      return this._container._insertObject.call(this, obj, selector, 'after'); 
  },

  before: function(obj, selector) { 
      return this._container._insertObject.call(this, obj, selector, 'before'); 
  },
  
  // Removes child object from container
  remove: function(id){
    delete this._container.children[id];
    this.trigger('remove', id);
    return this;
  },

  // Iterates over all child objects in container
  each: function(fn){
    $.each(this._container.children, fn);
    return this; // for chainable calls
  },

  // Removes all objects in container
  empty: function(){
    this.each(function(){
      this.destroy();
    });
    return this;
  },
  
  // Number of children
  size: function() {
    return util.size(this._container.children);
  }
  
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../util/util":19}],11:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * _events API and auxiliary functions for handling events
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null),
    ROOT_SELECTOR = '&'; // Also in mvc/view.js

module.exports = {

  // Binds eventStr to fn. eventStr is parsed as per parseEventStr()
  bind: function(eventStr, fn){

    var eventObj = parseEventStr(eventStr);

    // DOM event 'event selector', e.g. 'click button'
    if (eventObj.selector) {

      // Keep click and submit localized
      var fnx = function(event) {
        fn(event);
        return false; // Prevent default & bubbling
        // or just default? if ( ! event.isDefaultPrevented() ) event.preventDefault();
      };

      // Manually override root selector, as jQuery selectors can't select self object
      if (eventObj.selector === ROOT_SELECTOR) {

        if ( eventObj.type === 'click' || eventObj.type === 'submit' ) {
          this.view.$().on(eventObj.type, fnx);
        } else {
          this.view.$().on(eventObj.type, fn);
        }

        // @extend Replace $().bind with $().on
        // this.view.$().bind(eventObj.type, fn);
      }
      else {

        if ( eventObj.type === 'click' || eventObj.type === 'submit' ) {
          this.view.$().on(eventObj.type, eventObj.selector, fnx);
        } else {
          this.view.$().on(eventObj.type, eventObj.selector, fn);
        }

        // @extend Replace $().delegate with $().on
        // this.view.$().delegate(eventObj.selector, eventObj.type, fn);
      }
    }
    // Custom event
    else {

      // @extend Replace $().bind with $().on
      $(this._events.data).on(eventObj.type, fn);
      // $(this._events.data).bind(eventObj.type, fn);
    }
    return this; // for chainable calls
  }, // bind

  // Alias to bind()
  on: function( eventStr, fn ) {
    return this._events.bind( eventStr, fn );
  },

  // Triggers eventStr. Syntax for eventStr is same as that for bind()
  trigger: function(eventStr, params){

    var eventObj = parseEventStr(eventStr);

    // DOM event 'event selector', e.g. 'click button'
    if (eventObj.selector) {
      // Manually override root selector, as jQuery selectors can't select self object
      if (eventObj.selector === ROOT_SELECTOR) {
        this.view.$().trigger(eventObj.type, params);
      }
      else {          
        this.view.$().find(eventObj.selector).trigger(eventObj.type, params);
      }
    }
    // Custom event
    else {
      $(this._events.data).trigger('_'+eventObj.type, params);
      // fire 'pre' hooks in reverse attachment order ( last first ) then put them back
      reverseEvents(this._events.data, 'pre:' + eventObj.type);
      $(this._events.data).trigger('pre:' + eventObj.type, params);
      reverseEvents(this._events.data, 'pre:' + eventObj.type);

      $(this._events.data).trigger(eventObj.type, params);

      // Trigger event for parent
      if (this.parent())
        this.parent().trigger((eventObj.type.match(/^child:/) ? '' : 'child:') + eventObj.type, params);
      $(this._events.data).trigger('post:' + eventObj.type, params);
    }
    return this; // for chainable calls
  } // trigger
  
};


/*---------------------------------------------
 *
 * Parse event string
 *
 * 'event'          : custom event
 * 'event selector' : DOM event using 'selector'
 *
 * Returns { type:'event' [, selector:'selector'] }
 * 
 */

function parseEventStr( eventStr ) {

  var eventObj = { type:eventStr }, 
      spacePos = eventStr.search(/\s/);

  // DOM event 'event selector', e.g. 'click button'
  if (spacePos > -1) {
    eventObj.type = eventStr.substr(0, spacePos);
    eventObj.selector = eventStr.substr(spacePos+1);
  } else if ( eventStr === 'click' || eventStr === 'submit' ) {
    // @extend Shortcut for 'click &' and 'submit &'
    eventObj.type = eventStr;
    eventObj.selector = ROOT_SELECTOR;
  }
  return eventObj;
}

// Reverses the order of events attached to an object

function reverseEvents(obj, eventType){

  var events = $(obj).data('events');

  if (events !== undefined && events[eventType] !== undefined){
    // can't reverse what's not there
    var reversedEvents = [];
    for (var e in events[eventType]){
      if (!events[eventType].hasOwnProperty(e)) continue;
      reversedEvents.unshift(events[eventType][e]);
    }
    events[eventType] = reversedEvents;
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],12:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * Extended shortcuts
 * 
 * replace, child, children, load
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null);

module.exports = {

  get : function( arg ) {
    return this.model.get( arg );
  },

  set : function( arg, params, third ) {
    return this.model.set( arg, params, third  );
  },

  invalid : function() {
    return this.model.invalid();
  },

  replace: function( obj, selector ){
    if ( typeof selector === 'string' ) {
      this.view.$(selector).html('');
    }
    this.empty()._container.append.apply(this, arguments);
    return this; // for chainable calls
  },

  // Return nth child object
  child: function(n){
    var i = 0;
    n = n || 0;

    for (var j in this._container.children) {
      if ( this._container.children.hasOwnProperty(j) ) {
        if ( i == n )
          return this._container.children[j];
        else if ( i > n )
          return false;

        i++; // Continue searching
      }
    }
    return false;
  },

  // Return all child objects
  children: function(){
    return this._container.children; // { id: child, .. }
  },

  // Replace children models - append if there's more, destroy if less
  load: function( proto, models, selector ) {

    var self = this,
        maxModels = models.length,
        maxChildren = this.size();

    $.each(models, function(index, model) {
      if ( self.child(index) ) {
        self.child(index).model.set( model );
      } else {
        self.append( $$( proto, model ), selector );
      }
    });

    if (maxChildren > maxModels) {
      for (var i = maxModels; i < maxChildren; i++) {
        // Child's index stays the same, since each one is destroyed
        self.child(maxModels).destroy();
      }
    }

    return this;
  }

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],13:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * Form helpers
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null);

module.exports = {

  form : {

    // Clear the form
    clear : function() {

      return this.$view.find(':input')
        .not(':button, :submit, :reset, :hidden').removeAttr('checked').removeAttr('selected')
        .not(':checkbox, :radio, select').val('');
    },

    // Validate model, instead of form in the DOM directly
    // @return An array of invalid model properties
    invalid : function() {

      return this.model.invalid();
    }
  }

};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * Construct default object prototype
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null),

    defaultPrototype = {

      _agility: true,
      _container: require('./container'),
      _events: require('./events'),

      $node: {}, // Map of model properties -> bound elements
      key: {}, // Map of elements -> bound model properties
      required: {}, // Map of required model properties and require types

      model: require('../mvc/model'),
      view: require('../mvc/view'),
      controller: require('../mvc/controller')

    },

    shortcuts = require('./shortcuts'),
    extend = require('./extend'),
    form = require('./form');

module.exports = $.extend(true, defaultPrototype, shortcuts, extend, form);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../mvc/controller":3,"../mvc/model":7,"../mvc/view":9,"./container":10,"./events":11,"./extend":12,"./form":13,"./shortcuts":15}],15:[function(require,module,exports){

/*---------------------------------------------
 *
 * Object shortcuts
 *
 */

module.exports = {

  destroy: function() {
    this.trigger('destroy', this._id); // parent must listen to 'remove' event and handle container removal!
    // can't return this as it might not exist anymore!
  },
  parent: function(){
    return this._parent;
  },
  
  //
  // _container shortcuts
  //
  append: function(){
    this._container.append.apply(this, arguments);
    return this; // for chainable calls
  },
  prepend: function(){
    this._container.prepend.apply(this, arguments);
    return this; // for chainable calls
  },
  after: function(){
    this._container.after.apply(this, arguments);
    return this; // for chainable calls
  },
  before: function(){
    this._container.before.apply(this, arguments);
    return this; // for chainable calls
  },
  remove: function(){
    this._container.remove.apply(this, arguments);
    return this; // for chainable calls
  },
  size: function(){
    return this._container.size.apply(this, arguments);
  },
  each: function(){
    return this._container.each.apply(this, arguments);
  },
  empty: function(){
    return this._container.empty.apply(this, arguments);
  },

  //
  // _events shortcuts
  //
  bind: function(){
    this._events.bind.apply(this, arguments);
    return this; // for chainable calls
  },
  on: function(){ // Alias
    this._events.bind.apply(this, arguments);
    return this; // for chainable calls
  },
  trigger: function(){
    this._events.trigger.apply(this, arguments);
    return this; // for chainable calls
  },

};

},{}],16:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * jQuery utility functions
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null);

// Get element including wrapping tag

$.fn.outerHTML = function(s) {
  if (s) {
    return this.before(s).remove();
  } else {
    var doc = this[0] ? this[0].ownerDocument : document;
    return jQuery('<div>', doc).append(this.eq(0).clone()).html();
  }
};



// Generic isEmpty

$.isEmpty = function( mixed_var ) {

  // Empty: null, undefined, '', [], {}
  // Not empty: 0, true, false
  // What about jQuery object?

  var undef, key, i, len;
  var emptyValues = [undef, null, ''];

  for (i = 0, len = emptyValues.length; i < len; i++) {
    if (mixed_var === emptyValues[i]) {
      return true;
    }
  }

  if (typeof mixed_var === 'object') {
    for (key in mixed_var) {
      // Inherited properties count?
      // if (mixed_var.hasOwnProperty(key)) {
        return false;
      // }
    }
    return true;
  }

  return false;
};

/* Another version

window.jQuery.isEmpty = function( data ) {

  if(typeof(data) == 'number' || typeof(data) == 'boolean') {
    return false;
  }
  if(typeof(data) == 'undefined' || data === null) {
    return true;
  }
  if(typeof(data.length) != 'undefined') {
    return data.length === 0;
  }

  var count = 0;
  for(var i in data) {
    if(data.hasOwnProperty(i)) {
      count ++;
    }
  }
  return count === 0;
};
*/


// Validate e-mail

$.isEmail = function( email ) {

  if ( $.isEmpty( email ) ) return false;

  var regex = /^([a-zA-Z0-9_.+-])+\@(([a-zA-Z0-9-])+\.)+([a-zA-Z0-9]{2,4})+$/;
  return regex.test(email);
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],17:[function(require,module,exports){

/*---------------------------------------------
 *
 * Shim for: Object.create and Object.getPrototypeOf
 *
 */


/*jslint proto: true */

// Modified from Douglas Crockford's Object.create()
// The condition below ensures we override other manual implementations
if (!Object.create || Object.create.toString().search(/native code/i)<0) {
  Object.create = function(obj){
    var Aux = function(){};
    $.extend(Aux.prototype, obj); // simply setting Aux.prototype = obj somehow messes with constructor, so getPrototypeOf wouldn't work in IE
    return new Aux();
  };
}

// Modified from John Resig's Object.getPrototypeOf()
// The condition below ensures we override other manual implementations
if (!Object.getPrototypeOf || Object.getPrototypeOf.toString().search(/native code/i)<0) {
  if ( typeof "test".__proto__ === "object" ) {
    Object.getPrototypeOf = function(object){
      return object.__proto__;
    };
  } else {
    Object.getPrototypeOf = function(object){
      // May break if the constructor has been tampered with
      return object.constructor.prototype;
    };
  }
}

},{}],18:[function(require,module,exports){
(function (global){
/*---------------------------------------------
 *
 * Timed functions
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null);

var timers = {},
    defaultInterval = 10000;

$.fn.timedClass = function( className, duration ) {

  var $self = $(this);

  return $(this).timedFn(
    function(){ $self.addClass( className ); },
    function(){ $self.removeClass( className ); },
    duration || defaultInterval
  );
};

$.fn.timedText = function( txt, duration ) {

  var $self = $(this);

  return $(this).timedFn(
    function(){ $self.text( txt ); },
    function(){ $self.text(''); },
    duration || defaultInterval
  );
};

$.fn.timedFn = function( id, start, end, duration ) {

  duration = duration || defaultInterval;

  // ID skipped
  if ( typeof id === 'function' ) {

    duration = end || duration;
    end = start;
    start = id;

    new Timer(function(){
      end();
    }, duration );

    return start();

  // If timer ID is set and one is already going, add to the duration
  } else if ( typeof timers[id] !== 'undefined' && ! timers[id].finished ) {

    timers[id].add( duration );

  } else {

    timers[id] = new Timer(function(){
      end();
    }, duration );

    return start();
  }
};


function Timer(callback, time) {
    this.setTimeout(callback, time);
}

Timer.prototype.setTimeout = function(callback, time) {

    var self = this;

    this.finished = false;
    this.callback = callback;
    this.time = time;

    if(this.timer) {
        clearTimeout(this.timer);
    }
    this.timer = setTimeout(function() {
      self.finished = true;
      self.callback();
    }, time);
    this.start = Date.now();
};

Timer.prototype.add = function(time) {
   if(!this.finished) {
       // add time to time left
       time = this.time - (Date.now() - this.start) + time;
       this.setTimeout(this.callback, time);
   }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * util.*
 *
 * isAgility
 * proxyAll
 * reverseEvents
 * size
 * extendController
 * 
 */

/*jslint loopfunc: true */

var util = {},
    $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null);

// Checks if provided obj is an agility object
util.isAgility = function(obj){
 return obj._agility === true;
};

// Scans object for functions (depth=2) and proxies their 'this' to dest.
// * To ensure it works with previously proxied objects, we save the original function as 
//   a '._preProxy' method and when available always use that as the proxy source.
// * To skip a given method, create a sub-method called '_noProxy'.
util.proxyAll = function(obj, dest){
  if (!obj || !dest) {
    throw "agility.js: util.proxyAll needs two arguments";
  }
  for (var attr1 in obj) {
    var proxied = obj[attr1];
    // Proxy root methods
    if (typeof obj[attr1] === 'function' ) {

      proxied = obj[attr1]._noProxy ? obj[attr1] : $.proxy(obj[attr1]._preProxy || obj[attr1], dest);
      proxied._preProxy = obj[attr1]._noProxy ? undefined : (obj[attr1]._preProxy || obj[attr1]); // save original
      obj[attr1] = proxied;

    }
    // Proxy sub-methods (model.*, view.*, etc) -- except for jQuery object
    else if (typeof obj[attr1] === 'object' && !(obj[attr1] instanceof jQuery) ) {
      for (var attr2 in obj[attr1]) {
        var proxied2 = obj[attr1][attr2];
        if (typeof obj[attr1][attr2] === 'function') {
          proxied2 = obj[attr1][attr2]._noProxy ? obj[attr1][attr2] : $.proxy(obj[attr1][attr2]._preProxy || obj[attr1][attr2], dest);
          proxied2._preProxy = obj[attr1][attr2]._noProxy ? undefined : (obj[attr1][attr2]._preProxy || obj[attr1][attr2]); // save original
          proxied[attr2] = proxied2;
        }
      } // for attr2
      obj[attr1] = proxied;
    } // if not func
  } // for attr1
}; // proxyAll


// Determines # of attributes of given object (prototype inclusive)
util.size = function(obj){
  var size = 0, key;
  for (key in obj) {
    size++;
  }
  return size;
};

// Find controllers to be extended (with syntax '~'), redefine those to encompass previously defined controllers
// Example:
//   var a = $$({}, '<button>A</button>', {'click &': function(){ alert('A'); }});
//   var b = $$(a, {}, '<button>B</button>', {'~click &': function(){ alert('B'); }});
// Clicking on button B will alert both 'A' and 'B'.
util.extendController = function(object) {
  for (var controllerName in object.controller) {

    // new scope as we need one new function handler per controller
    (function(){
      var matches, extend, eventName,
          previousHandler, currentHandler, newHandler;

      if (typeof object.controller[controllerName] === 'function') {
        matches = controllerName.match(/^(\~)*(.+)/); // 'click button', '~click button', '_create', etc
        extend = matches[1];
        eventName = matches[2];
      
        if (!extend) return; // nothing to do

        // Redefine controller:
        // '~click button' ---> 'click button' = previousHandler + currentHandler
        previousHandler = object.controller[eventName] ? (object.controller[eventName]._preProxy || object.controller[eventName]) : undefined;
        currentHandler = object.controller[controllerName];
        newHandler = function() {
          if (previousHandler) previousHandler.apply(this, arguments);
          if (currentHandler) currentHandler.apply(this, arguments);
        };

        object.controller[eventName] = newHandler;
        delete object.controller[controllerName]; // delete '~click button'
      } // if function
    })();
  } // for controllerName
};

module.exports = util;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
(function (global){

/*---------------------------------------------
 *
 * wp.action
 * 
 * - get, save
 * - login, logout, go, reload
 *
 */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null);
var wpAjax = require('./ajax.js');

module.exports = $.extend( window.wp.action || {}, {

  /**
   *
   * get( [type,] { query } )
   * 
   * @param {string} type   Content type: posts, users
   * @param {object} query  Query arguments
   * 
   * @todo taxonomy, comments
   *
   */

  get : function() {

    // Default: get_posts
    var type = 'posts';

    // For other content types: get_user, get_taxonomy, ...
    var otherTypes = [ 'post', 'user', 'users', 'taxonomy', 'field', 'fields' ];

    // Create array of arguments
    var args = Array.prototype.slice.call(arguments, 0);

    if ( args.length === 0 )
      throw "wp.action.get needs an object";

    if ( typeof args[0] === 'string' ) {
      type = args[0];
      args.shift();
    }

    request = args[0] || {};
    success = args[1] || {};
    error = args[2] || {};

    if ( typeof request.type !== 'undefined' && $.inArray(request.type, otherTypes) > -1 ) {
      type = request.type;
      delete request.type;
    }

    return wpAjax( 'get_'+type, request, success, error );
  },


  /**
   *
   * save( [type,] { data } )
   * 
   * @param {string} type   Content type: post, user
   * @param {object} data   Data
   * 
   * @todo taxonomy, comments..
   *
   */

  save: function() {

    // For post, page, custom post type: save_post
    var type = 'post';

    // For other content types: save_user, save_taxonomy, ...
    var nonPostTypes = [ 'user', 'users', 'taxonomy', 'field', 'fields' ];

    // Create array of arguments
    var args = Array.prototype.slice.call(arguments, 0);

    if ( args.length === 0 )
      throw "wp.action.save needs an object";

    if ( typeof args[0] === 'string' ) {
      type = args[0];
      args.shift();
    }

    request = args[0] || {};
    success = args[1] || {};
    error = args[2] || {};

    if ( typeof request.type !== 'undefined' && $.inArray(request.type, nonPostTypes) > -1 ) {
      type = request.type;
      delete request.type;
    } else if ( type == 'post' && $.isArray( request ) ) {
      type = 'posts';
    }

    return wpAjax( 'save_'+type, request, success, error );
  },


  /**
   *
   * login, logout, go, reload
   *
   * @todo register
   *
   */


  login : function( request, success, error ) {

    return wpAjax( 'login', request, success, error );
  },

  logout : function( redirect ) {

    var logout = wp.url.logout;

    if ( typeof redirect === 'undefined' ) redirect = wp.current.request;

    logout += '&redirect_to='+wp.url.site+redirect;
    location.href = logout;
  },

  go : function( route ) {
    location.href = wp.url.site+route;
  },

  reload : function() {
    location.href = wp.current.url;
  },

  /**
   *
   * email
   * 
   */

  mail : function( mailObj ) {

    // Default: get_posts
    var type = 'mail';

    // Create array of arguments
    var args = Array.prototype.slice.call(arguments, 0);

    if ( args.length === 0 )
      throw "wp.action.mail needs an object";

    request = args[0] || {};
    success = args[1] || {};
    error = args[2] || {};

    return wpAjax( 'send_email', request, success, error );
  }


});


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./ajax.js":21}],21:[function(require,module,exports){
(function (global){
/* global wp.current.nonce, wp.url.ajax */

var $ = (typeof window !== "undefined" ? window.jQuery : typeof global !== "undefined" ? global.jQuery : null);

function wpAjax( action, request, success, error ) {

  var req = {
    type: 'POST',
    url: wp.url.ajax, // AJAX URL from server-side
    data: {
      action: 'agility_'+action, // Prefix
      nonce: wp.current.nonce, // Nonce from server-side
      data: request // The real data
    },
    beforeSend: '',
    success: '',
    error: ''
  };

  // Based on wp-util.js
  return $.Deferred( function( deferred ) {

    // Transfer success/error callbacks.
    if ( success )
      deferred.done( success );
    if ( error )
      deferred.fail( error );

    // Option to force return fail before Ajax request
    if ( action === 'fail' )
      deferred.rejectWith( this, arguments );

    // Use with PHP's wp_send_json_success() and wp_send_json_error()
    $.ajax( req ).done( function( response ) {

      // Treat a response of `1` as successful for backwards compatibility
      if ( response === '1' || response === 1 )
        response = { success: true };

      if ( typeof response.data === 'undefined' )
        response.data = 'empty';

      if ( typeof response === 'object' && ( typeof response.success !== 'undefined' ) )
        deferred[ response.success ? 'resolveWith' : 'rejectWith' ]( this, [response.data] );
      else{
        deferred.rejectWith( this, arguments ); // [response.data]
      }
    }).fail( function() {
      deferred.rejectWith( this, arguments );
    });
  }).promise();

}

module.exports = wpAjax;


/**
 * Shim for "fixing" IE's lack of support (IE < 9) for applying slice
 * on host objects like NamedNodeMap, NodeList, and HTMLCollection
 * (technically, since host objects have been implementation-dependent,
 * at least before ES6, IE hasn't needed to work this way).
 * Also works on strings, fixes IE < 9 to allow an explicit undefined
 * for the 2nd argument (as in Firefox), and prevents errors when
 * called on other DOM objects.

(function () {
  'use strict';
  var _slice = Array.prototype.slice;

  try {
    // Can't be used with DOM elements in IE < 9
    _slice.call(document.documentElement);
  } catch (e) { // Fails in IE < 9
    // This will work for genuine arrays, array-like objects, 
    // NamedNodeMap (attributes, entities, notations),
    // NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes),
    // and will not fail on other DOM objects (as do DOM elements in IE < 9)
    Array.prototype.slice = function(begin, end) {
      // IE < 9 gets unhappy with an undefined end argument
      end = (typeof end !== 'undefined') ? end : this.length;

      // For native Array objects, we use the native slice function
      if (Object.prototype.toString.call(this) === '[object Array]'){
        return _slice.call(this, begin, end); 
      }

      // For array like object we handle it ourselves.
      var i, cloned = [],
        size, len = this.length;

      // Handle negative value for "begin"
      var start = begin || 0;
      start = (start >= 0) ? start: len + start;

      // Handle negative value for "end"
      var upTo = (end) ? end : len;
      if (end < 0) {
        upTo = len + end;
      }

      // Actual expected size of the slice
      size = upTo - start;

      if (size > 0) {
        cloned = new Array(size);
        if (this.charAt) {
          for (i = 0; i < size; i++) {
            cloned[i] = this.charAt(start + i);
          }
        } else {
          for (i = 0; i < size; i++) {
            cloned[i] = this[start + i];
          }
        }
      }

      return cloned;
    };
  }
}());
 */


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYi9zeXMvY29uZi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwianMvc3JjL2luZGV4LmpzIiwianMvc3JjL2FnaWxpdHkvaW5kZXguanMiLCJqcy9zcmMvYWdpbGl0eS9tdmMvY29udHJvbGxlci5qcyIsImpzL3NyYy9hZ2lsaXR5L212Yy9tb2RlbC1nZXQuanMiLCJqcy9zcmMvYWdpbGl0eS9tdmMvbW9kZWwtc2V0LmpzIiwianMvc3JjL2FnaWxpdHkvbXZjL21vZGVsLXZhbGlkYXRlLmpzIiwianMvc3JjL2FnaWxpdHkvbXZjL21vZGVsLmpzIiwianMvc3JjL2FnaWxpdHkvbXZjL3ZpZXctYmluZC5qcyIsImpzL3NyYy9hZ2lsaXR5L212Yy92aWV3LmpzIiwianMvc3JjL2FnaWxpdHkvcHJvdG90eXBlL2NvbnRhaW5lci5qcyIsImpzL3NyYy9hZ2lsaXR5L3Byb3RvdHlwZS9ldmVudHMuanMiLCJqcy9zcmMvYWdpbGl0eS9wcm90b3R5cGUvZXh0ZW5kLmpzIiwianMvc3JjL2FnaWxpdHkvcHJvdG90eXBlL2Zvcm0uanMiLCJqcy9zcmMvYWdpbGl0eS9wcm90b3R5cGUvaW5kZXguanMiLCJqcy9zcmMvYWdpbGl0eS9wcm90b3R5cGUvc2hvcnRjdXRzLmpzIiwianMvc3JjL2FnaWxpdHkvdXRpbC9qcXVlcnkudXRpbC5qcyIsImpzL3NyYy9hZ2lsaXR5L3V0aWwvb2JqZWN0LXNoaW0uanMiLCJqcy9zcmMvYWdpbGl0eS91dGlsL3RpbWVkLmpzIiwianMvc3JjL2FnaWxpdHkvdXRpbC91dGlsLmpzIiwianMvc3JjL3dwL2FjdGlvbi5qcyIsImpzL3NyYy93cC9hamF4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJ3cC1hZ2lsaXR5Lm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXG53aW5kb3cuJCQgPSByZXF1aXJlKCcuL2FnaWxpdHkvaW5kZXguanMnKTtcbndpbmRvdy53cCA9IHdpbmRvdy53cCB8fCB7fTtcbndpbmRvdy53cC5hY3Rpb24gPSByZXF1aXJlKCcuL3dwL2FjdGlvbi5qcycpO1xuIiwiLyoqXG4gKiBcbiAqIEFnaWxpdHkuanMgLSB2MC4yLjRcbiAqIFxuICogRm9ya2VkIGFuZCBleHRlbmRlZCBmcm9tOiBBZ2lsaXR5LmpzIDAuMS4zIGJ5IEFydHVyIEIuIEFkaWIgLSBodHRwOi8vYWdpbGl0eWpzLmNvbVxuICogXG4gKiBTZXBhcmF0ZWQgaW50byBDb21tb25KUyBtb2R1bGVzXG4gKiBcbiAqIE1lcmdlZCBwdWxsIHJlcXVlc3RzXG4gKiAtIFN1cHBvcnQgbmVzdGVkIG1vZGVsIHByb3BlcnRpZXNcbiAqIC0gRWZmaWNpZW50IGhhbmRsaW5nIG9mIHN0eWxlXG4gKiBcbiAqIEV4dGVuZGVkIGZlYXR1cmVzXG4gKiAtIE9ubHkgcmVuZGVyIGNoYW5nZWQgbW9kZWwgcHJvcGVydGllc1xuICogLSBGb3JtIGhlbHBlcnNcbiAqIC0gTnVtZXJvdXMgaW1wcm92ZW1lbnRzIHRvIGJlIGRvY3VtZW50ZWRcbiAqIFxuICovXG5cbi8qanNsaW50IGxvb3BmdW5jOiB0cnVlICovXG5cbihmdW5jdGlvbih3aW5kb3csIHVuZGVmaW5lZCl7XG5cbiAgaWYgKCF3aW5kb3cualF1ZXJ5KSB7XG4gICAgdGhyb3cgXCJhZ2lsaXR5LmpzOiBqUXVlcnkgbm90IGZvdW5kXCI7XG4gIH1cbiAgXG4gIC8vIExvY2FsIHJlZmVyZW5jZXNcbiAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxuICAgICAgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24sXG4gICAgICAkICAgICAgICA9IGpRdWVyeSxcblxuICAgICAgYWdpbGl0eSwgLy8gTWFpbiBhZ2lsaXR5IG9iamVjdCBidWlsZGVyXG5cbiAgICAgIHV0aWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL3V0aWwvdXRpbCcpLCAgICAgICAgIC8vIEludGVybmFsIHV0aWxpdHkgZnVuY3Rpb25zXG4gICAgICAkdXRpbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi91dGlsL2pxdWVyeS51dGlsJyksIC8vIGpRdWVyeSB1dGlsaXR5IGZ1bmN0aW9uc1xuICAgICAgc2hpbSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbC9vYmplY3Qtc2hpbScpLCAgLy8gT2JqZWN0LmNyZWF0ZSBhbmQgZ2V0UHJvdG90eXBlT2ZcbiAgICAgIHRpbWVkICAgICAgICAgICAgPSByZXF1aXJlKCcuL3V0aWwvdGltZWQnKSwgICAgICAgIC8vIFRpbWVkIGZ1bmN0aW9uc1xuICAgICAgZGVmYXVsdFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vcHJvdG90eXBlL2luZGV4JyksICAgLy8gRGVmYXVsdCBvYmplY3QgcHJvdG90eXBlXG4gICAgICBpZENvdW50ZXIgICAgICAgID0gMDsgLy8gR2xvYmFsIG9iamVjdCBjb3VudGVyXG5cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBNYWluIG9iamVjdCBjb25zdHJ1Y3RvclxuICAgKlxuICAgKi9cbiAgXG4gIGFnaWxpdHkgPSBmdW5jdGlvbigpIHtcbiAgICBcbiAgICAvLyBSZWFsIGFycmF5IG9mIGFyZ3VtZW50c1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICBcbiAgICAvLyBPYmplY3QgdG8gYmUgcmV0dXJuZWQgYnkgYnVpbGRlclxuICAgIG9iamVjdCA9IHt9LFxuXG4gICAgJHJvb3QsIC8vIFVzZWQgd2hlbiB0ZW1wbGF0ZSBpcyBmcm9tIERPTVxuXG4gICAgcHJvdG90eXBlID0gZGVmYXVsdFByb3RvdHlwZTtcblxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKlxuICAgICAqIENyZWF0ZSBvYmplY3QgZnJvbSBwcm90b3R5cGVcbiAgICAgKlxuICAgICAqL1xuXG4gICAgLy8gSWYgZmlyc3QgYXJnIGlzIG9iamVjdCwgdXNlIGl0IGFzIHByb3RvdHlwZVxuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gXCJvYmplY3RcIiAmJiB1dGlsLmlzQWdpbGl0eShhcmdzWzBdKSkge1xuXG4gICAgICBwcm90b3R5cGUgPSBhcmdzWzBdOyAgICBcbiAgICAgIGFyZ3Muc2hpZnQoKTsgLy8gcmVtYWluaW5nIGFyZ3Mgbm93IHdvcmsgYXMgdGhvdWdoIG9iamVjdCB3YXNuJ3Qgc3BlY2lmaWVkXG5cbiAgICB9XG5cbiAgICAvLyBCdWlsZCBvYmplY3QgZnJvbSBwcm90b3R5cGUgYXMgd2VsbCBhcyB0aGUgaW5kaXZpZHVhbCBwcm90b3R5cGUgcGFydHNcbiAgICAvLyBUaGlzIGVuYWJsZXMgZGlmZmVyZW50aWFsIGluaGVyaXRhbmNlIGF0IHRoZSBzdWItb2JqZWN0IGxldmVsLCBlLmcuIG9iamVjdC52aWV3LmZvcm1hdFxuICAgIG9iamVjdCA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlKTtcbiAgICBvYmplY3QubW9kZWwgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZS5tb2RlbCk7XG4gICAgb2JqZWN0LnZpZXcgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZS52aWV3KTtcbiAgICBvYmplY3QuY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlLmNvbnRyb2xsZXIpO1xuICAgIG9iamVjdC5fY29udGFpbmVyID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUuX2NvbnRhaW5lcik7XG4gICAgb2JqZWN0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZS5fZXZlbnRzKTtcbiAgICBvYmplY3QuZm9ybSA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlLmZvcm0pO1xuXG5cbiAgICAvLyBJbnN0YW5jZSBwcm9wZXJ0aWVzLCBpLmUuIG5vdCBpbmhlcml0ZWRcbiAgICBvYmplY3QuX2lkID0gaWRDb3VudGVyKys7XG4gICAgb2JqZWN0Ll9wYXJlbnQgPSBudWxsO1xuICAgIG9iamVjdC5fZXZlbnRzLmRhdGEgPSB7fTsgLy8gZXZlbnQgYmluZGluZ3Mgd2lsbCBoYXBwZW4gYmVsb3dcbiAgICBvYmplY3QuX2NvbnRhaW5lci5jaGlsZHJlbiA9IHt9O1xuICAgIFxuICAgIGlmICggcHJvdG90eXBlLnZpZXcuJHJvb3QgaW5zdGFuY2VvZiBqUXVlcnkgJiYgcHJvdG90eXBlLl90ZW1wbGF0ZSApIHtcbiAgICAgIC8vIHByb3RvdHlwZSAkcm9vdCBleGlzdHM6IGNsb25lIGl0cyBjb250ZW50XG4gICAgICBvYmplY3Qudmlldy4kcm9vdCA9ICQoIHByb3RvdHlwZS52aWV3LiRyb290Lm91dGVySFRNTCgpICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3Qudmlldy4kcm9vdCA9ICQoKTsgLy8gZW1wdHkgalF1ZXJ5IG9iamVjdFxuICAgIH1cblxuXG4gICAgLy8gQ2xvbmUgb3duIHByb3BlcnRpZXNcbiAgICAvLyBpLmUuIHByb3BlcnRpZXMgdGhhdCBhcmUgaW5oZXJpdGVkIGJ5IGRpcmVjdCBjb3B5IGluc3RlYWQgb2YgYnkgcHJvdG90eXBlIGNoYWluXG4gICAgLy8gVGhpcyBwcmV2ZW50cyBjaGlsZHJlbiBmcm9tIGFsdGVyaW5nIHBhcmVudHMgbW9kZWxzXG4gICAgb2JqZWN0Lm1vZGVsLl9kYXRhID0gcHJvdG90eXBlLm1vZGVsLl9kYXRhID8gJC5leHRlbmQodHJ1ZSwge30sIHByb3RvdHlwZS5tb2RlbC5fZGF0YSkgOiB7fTtcbiAgICBvYmplY3QuX2RhdGEgPSBwcm90b3R5cGUuX2RhdGEgPyAkLmV4dGVuZCh0cnVlLCB7fSwgcHJvdG90eXBlLl9kYXRhKSA6IHt9O1xuXG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqXG4gICAgICogRXh0ZW5kIG1vZGVsLCB2aWV3LCBjb250cm9sbGVyIGJhc2VkIG9uIGdpdmVuIGFyZ3VtZW50c1xuICAgICAqXG4gICAgICovXG5cbiAgICAvLyBKdXN0IHRoZSBkZWZhdWx0IHByb3RvdHlwZSB7fVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIH1cblxuICAgIC8vICggdmlldy5mb3JtYXQgWyx7IG1ldGhvZDpmdW5jdGlvbiwgLi4uIH1dIClcbiAgICBlbHNlIGlmICggdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnICkge1xuXG4gICAgICAvLyBHZXQgdGVtcGxhdGUgZnJvbSAnI2lkJ1xuICAgICAgaWYgKCBhcmdzWzBdWzBdID09PSAnIycgKSB7XG5cbiAgICAgICAgJHJvb3QgPSAkKGFyZ3NbMF0pO1xuXG4gICAgICAgIC8vIFRlbXBsYXRlIGZyb20gc2NyaXB0IHRhZ1xuICAgICAgICBpZiAoICRyb290LnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpID09PSAnc2NyaXB0JyApIHtcblxuICAgICAgICAgIG9iamVjdC52aWV3LmZvcm1hdCA9ICRyb290Lmh0bWwoKTtcblxuICAgICAgICAvLyBUZW1wbGF0ZSBmcm9tIGV4aXN0aW5nIERPTVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gSW5jbHVkZSBjb250YWluZXIgaXRzZWxmXG4gICAgICAgICAgb2JqZWN0LnZpZXcuZm9ybWF0ID0gJHJvb3Qub3V0ZXJIVE1MKCk7XG4gICAgICAgICAgLy8gQXNzaWduIHJvb3QgdG8gZXhpc3RpbmcgRE9NIGVsZW1lbnRcbiAgICAgICAgICBvYmplY3Qudmlldy4kcm9vdCA9ICRyb290O1xuICAgICAgICAgIFxuICAgICAgICAgIG9iamVjdC5fdGVtcGxhdGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIC8vIG9yICc8dGVtcGxhdGU+JyBzdHJpbmdcbiAgICAgIGVsc2Ugb2JqZWN0LnZpZXcuZm9ybWF0ID0gYXJnc1swXTtcblxuICAgICAgLy8gQ29udHJvbGxlciBmcm9tIG9iamVjdFxuICAgICAgaWYgKCBhcmdzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFyZ3NbMV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICQuZXh0ZW5kKG9iamVjdC5jb250cm9sbGVyLCBhcmdzWzFdKTtcbiAgICAgICAgdXRpbC5leHRlbmRDb250cm9sbGVyKG9iamVjdCk7XG4gICAgICB9XG5cbiAgICB9IC8vIHNpbmdsZSB2aWV3IGFyZ1xuXG4gICAgLy8gUHJvdG90eXBlIGRpZmZlcmVudGlhbCBmcm9tIHNpbmdsZSB7bW9kZWwsdmlldyxjb250cm9sbGVyfSBvYmplY3RcbiAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgJiYgKGFyZ3NbMF0ubW9kZWwgfHwgYXJnc1swXS52aWV3KSApIHtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBhcmdzWzBdKSB7XG5cbiAgICAgICAgaWYgKHByb3AgPT09ICdtb2RlbCcpIHtcblxuICAgICAgICAgICQuZXh0ZW5kKG9iamVjdC5tb2RlbC5fZGF0YSwgYXJnc1swXS5tb2RlbCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAndmlldycpIHtcblxuICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1swXS52aWV3ID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICAvLyBHZXQgdGVtcGxhdGUgZnJvbSAnI2lkJ1xuICAgICAgICAgICAgaWYgKCBhcmdzWzBdLnZpZXdbMF0gPT09ICcjJyApIHtcblxuICAgICAgICAgICAgICAkcm9vdCA9ICQoYXJnc1swXS52aWV3KTtcblxuICAgICAgICAgICAgICBvYmplY3Qudmlldy5mb3JtYXQgPSAkcm9vdC5odG1sKCk7XG5cbiAgICAgICAgICAgICAgLy8gVGVtcGxhdGUgZnJvbSBzY3JpcHQgdGFnXG4gICAgICAgICAgICAgIGlmICggJHJvb3QucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCkgPT09ICdzY3JpcHQnICkge1xuXG4gICAgICAgICAgICAgICAgb2JqZWN0LnZpZXcuZm9ybWF0ID0gJHJvb3QuaHRtbCgpO1xuXG4gICAgICAgICAgICAgIC8vIFRlbXBsYXRlIGZyb20gZXhpc3RpbmcgRE9NXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIGNvbnRhaW5lciBpdHNlbGZcbiAgICAgICAgICAgICAgICBvYmplY3Qudmlldy5mb3JtYXQgPSAkcm9vdC5vdXRlckhUTUwoKTtcbiAgICAgICAgICAgICAgICAvLyBBc3NpZ24gcm9vdCB0byBleGlzdGluZyBET00gZWxlbWVudFxuICAgICAgICAgICAgICAgIG9iamVjdC52aWV3LiRyb290ID0gJHJvb3Q7XG4gICAgICAgICAgICAgICAgb2JqZWN0Ll90ZW1wbGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3IgJzx0ZW1wbGF0ZT4nIHN0cmluZ1xuICAgICAgICAgICAgZWxzZSBvYmplY3Qudmlldy5mb3JtYXQgPSBhcmdzWzBdLnZpZXc7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAkLmV4dGVuZChvYmplY3QudmlldywgYXJnc1swXS52aWV3KTsgLy8gdmlldzp7Zm9ybWF0Ont9LHN0eWxlOnt9fVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCBwcm9wID09PSAnY29udHJvbGxlcicgfHwgcHJvcCA9PT0gJ2V2ZW50cycgKSB7XG4gICAgICAgICAgJC5leHRlbmQob2JqZWN0LmNvbnRyb2xsZXIsIGFyZ3NbMF1bcHJvcF0pO1xuICAgICAgICAgIHV0aWwuZXh0ZW5kQ29udHJvbGxlcihvYmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlci1kZWZpbmVkIG1ldGhvZHNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgb2JqZWN0W3Byb3BdID0gYXJnc1swXVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gc2luZ2xlIHttb2RlbCwgdmlldywgY29udHJvbGxlcn0gYXJnXG5cbiAgICAvLyBQcm90b3R5cGUgZGlmZmVyZW50aWFsIGZyb20gc2VwYXJhdGUge21vZGVsfSwge3ZpZXd9LCB7Y29udHJvbGxlcn0gYXJndW1lbnRzXG4gICAgZWxzZSB7XG4gICAgICBcbiAgICAgIC8vIE1vZGVsIG9iamVjdFxuICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAkLmV4dGVuZChvYmplY3QubW9kZWwuX2RhdGEsIGFyZ3NbMF0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJnc1swXSkge1xuICAgICAgICB0aHJvdyBcImFnaWxpdHkuanM6IHVua25vd24gYXJndW1lbnQgdHlwZSAobW9kZWwpXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIFZpZXcgZm9ybWF0IGZyb20gc2hvcnRoYW5kIHN0cmluZyAoLi4uLCAnPGRpdj53aGF0ZXZlcjwvZGl2PicsIC4uLilcbiAgICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAvLyBAZXh0ZW5kIEdldCB0ZW1wbGF0ZSBmcm9tIElEXG4gICAgICAgIGlmICggYXJnc1sxXVswXSA9PT0gJyMnICkge1xuXG4gICAgICAgICAgLy8gb2JqZWN0LnZpZXcuZm9ybWF0ID0gJChhcmdzWzFdKS5odG1sKCk7XG5cbiAgICAgICAgICAkcm9vdCA9ICQoYXJnc1sxXSk7XG5cbiAgICAgICAgICAvLyBUZW1wbGF0ZSBmcm9tIHNjcmlwdCB0YWdcbiAgICAgICAgICBpZiAoICRyb290LnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpID09PSAnc2NyaXB0JyApIHtcblxuICAgICAgICAgICAgb2JqZWN0LnZpZXcuZm9ybWF0ID0gJHJvb3QuaHRtbCgpO1xuXG4gICAgICAgICAgLy8gVGVtcGxhdGUgZnJvbSBleGlzdGluZyBET01cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBJbmNsdWRlIGNvbnRhaW5lciBpdHNlbGZcbiAgICAgICAgICAgIG9iamVjdC52aWV3LmZvcm1hdCA9ICRyb290Lm91dGVySFRNTCgpO1xuICAgICAgICAgICAgLy8gQXNzaWduIHJvb3QgdG8gZXhpc3RpbmcgRE9NIGVsZW1lbnRcbiAgICAgICAgICAgIG9iamVjdC52aWV3LiRyb290ID0gJHJvb3Q7XG4gICAgICAgICAgICBvYmplY3QuX3RlbXBsYXRlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9iamVjdC52aWV3LmZvcm1hdCA9IGFyZ3NbMV07IC8vIGV4dGVuZCB2aWV3IHdpdGggLmZvcm1hdFxuICAgICAgfSAgXG4gICAgICAvLyBWaWV3IGZyb20gb2JqZWN0ICguLi4sIHtmb3JtYXQ6JzxkaXY+d2hhdGV2ZXI8L2Rpdj4nfSwgLi4uKVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICQuZXh0ZW5kKG9iamVjdC52aWV3LCBhcmdzWzFdKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyZ3NbMV0pIHtcbiAgICAgICAgdGhyb3cgXCJhZ2lsaXR5LmpzOiB1bmtub3duIGFyZ3VtZW50IHR5cGUgKHZpZXcpXCI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZpZXcgc3R5bGUgZnJvbSBzaG9ydGhhbmQgc3RyaW5nICguLi4sIC4uLiwgJ3Age2NvbG9yOnJlZH0nLCAuLi4pXG5cbiAgICAgIGlmICh0eXBlb2YgYXJnc1syXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2JqZWN0LnZpZXcuc3R5bGUgPSBhcmdzWzJdO1xuICAgICAgICBhcmdzLnNwbGljZSgyLCAxKTsgLy8gc28gdGhhdCBjb250cm9sbGVyIGNvZGUgYmVsb3cgd29ya3NcbiAgICAgIH1cblxuICAgICAgLy8gQ29udHJvbGxlciBmcm9tIG9iamVjdCAoLi4uLCAuLi4sIHttZXRob2Q6ZnVuY3Rpb24oKXt9fSlcbiAgICAgIGlmICh0eXBlb2YgYXJnc1syXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgJC5leHRlbmQob2JqZWN0LmNvbnRyb2xsZXIsIGFyZ3NbMl0pO1xuICAgICAgICB1dGlsLmV4dGVuZENvbnRyb2xsZXIob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyZ3NbMl0pIHtcbiAgICAgICAgdGhyb3cgXCJhZ2lsaXR5LmpzOiB1bmtub3duIGFyZ3VtZW50IHR5cGUgKGNvbnRyb2xsZXIpXCI7XG4gICAgICB9XG4gICAgICBcbiAgICB9IC8vIHNlcGFyYXRlICh7bW9kZWx9LCB7dmlld30sIHtjb250cm9sbGVyfSkgYXJnc1xuXG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqXG4gICAgICogTGF1bmNoIHNlcXVlbmNlOiBCaW5kaW5ncywgaW5pdGlhbGl6YXRpb25zLCBldGNcbiAgICAgKlxuICAgICAqL1xuICAgIFxuICAgIC8vIFNhdmUgbW9kZWwncyBpbml0aWFsIHN0YXRlIChzbyBpdCBjYW4gYmUgLnJlc2V0KCkgbGF0ZXIpXG4gICAgb2JqZWN0Lm1vZGVsLl9pbml0RGF0YSA9ICQuZXh0ZW5kKHt9LCBvYmplY3QubW9kZWwuX2RhdGEpO1xuXG4gICAgLy8gb2JqZWN0Liogd2lsbCBoYXZlIHRoZWlyICd0aGlzJyA9PT0gb2JqZWN0LiBUaGlzIHNob3VsZCBjb21lIGJlZm9yZSBjYWxsIHRvIG9iamVjdC4qIGJlbG93LlxuICAgIHV0aWwucHJveHlBbGwob2JqZWN0LCBvYmplY3QpO1xuXG4gIFxuICAgIC8vIEluaXRpYWxpemUgJHJvb3QsIG5lZWRlZCBmb3IgRE9NIGV2ZW50cyBiaW5kaW5nIGJlbG93XG4gICAgb2JqZWN0LnZpZXcucmVuZGVyKCk7XG4gIFxuXG4gICAgLy8gQmluZCBhbGwgY29udHJvbGxlcnMgdG8gdGhlaXIgZXZlbnRzXG5cbiAgICB2YXIgYmluZEV2ZW50ID0gZnVuY3Rpb24oZXYsIGhhbmRsZXIpe1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9iamVjdC5iaW5kKGV2LCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgZXZlbnRTdHIgaW4gb2JqZWN0LmNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBldmVudHMgPSBldmVudFN0ci5zcGxpdCgnOycpO1xuICAgICAgdmFyIGhhbmRsZXIgPSBvYmplY3QuY29udHJvbGxlcltldmVudFN0cl07XG4gICAgICAkLmVhY2goZXZlbnRzLCBmdW5jdGlvbihpLCBldil7XG4gICAgICAgIGV2ID0gJC50cmltKGV2KTtcbiAgICAgICAgYmluZEV2ZW50KGV2LCBoYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEF1dG8tdHJpZ2dlcnMgY3JlYXRlIGV2ZW50XG4gICAgb2JqZWN0LnRyaWdnZXIoJ2NyZWF0ZScpOyAgICBcbiAgICBcbiAgICByZXR1cm4gb2JqZWN0O1xuICAgIFxuICB9OyAvLyBhZ2lsaXR5XG5cblxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIEdsb2JhbCBwcm9wZXJ0aWVzXG4gICAqXG4gICAqL1xuXG4gIFxuICAvLyAkJC5kb2N1bWVudCBpcyBhIHNwZWNpYWwgQWdpbGl0eSBvYmplY3QsIHdob3NlIHZpZXcgaXMgYXR0YWNoZWQgdG8gPGJvZHk+XG4gIC8vIFRoaXMgb2JqZWN0IGlzIHRoZSBtYWluIGVudHJ5IHBvaW50IGZvciBhbGwgRE9NIG9wZXJhdGlvbnNcbiAgYWdpbGl0eS5kb2N1bWVudCA9IGFnaWxpdHkoe1xuICAgIF9kb2N1bWVudCA6IHRydWUsXG4gICAgdmlldzoge1xuICAgICAgJDogZnVuY3Rpb24oc2VsZWN0b3IpeyByZXR1cm4gc2VsZWN0b3IgPyAkKHNlbGVjdG9yLCAnYm9keScpIDogJCgnYm9keScpOyB9XG4gICAgfSxcbiAgICBjb250cm9sbGVyOiB7XG4gICAgICAvLyBPdmVycmlkZSBkZWZhdWx0IGNvbnRyb2xsZXIgKGRvbid0IHJlbmRlciwgZG9uJ3Qgc3R5bGl6ZSwgZXRjKVxuICAgICAgX2NyZWF0ZTogZnVuY3Rpb24oKXt9XG4gICAgfVxuICB9KTtcblxuICAvLyBTaG9ydGN1dCB0byBwcm90b3R5cGUgZm9yIHBsdWdpbnNcbiAgYWdpbGl0eS5mbiA9IGRlZmF1bHRQcm90b3R5cGU7XG5cbiAgLy8gTmFtZXNwYWNlIHRvIGRlY2xhcmUgcmV1c2FibGUgQWdpbGl0eSBvYmplY3RzXG4gIC8vIFVzZTogYXBwLmFwcGVuZCggJCQubW9kdWxlLnNvbWV0aGluZyApIG9yICQkKCAkJC5tb2R1bGUuc29tZXRoaW5nLCB7bSx2LGN9IClcbiAgYWdpbGl0eS5tb2R1bGUgPSB7fTtcblxuICAvLyBpc0FnaWxpdHkgdGVzdFxuICBhZ2lsaXR5LmlzQWdpbGl0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB1dGlsLmlzQWdpbGl0eShvYmopO1xuICB9O1xuXG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICpcbiAgICogRXhwb3J0IGl0XG4gICAqXG4gICAqL1xuXG4gIC8vIEFNRCwgQ29tbW9uSlMsIHRoZW4gZ2xvYmFsXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBAdG9kbyBJcyB0aGlzIGNvcnJlY3Q/XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gYWdpbGl0eTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gYWdpbGl0eTtcbiAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy4kJCA9IGFnaWxpdHk7XG4gIH1cblxufSkod2luZG93KTtcbiIsIlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBDb250cm9sbGVyXG4gKlxuICogRGVmYXVsdCBjb250cm9sbGVycywgaS5lLiBldmVudCBoYW5kbGVycy4gRXZlbnQgaGFuZGxlcnMgdGhhdCBzdGFydFxuICogd2l0aCAnXycgYXJlIG9mIGludGVybmFsIHVzZSBvbmx5LCBhbmQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgYW55IG90aGVyXG4gKiBoYW5kbGVyIHdpdGhvdXQgdGhhdCBwcmVmaXguIFNlZTogdHJpZ2dlcigpXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8vIFRyaWdnZXJlZCBhZnRlciBzZWxmIGNyZWF0aW9uXG4gIF9jcmVhdGU6IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICB0aGlzLnZpZXcuc3R5bGl6ZSgpO1xuICAgIHRoaXMudmlldy5iaW5kaW5ncygpOyAvLyBNb2RlbC1WaWV3IGJpbmRpbmdzXG4gICAgdGhpcy52aWV3LnN5bmMoKTsgLy8gc3luY3MgVmlldyB3aXRoIE1vZGVsXG4gIH0sXG5cbiAgLy8gVHJpZ2dlcmVkIHVwb24gcmVtb3Zpbmcgc2VsZlxuICBfZGVzdHJveTogZnVuY3Rpb24oZXZlbnQpe1xuXG4gICAgLy8gQHB1bGwgIzk1IFJlbW92ZSBnZW5lcmF0ZWQgc3R5bGUgdXBvbiBkZXN0cnVjdGlvbiBvZiBvYmplY3RzXG4gICAgLy8gQGV4dGVuZCBPbmx5IGlmIHVzaW5nIHN0eWxlIGF0dHJpYnV0ZVxuXG4gICAgaWYgKHRoaXMudmlldy5zdHlsZSkge1xuICAgICAgdmFyIG9iaklkID0gJ2FnaWxpdHlfJyArIHRoaXMuX2lkO1xuICAgICAgJCgnaGVhZCAjJytvYmpJZCwgd2luZG93LmRvY3VtZW50KS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICAvLyBkZXN0cm95IGFueSBhcHBlbmRlZCBhZ2lsaXR5IG9iamVjdHNcbiAgICB0aGlzLl9jb250YWluZXIuZW1wdHkoKTtcblxuICAgIC8vIGRlc3Ryb3kgc2VsZiBpbiBET00sIHJlbW92aW5nIGFsbCBldmVudHNcbiAgICB0aGlzLnZpZXcuJCgpLnJlbW92ZSgpO1xuICB9LFxuXG4gIC8vIFRyaWdnZXJlZCBhZnRlciBjaGlsZCBvYmogaXMgYXBwZW5kZWQgdG8gY29udGFpbmVyXG4gIF9hcHBlbmQ6IGZ1bmN0aW9uKGV2ZW50LCBvYmosIHNlbGVjdG9yKXtcbiAgICB0aGlzLnZpZXcuJChzZWxlY3RvcikuYXBwZW5kKG9iai52aWV3LiQoKSk7XG4gIH0sXG5cbiAgLy8gVHJpZ2dlcmVkIGFmdGVyIGNoaWxkIG9iaiBpcyBwcmVwZW5kZWQgdG8gY29udGFpbmVyXG4gIF9wcmVwZW5kOiBmdW5jdGlvbihldmVudCwgb2JqLCBzZWxlY3Rvcil7XG4gICAgdGhpcy52aWV3LiQoc2VsZWN0b3IpLnByZXBlbmQob2JqLnZpZXcuJCgpKTtcbiAgfSxcblxuICAvLyBUcmlnZ2VyZWQgYWZ0ZXIgY2hpbGQgb2JqIGlzIGluc2VydGVkIGluIHRoZSBjb250YWluZXJcbiAgX2JlZm9yZTogZnVuY3Rpb24oZXZlbnQsIG9iaiwgc2VsZWN0b3Ipe1xuICAgIGlmICghc2VsZWN0b3IpIHRocm93ICdhZ2lsaXR5LmpzOiBfYmVmb3JlIG5lZWRzIGEgc2VsZWN0b3InO1xuICAgIHRoaXMudmlldy4kKHNlbGVjdG9yKS5iZWZvcmUob2JqLnZpZXcuJCgpKTtcbiAgfSxcblxuICAvLyBUcmlnZ2VyZWQgYWZ0ZXIgY2hpbGQgb2JqIGlzIGluc2VydGVkIGluIHRoZSBjb250YWluZXJcbiAgX2FmdGVyOiBmdW5jdGlvbihldmVudCwgb2JqLCBzZWxlY3Rvcil7XG4gICAgaWYgKCFzZWxlY3RvcikgdGhyb3cgJ2FnaWxpdHkuanM6IF9hZnRlciBuZWVkcyBhIHNlbGVjdG9yJztcbiAgICB0aGlzLnZpZXcuJChzZWxlY3RvcikuYWZ0ZXIob2JqLnZpZXcuJCgpKTtcbiAgfSxcblxuICAvLyBUcmlnZ2VyZWQgYWZ0ZXIgYSBjaGlsZCBvYmogaXMgcmVtb3ZlZCBmcm9tIGNvbnRhaW5lciAob3Igc2VsZi1yZW1vdmVkKVxuICBfcmVtb3ZlOiBmdW5jdGlvbihldmVudCwgaWQpeyAgICAgICAgXG4gIH0sXG5cbiAgLy8gVHJpZ2dlcmVkIGFmdGVyIG1vZGVsIGlzIGNoYW5nZWRcbiAgJ19jaGFuZ2UnOiBmdW5jdGlvbihldmVudCl7XG4gIH1cbiAgXG59O1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBHZXRcbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXQoIGFyZyApIHtcblxuICAvLyBHZXQgd2hvbGUgbW9kZWxcbiAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWwuX2RhdGE7XG4gIH1cblxuICAvLyBHZXQgYXR0cmlidXRlXG4gIC8vIEBwdWxsICM5MSBBZGQgc3VwcG9ydCBmb3IgbmVzdGVkIG1vZGVsczogcGFyZW50LmNoaWxkXG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBwYXRocyA9IGFyZy5zcGxpdCgnLicpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwuX2RhdGFbcGF0aHNbMF1dO1xuICAgIC8vY2hlY2sgZm9yIG5lc3RlZCBvYmplY3RzXG4gICAgaWYgKCQuaXNQbGFpbk9iamVjdCh2YWx1ZSkpe1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwYXRocy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QodmFsdWUpICYmIHZhbHVlW3BhdGhzW2ldXSl7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVtwYXRoc1tpXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVtwYXRocy5zcGxpY2UoaSkuam9pbignLicpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL2RpcmVjdCBrZXkgYWNjZXNzXG4gICAgICB2YWx1ZSA9IHRoaXMubW9kZWwuX2RhdGFbYXJnXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdGhyb3cgJ2FnaWxpdHkuanM6IHVua25vd24gYXJndW1lbnQgZm9yIGdldHRlcic7XG59O1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBTZXQ6IHNldCBtb2RlbCBhdHRyaWJ1dGVzIGFuZCB0cmlnZ2VyIGNoYW5nZSBldmVudHNcbiAqIFxuICogQHRvZG8gUGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbnNcbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXQoIGFyZywgcGFyYW1zLCB0aGlyZCApIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBhdHRyO1xuICB2YXIgbW9kaWZpZWQgPSBbXTsgLy8gbGlzdCBvZiBtb2RpZmllZCBtb2RlbCBhdHRyaWJ1dGVzXG4gIHZhciBwcmV2aW91cyA9IHt9OyAvLyBsaXN0IG9mIHByZXZpb3VzIHZhbHVlc1xuXG4gIC8vIFNldCBpbmRpdmlkdWFsIG1vZGVsIHByb3BlcnR5OiBtb2RlbC5zZXQoIHByb3AsIHZhbHVlIClcbiAgaWYgKCB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyAmJiBwYXJhbXMgKSB7XG5cbiAgICBhdHRyID0gYXJnO1xuICAgIGFyZyA9IHt9O1xuICAgIGlmICggdHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcgKVxuICAgICAgYXJnW2F0dHJdID0gJC5leHRlbmQoe30sIHBhcmFtcyk7XG4gICAgZWxzZVxuICAgICAgYXJnW2F0dHJdID0gcGFyYW1zO1xuXG4gICAgcGFyYW1zID0gdGhpcmQgfHwge307XG4gIH1cblxuICBpZiAoIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICkge1xuXG4gICAgdmFyIF9jbG9uZSA9IHt9O1xuXG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMucmVzZXQpIHtcbiAgICAgIF9jbG9uZSA9IHRoaXMubW9kZWwuX2RhdGE7IC8vIGhvbGQgb24gdG8gZGF0YSBmb3IgY2hhbmdlIGV2ZW50c1xuICAgICAgdGhpcy5tb2RlbC5fZGF0YSA9ICQuZXh0ZW5kKHt9LCBhcmcpOyAvLyBlcmFzZXMgcHJldmlvdXMgbW9kZWwgYXR0cmlidXRlcyB3aXRob3V0IHBvaW50aW5nIHRvIG9iamVjdFxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgLy8gQGV4dGVuZCBDb21wYXJlIGFuZCBvbmx5IHRyaWdnZXIgY2hhbmdlIGV2ZW50IGZvciBtb2RpZmllZCBrZXlzXG4gICAgICBfY2xvbmUgPSAkLmV4dGVuZCh7fSwgdGhpcy5tb2RlbC5fZGF0YSk7XG5cbiAgICAgIC8vIEBwdWxsICM5MSBBZGQgc3VwcG9ydCBmb3IgbmVzdGVkIG1vZGVsc1xuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHByb3BlcnRpZXMgYW5kIGZpbmQgbmVzdGVkIGRlY2xhcmF0aW9uc1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIGFyZyl7XG4gICAgICAgIGlmIChwcm9wLmluZGV4T2YoJy4nKSA+IC0xKXtcbiAgICAgICAgICB2YXIgcGF0aCA9IHByb3Auc3BsaXQoJy4nKTtcbiAgICAgICAgICB2YXIgY3VycmVudF9ub2RlID0gdGhpcy5tb2RlbC5fZGF0YVtwYXRoWzBdXTtcbiAgICAgICAgICBpZiAoIWN1cnJlbnRfbm9kZSl7XG4gICAgICAgICAgICBjdXJyZW50X25vZGUgPSB0aGlzLm1vZGVsLl9kYXRhW3BhdGhbMF1dID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuZXh0X25vZGU7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKyl7XG4gICAgICAgICAgICBuZXh0X25vZGUgPSBjdXJyZW50X25vZGVbcGF0aFtpXV07XG4gICAgICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KG5leHRfbm9kZSkpe1xuICAgICAgICAgICAgIGN1cnJlbnRfbm9kZSA9IG5leHRfbm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgY3VycmVudF9ub2RlW3BhdGhbaV1dID0ge307XG4gICAgICAgICAgICAgY3VycmVudF9ub2RlID0gY3VycmVudF9ub2RlW3BhdGhbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGFzdF9wcm9wZXJ0eSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QoYXJnW2tleV0pICYmICQuaXNQbGFpbk9iamVjdChjdXJyZW50X25vZGVbbGFzdF9wcm9wZXJ0eV0pKXtcbiAgICAgICAgICAgLy9pZiB3ZSdyZSBhc3NpZ25pbmcgb2JqZWN0cywgZXh0ZW5kIHJhdGhlciB0aGFuIHJlcGxhY2VcbiAgICAgICAgICAgJC5leHRlbmQoY3VycmVudF9ub2RlW2xhc3RfcHJvcGVydHldLCBhcmdbcHJvcF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIGN1cnJlbnRfbm9kZVtsYXN0X3Byb3BlcnR5XSA9IGFyZ1twcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgbW9kaWZpZWQucHVzaChwcm9wKTtcbiAgICAgICAgICBwcmV2aW91c1twcm9wXSA9IF9jbG9uZVtwcm9wXTtcbiAgICAgICAgICBkZWxldGUgX2Nsb25lWyBwcm9wIF07IC8vIG5vIG5lZWQgdG8gZmlyZSBjaGFuZ2UgdHdpY2VcbiAgICAgICAgICBkZWxldGUgYXJnW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICQuZXh0ZW5kKHRoaXMubW9kZWwuX2RhdGEsIGFyZyk7IC8vIGRlZmF1bHQgaXMgZXh0ZW5kXG4gICAgfVxuXG4gICAgLy8gR2l2ZW4gb2JqZWN0XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG4gICAgICAvLyBDaGVjayBpZiBjaGFuZ2VkXG4gICAgICBpZiAodGhpcy5tb2RlbC5fZGF0YVtrZXldICE9PSBfY2xvbmVba2V5XSApIHtcbiAgICAgICAgbW9kaWZpZWQucHVzaChrZXkpO1xuICAgICAgICBwcmV2aW91c1trZXldID0gX2Nsb25lWyBrZXkgXTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBfY2xvbmVbIGtleSBdOyAvLyBubyBuZWVkIHRvIGZpcmUgY2hhbmdlIHR3aWNlXG4gICAgfVxuXG4gICAgLy8gUHJldmlvdXMgb2JqZWN0XG5cbiAgICBmb3IgKGtleSBpbiBfY2xvbmUpIHtcbiAgICAgIC8vIENoZWNrIGlmIGNoYW5nZWRcbiAgICAgIGlmICh0aGlzLm1vZGVsLl9kYXRhW2tleV0gIT09IF9jbG9uZVtrZXldICkge1xuICAgICAgICBtb2RpZmllZC5wdXNoKGtleSk7XG4gICAgICAgIHByZXZpb3VzW2tleV0gPSBfY2xvbmVbIGtleSBdO1xuICAgICAgfVxuICAgIH1cblxuICB9IGVsc2Uge1xuXG4gICAgLy8gTm90IGFuIG9iamVjdFxuICAgIHRocm93IFwiYWdpbGl0eS5qczogdW5rbm93biBhcmd1bWVudCB0eXBlIGluIG1vZGVsLnNldCgpXCI7XG4gIH1cblxuICAvLyBUaWdnZXIgY2hhbmdlIGV2ZW50c1xuXG4gIGlmIChwYXJhbXMgJiYgcGFyYW1zLnNpbGVudD09PXRydWUpIHJldHVybiB0aGlzOyAvLyBkbyBub3QgZmlyZSBldmVudHNcblxuICAvLyBAZXh0ZW5kIFBhc3MgYXJyYXkgb2YgbW9kaWZpZWQgbW9kZWwga2V5c1xuXG4gIC8vICQoKS50cmlnZ2VyIHBhcnNlcyB0aGUgc2Vjb25kIHBhcmFtZXRlciBhcyBzZXBhcmF0ZSBhcmd1bWVudHMsXG4gIC8vIHNvIHdlIHB1dCBpdCBpbiBhbiBhcnJheVxuXG4gIHRoaXMudHJpZ2dlcignY2hhbmdlJywgW21vZGlmaWVkLCBwcmV2aW91c10pO1xuXG4gICQuZWFjaChtb2RpZmllZCwgZnVuY3Rpb24oaW5kZXgsIGtleSl7XG4gICAgc2VsZi50cmlnZ2VyKCdjaGFuZ2U6JytrZXksIHByZXZpb3VzW2tleV0pO1xuICB9KTtcblxuICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluYWJsZSBjYWxsc1xuXG59O1xuIiwiXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFZhbGlkYXRlIG1vZGVsIHByb3BlcnRpZXMgYmFzZWQgb24gb2JqZWN0LnJlcXVpcmVkXG4gKlxuICovXG5cbnZhciAkdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvanF1ZXJ5LnV0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICpcbiAgICogbW9kZWwuaW52YWxpZCgpXG4gICAqIFxuICAgKiBAcmV0dXJuIEFuIGFycmF5IG9mIGludmFsaWQga2V5c1xuICAgKlxuICAgKi9cblxuICBpbnZhbGlkIDogZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgaW52YWxpZCA9IFtdO1xuXG4gICAgLy8gQ2hlY2sgZWFjaCByZXF1aXJlZCBrZXlcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnJlcXVpcmVkKSB7XG4gICAgICBpZiAoICEgdGhpcy5tb2RlbC5pc1ZhbGlkS2V5KCBrZXkgKSApXG4gICAgICAgIGludmFsaWQucHVzaChrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnZhbGlkO1xuICB9LFxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIGlzVmFsaWRcbiAgICpcbiAgICogaXNWYWxpZCgpIFZhbGlkYXRlIHdob2xlIG1vZGVsXG4gICAqIGlzVmFsaWQoIGtleSApIFZhbGlkYXRlIGtleVxuICAgKlxuICAgKiBAcmV0dXJuIGJvb2xlYW5cbiAgICpcbiAgICovXG4gIFxuXG4gIGlzVmFsaWQgOiBmdW5jdGlvbigga2V5ICkge1xuXG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgIC8vIENoZWNrIHRoZSB3aG9sZSBtb2RlbFxuICAgICAgcmV0dXJuICggdGhpcy5tb2RlbC5pbnZhbGlkKCkubGVuZ3RoID09PSAwKTtcblxuICAgIH0gZWxzZSByZXR1cm4gdGhpcy5tb2RlbC5pc1ZhbGlkS2V5KCBrZXkgKTtcblxuICB9LFxuXG4gIGlzVmFsaWRLZXkgOiBmdW5jdGlvbigga2V5ICkge1xuXG4gICAgaWYgKCB0eXBlb2YgdGhpcy5yZXF1aXJlZFtrZXldID09PSAndW5kZWZpbmVkJyApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciB2YWwgPSB0aGlzLm1vZGVsLmdldCgga2V5ICksXG4gICAgICAgIHJlcXVpcmVUeXBlID0gdGhpcy5yZXF1aXJlZFsga2V5IF07XG5cbiAgICBpZiAoIHJlcXVpcmVUeXBlID09PSB0cnVlICkge1xuXG4gICAgICByZXR1cm4gISAkLmlzRW1wdHkoIHZhbCApO1xuXG4gICAgfSBlbHNlIGlmICggcmVxdWlyZVR5cGUgPT09ICdlbWFpbCcgKSB7XG5cbiAgICAgIHJldHVybiAkLmlzRW1haWwoIHZhbCApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gT3RoZXIgdHlwZXMgb2YgcmVxdWlyZWQ6IGJvb2xlYW4sIGNoZWNrZWQsIGN1c3RvbSBjb25kaXRpb24uLj9cblxuICAgIH1cblxuICAgIHJldHVybiB0cnVlOyAvLyBQYXNzZWQgYWxsIHJlcXVpcmVtZW50c1xuICB9XG5cbn07XG5cbiIsIlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBNb2RlbCBBUElcbiAqXG4gKiBnZXRcbiAqIHNldFxuICogcmVzZXRcbiAqIHNpemVcbiAqIGVhY2hcbiAqIFxuICogaW52YWxpZFxuICogaXNWYWxpZFxuICogaXNWYWxpZEtleVxuICpcbiAqL1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmpRdWVyeSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwualF1ZXJ5IDogbnVsbCksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpLFxuICAgIG1vZGVsVmFsaWRhdGUgPSByZXF1aXJlKCcuL21vZGVsLXZhbGlkYXRlJyksXG4gICAgbW9kZWwgPSB7XG5cbiAgICAgIGdldDogcmVxdWlyZSgnLi9tb2RlbC1nZXQnKSxcbiAgICAgIHNldDogcmVxdWlyZSgnLi9tb2RlbC1zZXQnKSxcblxuICAgICAgLy8gUmVzZXR0ZXIgKHRvIGluaXRpYWwgbW9kZWwgdXBvbiBvYmplY3QgaW5pdGlhbGl6YXRpb24pXG4gICAgICByZXNldDogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQodGhpcy5tb2RlbC5faW5pdERhdGEsIHtyZXNldDp0cnVlfSk7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5hYmxlIGNhbGxzXG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBOdW1iZXIgb2YgbW9kZWwgcHJvcGVydGllc1xuICAgICAgc2l6ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHV0aWwuc2l6ZSh0aGlzLm1vZGVsLl9kYXRhKTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIC0gbG9vcHMgb3ZlciBlYWNoIG1vZGVsIHByb3BlcnR5XG4gICAgICBlYWNoOiBmdW5jdGlvbihmbil7XG4gICAgICAgIC8vIFByb3h5IHRoaXMgb2JqZWN0XG4gICAgICAgICQuZWFjaCh0aGlzLm1vZGVsLl9kYXRhLCAkLnByb3h5KGZuLHRoaXMpICk7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5hYmxlIGNhbGxzXG4gICAgICB9XG5cbiAgICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9ICQuZXh0ZW5kKCBtb2RlbCwgbW9kZWxWYWxpZGF0ZSApO1xuIiwiXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFZpZXcgYmluZGluZ3NcbiAqXG4gKiAgQXBwbHkgRE9NIDwtPiBNb2RlbCBiaW5kaW5ncywgZnJvbSBlbGVtZW50cyB3aXRoICdkYXRhLWJpbmQnIGF0dHJpYnV0ZXNcbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kaW5ncygpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7IC8vIFJlZmVyZW5jZSB0byBvYmplY3RcbiAgdmFyICRyb290Tm9kZSA9IHRoaXMudmlldy4kKCkuZmlsdGVyKCdbZGF0YS1iaW5kXScpO1xuICB2YXIgJGNoaWxkTm9kZXMgPSB0aGlzLnZpZXcuJCgnW2RhdGEtYmluZF0nKTtcblxuICB2YXIgY3JlYXRlQXR0cmlidXRlUGFpckNsb3N1cmUgPSBmdW5jdGlvbihiaW5kRGF0YSwgbm9kZSwgaSkge1xuICAgIHZhciBhdHRyUGFpciA9IGJpbmREYXRhLmF0dHJbaV07IC8vIGNhcHR1cmUgdGhlIGF0dHJpYnV0ZSBwYWlyIGluIGNsb3N1cmVcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICggYXR0clBhaXIuYXR0ciA9PSAnaHRtbCcgKSB7XG4gICAgICAgIC8vIEFsbG93IGluc2VydGluZyBIVE1MIGNvbnRlbnRcbiAgICAgICAgbm9kZS5odG1sKHNlbGYubW9kZWwuZ2V0KGF0dHJQYWlyLmF0dHJWYXIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vcm1hbCBlbGVtZW50IGF0dHJpYnV0ZXNcbiAgICAgICAgbm9kZS5hdHRyKGF0dHJQYWlyLmF0dHIsIHNlbGYubW9kZWwuZ2V0KGF0dHJQYWlyLmF0dHJWYXIpKTtcbiAgICAgIH1cblxuICAgIH07XG4gIH07XG5cbiAgJHJvb3ROb2RlLmFkZCggJGNoaWxkTm9kZXMgKS5lYWNoKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciAkbm9kZSA9ICQodGhpcyk7XG4gICAgdmFyIGJpbmREYXRhID0gX3BhcnNlQmluZFN0ciggJG5vZGUuZGF0YSgnYmluZCcpICk7XG4gICAgdmFyIHJlcXVpcmVkID0gJG5vZGUuZGF0YSgncmVxdWlyZWQnKTsgLy8gZGF0YS1yZXF1aXJlZFxuXG4gICAgdmFyIGJpbmRBdHRyaWJ1dGVzT25lV2F5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyAxLXdheSBhdHRyaWJ1dGUgYmluZGluZ1xuICAgICAgaWYgKGJpbmREYXRhLmF0dHIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5kRGF0YS5hdHRyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2VsZi5iaW5kKCdfY2hhbmdlOicrYmluZERhdGEuYXR0cltpXS5hdHRyVmFyLFxuICAgICAgICAgICAgY3JlYXRlQXR0cmlidXRlUGFpckNsb3N1cmUoYmluZERhdGEsICRub2RlLCBpKSk7XG4gICAgICAgIH0gLy8gZm9yIChiaW5kRGF0YS5hdHRyKVxuICAgICAgfSAvLyBpZiAoYmluZERhdGEuYXR0cilcbiAgICB9OyAvLyBiaW5kQXR0cmlidXRlc09uZVdheSgpXG4gICAgXG5cbiAgICAvLyA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCI+OiAyLXdheSBiaW5kaW5nXG5cbiAgICBpZiAoJG5vZGUuaXMoJ2lucHV0OmNoZWNrYm94JykpIHtcbiAgICAgIC8vIE1vZGVsIC0tPiBET01cbiAgICAgIHNlbGYuYmluZCgnX2NoYW5nZTonK2JpbmREYXRhLmtleSwgZnVuY3Rpb24oKXtcbiAgICAgICAgJG5vZGUucHJvcChcImNoZWNrZWRcIiwgc2VsZi5tb2RlbC5nZXQoYmluZERhdGEua2V5KSk7IC8vIHRoaXMgd29uJ3QgZmlyZSBhIERPTSAnY2hhbmdlJyBldmVudCwgc2F2aW5nIHVzIGZyb20gYW4gaW5maW5pdGUgZXZlbnQgbG9vcCAoTW9kZWwgPC0tPiBET00pXG4gICAgICB9KTsgICAgICAgICAgICBcbiAgICAgIC8vIERPTSAtLT4gTW9kZWxcbiAgICAgICRub2RlLmNoYW5nZShmdW5jdGlvbigpe1xuICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgIG9ialtiaW5kRGF0YS5rZXldID0gJCh0aGlzKS5wcm9wKFwiY2hlY2tlZFwiKTtcbiAgICAgICAgc2VsZi5tb2RlbC5zZXQob2JqKTsgLy8gbm90IHNpbGVudCBhcyB1c2VyIG1pZ2h0IGJlIGxpc3RlbmluZyB0byBjaGFuZ2UgZXZlbnRzXG4gICAgICB9KTtcbiAgICAgIC8vIDEtd2F5IGF0dHJpYnV0ZSBiaW5kaW5nXG4gICAgICBiaW5kQXR0cmlidXRlc09uZVdheSgpO1xuICAgIH1cbiAgICBcbiAgICAvLyA8c2VsZWN0PjogMi13YXkgYmluZGluZ1xuXG4gICAgZWxzZSBpZiAoJG5vZGUuaXMoJ3NlbGVjdCcpKSB7XG4gICAgICAvLyBNb2RlbCAtLT4gRE9NXG4gICAgICBzZWxmLmJpbmQoJ19jaGFuZ2U6JytiaW5kRGF0YS5rZXksIGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBub2RlTmFtZSA9ICRub2RlLmF0dHIoJ25hbWUnKTtcbiAgICAgICAgdmFyIG1vZGVsVmFsdWUgPSBzZWxmLm1vZGVsLmdldChiaW5kRGF0YS5rZXkpO1xuICAgICAgICAkbm9kZS52YWwobW9kZWxWYWx1ZSk7XG4gICAgICB9KTsgICAgICAgICAgICBcbiAgICAgIC8vIERPTSAtLT4gTW9kZWxcbiAgICAgICRub2RlLmNoYW5nZShmdW5jdGlvbigpe1xuICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgIG9ialtiaW5kRGF0YS5rZXldID0gJG5vZGUudmFsKCk7XG4gICAgICAgIHNlbGYubW9kZWwuc2V0KG9iaik7IC8vIG5vdCBzaWxlbnQgYXMgdXNlciBtaWdodCBiZSBsaXN0ZW5pbmcgdG8gY2hhbmdlIGV2ZW50c1xuICAgICAgfSk7XG4gICAgICAvLyAxLXdheSBhdHRyaWJ1dGUgYmluZGluZ1xuICAgICAgYmluZEF0dHJpYnV0ZXNPbmVXYXkoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gPGlucHV0IHR5cGU9XCJyYWRpb1wiPjogMi13YXkgYmluZGluZ1xuXG4gICAgZWxzZSBpZiAoJG5vZGUuaXMoJ2lucHV0OnJhZGlvJykpIHtcblxuICAgICAgLy8gTW9kZWwgLS0+IERPTVxuICAgICAgc2VsZi5iaW5kKCdfY2hhbmdlOicrYmluZERhdGEua2V5LCBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgbm9kZU5hbWUgPSAkbm9kZS5hdHRyKCduYW1lJyk7XG4gICAgICAgIHZhciBtb2RlbFZhbHVlID0gc2VsZi5tb2RlbC5nZXQoYmluZERhdGEua2V5KTtcblxuICAgICAgICAgIC8vICRub2RlLnNpYmxpbmdzKCdpbnB1dFtuYW1lPVwiJytub2RlTmFtZSsnXCJdJykuZmlsdGVyKCdbdmFsdWU9XCInK21vZGVsVmFsdWUrJ1wiXScpLnByb3AoXCJjaGVja2VkXCIsIHRydWUpO1xuXG4gICAgICAgICAgLy8gQHB1bGwgIzExMCBCaW5kaW5nIGZvciByYWRpbyBidXR0b25zXG4gICAgICAgICAgLy8gVGhleSdyZSBub3QgYWx3YXlzIHNpYmxpbmdzLCBzbyBzdGFydCBmcm9tICRyb290XG4gICAgICAgICAgc2VsZi52aWV3LiRyb290LmZpbmQoJ2lucHV0W25hbWU9XCInK25vZGVOYW1lKydcIl0nKVxuICAgICAgICAgICAgLmZpbHRlcignW3ZhbHVlPVwiJyttb2RlbFZhbHVlKydcIl0nKVxuICAgICAgICAgICAgLnByb3AoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgICAgICAgICAgLy8gdGhpcyB3b24ndCBmaXJlIGEgRE9NICdjaGFuZ2UnIGV2ZW50LCBzYXZpbmcgdXMgZnJvbVxuICAgICAgICAgICAgLy8gYW4gaW5maW5pdGUgZXZlbnQgbG9vcCAoTW9kZWwgPC0tPiBET00pXG4gICAgICB9KTsgICAgICAgICAgICBcblxuICAgICAgLy8gRE9NIC0tPiBNb2RlbFxuXG4gICAgICAkbm9kZS5jaGFuZ2UoZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKCEkbm9kZS5wcm9wKFwiY2hlY2tlZFwiKSkgcmV0dXJuOyAvLyBvbmx5IGhhbmRsZXMgY2hlY2s9dHJ1ZSBldmVudHNcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBvYmpbYmluZERhdGEua2V5XSA9ICRub2RlLnZhbCgpO1xuICAgICAgICBzZWxmLm1vZGVsLnNldChvYmopOyAvLyBub3Qgc2lsZW50IGFzIHVzZXIgbWlnaHQgYmUgbGlzdGVuaW5nIHRvIGNoYW5nZSBldmVudHNcbiAgICAgIH0pO1xuICAgICAgLy8gMS13YXkgYXR0cmlidXRlIGJpbmRpbmdcbiAgICAgIGJpbmRBdHRyaWJ1dGVzT25lV2F5KCk7XG4gICAgfVxuICAgIFxuICAgIC8vIDxpbnB1dCB0eXBlPVwic2VhcmNoXCI+IChtb2RlbCBpcyB1cGRhdGVkIGFmdGVyIGV2ZXJ5IGtleXByZXNzIGV2ZW50KVxuXG4gICAgZWxzZSBpZiAoJG5vZGUuaXMoJ2lucHV0W3R5cGU9XCJzZWFyY2hcIl0nKSkge1xuXG4gICAgICAvLyBNb2RlbCAtLT4gRE9NXG4gICAgICBzZWxmLmJpbmQoJ19jaGFuZ2U6JytiaW5kRGF0YS5rZXksIGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIHRoaXMgd29uJ3QgZmlyZSBhIERPTSAnY2hhbmdlJyBldmVudCwgc2F2aW5nIHVzIGZyb21cbiAgICAgICAgLy8gYW4gaW5maW5pdGUgZXZlbnQgbG9vcCAoTW9kZWwgPC0tPiBET00pXG4gICAgICAgICRub2RlLnZhbChzZWxmLm1vZGVsLmdldChiaW5kRGF0YS5rZXkpKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2RlbCA8LS0gRE9NXG4gICAgICAkbm9kZS5rZXlwcmVzcyhmdW5jdGlvbigpe1xuICAgICAgICAvLyBXaXRob3V0IHRpbWVvdXQgJG5vZGUudmFsKCkgbWlzc2VzIHRoZSBsYXN0IGVudGVyZWQgY2hhcmFjdGVyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgb2JqW2JpbmREYXRhLmtleV0gPSAkbm9kZS52YWwoKTtcbiAgICAgICAgICBzZWxmLm1vZGVsLnNldChvYmopOyAvLyBub3Qgc2lsZW50IGFzIHVzZXIgbWlnaHQgYmUgbGlzdGVuaW5nIHRvIGNoYW5nZSBldmVudHNcbiAgICAgICAgfSwgNTApO1xuICAgICAgfSk7XG4gICAgICAvLyAxLXdheSBhdHRyaWJ1dGUgYmluZGluZ1xuICAgICAgYmluZEF0dHJpYnV0ZXNPbmVXYXkoKTtcbiAgICB9XG5cbiAgICAvLyA8aW5wdXQgdHlwZT1cInRleHRcIj4sIDxpbnB1dD4sIGFuZCA8dGV4dGFyZWE+OiAyLXdheSBiaW5kaW5nXG5cbiAgICBlbHNlIGlmICgkbm9kZS5pcygnaW5wdXQ6dGV4dCwgaW5wdXRbdHlwZSE9XCJzZWFyY2hcIl0sIHRleHRhcmVhJykpIHtcbiAgICAgIC8vIE1vZGVsIC0tPiBET01cbiAgICAgIHNlbGYuYmluZCgnX2NoYW5nZTonK2JpbmREYXRhLmtleSwgZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gdGhpcyB3b24ndCBmaXJlIGEgRE9NICdjaGFuZ2UnIGV2ZW50LCBzYXZpbmcgdXMgZnJvbVxuICAgICAgICAvLyBhbiBpbmZpbml0ZSBldmVudCBsb29wIChNb2RlbCA8LS0+IERPTSlcbiAgICAgICAgJG5vZGUudmFsKHNlbGYubW9kZWwuZ2V0KGJpbmREYXRhLmtleSkpO1xuICAgICAgfSk7ICAgICAgICAgICAgXG4gICAgICAvLyBNb2RlbCA8LS0gRE9NXG4gICAgICAkbm9kZS5jaGFuZ2UoZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBvYmpbYmluZERhdGEua2V5XSA9ICQodGhpcykudmFsKCk7XG4gICAgICAgIHNlbGYubW9kZWwuc2V0KG9iaik7IC8vIG5vdCBzaWxlbnQgYXMgdXNlciBtaWdodCBiZSBsaXN0ZW5pbmcgdG8gY2hhbmdlIGV2ZW50c1xuICAgICAgfSk7XG4gICAgICAvLyAxLXdheSBhdHRyaWJ1dGUgYmluZGluZ1xuICAgICAgYmluZEF0dHJpYnV0ZXNPbmVXYXkoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gYWxsIG90aGVyIDx0YWc+czogMS13YXkgYmluZGluZywgb25seSBNb2RlbCAtPiBET01cblxuICAgIGVsc2Uge1xuICAgICAgaWYgKGJpbmREYXRhLmtleSkge1xuICAgICAgICBzZWxmLmJpbmQoJ19jaGFuZ2U6JytiaW5kRGF0YS5rZXksIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgdmFyIGtleSA9IHNlbGYubW9kZWwuZ2V0KGJpbmREYXRhLmtleSk7XG4gICAgICAgICAgaWYgKGtleSB8fCBrZXk9PT0wKSB7XG4gICAgICAgICAgICAkbm9kZS50ZXh0KHNlbGYubW9kZWwuZ2V0KGJpbmREYXRhLmtleSkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRub2RlLnRleHQoJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBiaW5kQXR0cmlidXRlc09uZVdheSgpO1xuICAgIH1cblxuICAgIC8vIFN0b3JlIGJpbmRpbmcgbWFwIGZvciBsYXRlciByZWZlcmVuY2VcblxuICAgIHNlbGYuJG5vZGVbIGJpbmREYXRhLmtleSBdID0gJG5vZGU7IC8vIE1vZGVsIHByb3BlcnR5IC0+IGVsZW1lbnRcbiAgICBzZWxmLmtleVsgJG5vZGUgXSA9IGJpbmREYXRhLmtleTsgLy8gRWxlbWVudCAtPiBNb2RlbCBwcm9wZXJ0eVxuXG4gICAgaWYgKCB0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgc2VsZi5yZXF1aXJlZFsgYmluZERhdGEua2V5IF0gPSByZXF1aXJlZDtcbiAgICB9XG5cbiAgfSk7IC8vIG5vZGVzLmVhY2goKVxuXG4gIHJldHVybiB0aGlzO1xuXG59OyAvLyBiaW5kaW5ncygpXG5cblxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFBhcnNlIGRhdGEtYmluZCBzdHJpbmdcbiAqIFxuICogU3ludGF4OidbYXR0cmlidXRlXVs9XSB2YXJpYWJsZVssIFthdHRyaWJ1dGVdWz1dIHZhcmlhYmxlIF0uLi4nXG4gKiBcbiAqIEFsbCBwYWlycyBpbiB0aGUgbGlzdCBhcmUgYXNzdW1lZCB0byBiZSBhdHRyaWJ1dGVzXG4gKiBJZiB0aGUgdmFyaWFibGUgaXMgbm90IGFuIGF0dHJpYnV0ZSwgaXQgbXVzdCBvY2N1ciBieSBpdHNlbGZcbiAqXG4gKiBSZXR1cm5zIHsga2V5Oidtb2RlbCBrZXknLCBhdHRyOiBbIHthdHRyIDogJ2F0dHJpYnV0ZScsIGF0dHJWYXIgOiAndmFyaWFibGUnIH0uLi4gXSB9XG4gKlxuICovXG5cbmZ1bmN0aW9uIF9wYXJzZUJpbmRTdHIoIHN0ciApIHtcbiAgdmFyIG9iaiA9IHtrZXk6bnVsbCwgYXR0cjpbXX0sXG4gICAgICBwYWlycyA9IHN0ci5zcGxpdCgnLCcpLFxuICAgICAgLy8gcmVnZXggPSAvKFthLXpBLVowLTlfXFwtXSspKD86W1xccz1dKyhbYS16QS1aMC05X1xcLV0rKSk/LyxcbiAgICAgIC8vIEBwdWxsICM5MSBBZGQgc3VwcG9ydCBmb3IgbmVzdGVkIG1vZGVsczoga2V5LnByb3BcbiAgICAgIHJlZ2V4ID0gLyhbYS16QS1aMC05X1xcLVxcLl0rKSg/OltcXHM9XSsoW2EtekEtWjAtOV9cXC1dKykpPy8sXG4gICAgICBrZXlBc3NpZ25lZCA9IGZhbHNlLFxuICAgICAgbWF0Y2hlZDtcbiAgXG4gIGlmIChwYWlycy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgbWF0Y2hlZCA9IHBhaXJzW2ldLm1hdGNoKHJlZ2V4KTtcbiAgICAgIC8vIFsgXCJhdHRyaWJ1dGUgdmFyaWFibGVcIiwgXCJhdHRyaWJ1dGVcIiwgXCJ2YXJpYWJsZVwiIF1cbiAgICAgIC8vIG9yIFsgXCJhdHRyaWJ1dGU9dmFyaWFibGVcIiwgXCJhdHRyaWJ1dGVcIiwgXCJ2YXJpYWJsZVwiIF1cbiAgICAgIC8vIG9yXG4gICAgICAvLyBbIFwidmFyaWFibGVcIiwgXCJ2YXJpYWJsZVwiLCB1bmRlZmluZWQgXVxuICAgICAgLy8gaW4gc29tZSBJRSBpdCB3aWxsIGJlIFsgXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlXCIsIFwiXCIgXVxuICAgICAgLy8gb3JcbiAgICAgIC8vIG51bGxcbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YobWF0Y2hlZFsyXSkgPT09IFwidW5kZWZpbmVkXCIgfHwgbWF0Y2hlZFsyXSA9PT0gXCJcIikge1xuICAgICAgICAgIGlmIChrZXlBc3NpZ25lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG1heSBzcGVjaWZ5IG9ubHkgb25lIGtleSAoXCIgKyBcbiAgICAgICAgICAgICAga2V5QXNzaWduZWQgKyBcIiBoYXMgYWxyZWFkeSBiZWVuIHNwZWNpZmllZCBpbiBkYXRhLWJpbmQ9XCIgKyBcbiAgICAgICAgICAgICAgc3RyICsgXCIpXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXlBc3NpZ25lZCA9IG1hdGNoZWRbMV07XG4gICAgICAgICAgICBvYmoua2V5ID0gbWF0Y2hlZFsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqLmF0dHIucHVzaCh7YXR0cjogbWF0Y2hlZFsxXSwgYXR0clZhcjogbWF0Y2hlZFsyXX0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIGlmIChtYXRjaGVkKVxuICAgIH0gLy8gZm9yIChwYWlycy5sZW5ndGgpXG4gIH0gLy8gaWYgKHBhaXJzLmxlbmd0aCA+IDApXG4gIFxuICByZXR1cm4gb2JqO1xufVxuIiwiXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFZpZXcgQVBJXG4gKlxuICogdmlldy5mb3JtYXRcbiAqIHZpZXcuc3R5bGVcbiAqIHZpZXcuJFxuICogcmVuZGVyXG4gKiBiaW5kaW5nc1xuICogc3luY1xuICogc3R5bGl6ZVxuICogJGJvdW5kXG4gKlxuICovXG5cbnZhciB2aWV3QmluZCA9IHJlcXVpcmUoJy4vdmlldy1iaW5kJyksIC8vIFZpZXcgYmluZGluZ3NcbiAgICBST09UX1NFTEVDVE9SID0gJyYnOyAvLyBBbHNvIGluIHByb3RvdHlwZS9ldmVudHMuanNcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgXG4gIC8vIERlZmF1bHRzXG4gIGZvcm1hdDogJzxkaXYvPicsXG4gIHN0eWxlOiAnJyxcbiAgXG4gIC8vIFNob3J0Y3V0IHRvIHZpZXcuJHJvb3Qgb3Igdmlldy4kcm9vdC5maW5kKCksIGRlcGVuZGluZyBvbiBzZWxlY3RvciBwcmVzZW5jZVxuICAkOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHJldHVybiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBST09UX1NFTEVDVE9SKSA/IHRoaXMudmlldy4kcm9vdCA6IHRoaXMudmlldy4kcm9vdC5maW5kKHNlbGVjdG9yKTtcbiAgfSxcbiAgXG5cbiAgLy8gUmVuZGVyICRyb290XG4gIC8vIE9ubHkgZnVuY3Rpb24gdG8gYWNjZXNzICRyb290IGRpcmVjdGx5IG90aGVyIHRoYW4gJCgpXG4gIHJlbmRlcjogZnVuY3Rpb24oKXtcblxuICAgIC8vIFdpdGhvdXQgZm9ybWF0IHRoZXJlIGlzIG5vIHZpZXdcbiAgICBpZiAodGhpcy52aWV3LmZvcm1hdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IFwiYWdpbGl0eS5qczogZW1wdHkgZm9ybWF0IGluIHZpZXcucmVuZGVyKClcIjtcbiAgICB9ICAgICAgICAgICAgICAgIFxuXG4gICAgaWYgKCB0aGlzLnZpZXcuJHJvb3QgaW5zdGFuY2VvZiBqUXVlcnkgJiYgdGhpcy5fdGVtcGxhdGUgKSB7XG5cbiAgICAgIC8vICRyb290IGlzIGZyb20gRE9NIGFscmVhZHlcblxuICAgIH0gZWxzZSBpZiAoIHRoaXMudmlldy4kcm9vdC5zaXplKCkgPT09IDAgKSB7XG5cbiAgICAgIHRoaXMudmlldy4kcm9vdCA9ICQodGhpcy52aWV3LmZvcm1hdCk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBkb24ndCBvdmVyd3JpdGUgJHJvb3QgYXMgdGhpcyB3b3VsZCByZXNldCBpdHMgcHJlc2VuY2UgaW4gdGhlIERPTVxuICAgICAgLy8gYW5kIGFsbCBldmVudHMgYWxyZWFkeSBib3VuZFxuXG4gICAgICB0aGlzLnZpZXcuJHJvb3QuaHRtbCggJCh0aGlzLnZpZXcuZm9ybWF0KS5odG1sKCkgKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBhIHZhbGlkIChub24tZW1wdHkpICRyb290XG4gICAgaWYgKCAhKHRoaXMudmlldy4kcm9vdCBpbnN0YW5jZW9mIGpRdWVyeSkgJiYgdGhpcy52aWV3LiRyb290LnNpemUoKSA9PT0gMCApIHtcbiAgICAgIHRocm93ICdhZ2lsaXR5LmpzOiBjb3VsZCBub3QgZ2VuZXJhdGUgaHRtbCBmcm9tIGZvcm1hdCc7XG4gICAgfVxuXG4gICAgdGhpcy4kdmlldyA9IHRoaXMudmlldy4kcm9vdDtcbiAgICB0aGlzLiQgPSB0aGlzLnZpZXcuJDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSwgLy8gcmVuZGVyXG5cblxuXG4gIC8vIEFwcGx5IERPTSA8LT4gTW9kZWwgYmluZGluZ3NcblxuICBiaW5kaW5nczogdmlld0JpbmQsXG5cbiAgXG5cbiAgLy8gVHJpZ2dlcnMgX2NoYW5nZSBhbmQgX2NoYW5nZToqIGV2ZW50cyBzbyB0aGF0IHZpZXcgaXMgdXBkYXRlZCBhcyBwZXIgdmlldy5iaW5kaW5ncygpXG4gIHN5bmM6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIFRyaWdnZXIgY2hhbmdlIGV2ZW50cyBzbyB0aGF0IHZpZXcgaXMgdXBkYXRlZCBhY2NvcmRpbmcgdG8gbW9kZWxcbiAgICB0aGlzLm1vZGVsLmVhY2goZnVuY3Rpb24oa2V5LCB2YWwpe1xuICAgICAgc2VsZi50cmlnZ2VyKCdfY2hhbmdlOicra2V5KTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5tb2RlbC5zaXplKCkgPiAwKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ19jaGFuZ2UnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvLyBBcHBsaWVzIHN0eWxlIGR5bmFtaWNhbGx5XG4gIHN0eWxpemU6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG9iakNsYXNzLFxuICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoUk9PVF9TRUxFQ1RPUiwgJ2cnKTtcbiAgICBpZiAodGhpcy52aWV3LnN0eWxlLmxlbmd0aCA9PT0gMCB8fCB0aGlzLnZpZXcuJCgpLnNpemUoKSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBPd24gc3R5bGVcbiAgICAvLyBPYmplY3QgZ2V0cyBvd24gY2xhc3MgbmFtZSBcIi5hZ2lsaXR5XzEyM1wiLCBhbmQgPGhlYWQ+IGdldHMgYSBjb3JyZXNwb25kaW5nIDxzdHlsZT5cbiAgICBpZiAodGhpcy52aWV3Lmhhc093blByb3BlcnR5KCdzdHlsZScpKSB7XG4gICAgICBvYmpDbGFzcyA9ICdhZ2lsaXR5XycgKyB0aGlzLl9pZDtcbiAgICAgIHZhciBzdHlsZVN0ciA9IHRoaXMudmlldy5zdHlsZS5yZXBsYWNlKHJlZ2V4LCAnLicrb2JqQ2xhc3MpO1xuICAgICAgLy8gJCgnaGVhZCcsIHdpbmRvdy5kb2N1bWVudCkuYXBwZW5kKCc8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+JytzdHlsZVN0cisnPC9zdHlsZT4nKTtcblxuICAgICAgLy8gQHB1bGwgIzk1IEFkZCBJRCBzbyBsYXRlciB3ZSBjYW4gcmVtb3ZlIGdlbmVyYXRlZCBzdHlsZVxuICAgICAgLy8gdXBvbiBkZXN0cnVjdGlvbiBvZiBvYmplY3RzXG4gICAgICAkKCdoZWFkJywgd2luZG93LmRvY3VtZW50KS5hcHBlbmQoJzxzdHlsZSBpZD1cIicrIG9iakNsYXNzICsnXCIgdHlwZT1cInRleHQvY3NzXCI+JytcbiAgICAgICAgc3R5bGVTdHIrJzwvc3R5bGU+Jyk7XG4gICAgICB0aGlzLnZpZXcuJCgpLmFkZENsYXNzKG9iakNsYXNzKTtcbiAgICB9XG4gICAgLy8gSW5oZXJpdGVkIHN0eWxlXG4gICAgLy8gT2JqZWN0IGluaGVyaXRzIENTUyBjbGFzcyBuYW1lIGZyb20gZmlyc3QgYW5jZXN0b3IgdG8gaGF2ZSBvd24gdmlldy5zdHlsZVxuICAgIGVsc2Uge1xuICAgICAgLy8gUmV0dXJucyBpZCBvZiBmaXJzdCBhbmNlc3RvciB0byBoYXZlICdvd24nIHZpZXcuc3R5bGVcbiAgICAgIHZhciBhbmNlc3RvcldpdGhTdHlsZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB3aGlsZSAob2JqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgb2JqZWN0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICAgICAgaWYgKG9iamVjdC52aWV3Lmhhc093blByb3BlcnR5KCdzdHlsZScpKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdC5faWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH07IC8vIGFuY2VzdG9yV2l0aFN0eWxlXG5cbiAgICAgIHZhciBhbmNlc3RvcklkID0gYW5jZXN0b3JXaXRoU3R5bGUodGhpcyk7XG4gICAgICBvYmpDbGFzcyA9ICdhZ2lsaXR5XycgKyBhbmNlc3RvcklkO1xuICAgICAgdGhpcy52aWV3LiQoKS5hZGRDbGFzcyhvYmpDbGFzcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICpcbiAgICogRXh0ZW5kZWRcbiAgICpcbiAgICovXG5cbiAgLy8gUmV0dXJuIGVsZW1lbnQocykgYm91bmQgdG8gYSBtb2RlbCBwcm9wZXJ0eVxuICAvLyBSZWZlciB0byBtYXAgaW4gbWFpbiBvYmplY3RcblxuICAkYm91bmQ6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuJG5vZGVbIGtleSBdICE9PSB1bmRlZmluZWQgPyB0aGlzLiRub2RlWyBrZXkgXSA6IGZhbHNlO1xuXG4gICAgLyogT2xkIHdheTogZnJvbSBET01cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy52aWV3LiQoJ1tkYXRhLWJpbmRdJykuZmlsdGVyKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgYmluZERhdGEgPSBzZWxmLnZpZXcuX3BhcnNlQmluZFN0ciggJCh0aGlzKS5kYXRhKCdiaW5kJykgKTtcbiAgICAgIC8vIFdoYXQgYWJvdXQgbXVsdGlwbGUgb3IgbmVzdGVkIGJpbmRpbmdzP1xuICAgICAgcmV0dXJuICggYmluZERhdGEua2V5ID09IGtleSApO1xuICAgIH0pOyAqL1xuICB9XG5cbn07XG4iLCJcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogX2NvbnRhaW5lclxuICpcbiAqIEFQSSBhbmQgcmVsYXRlZCBhdXhpbGlhcnkgZnVuY3Rpb25zIGZvciBzdG9yaW5nIGNoaWxkIEFnaWxpdHkgb2JqZWN0cy5cbiAqIE5vdCBhbGwgbWV0aG9kcyBhcmUgZXhwb3NlZC4gU2VlICdzaG9ydGN1dHMnIGJlbG93IGZvciBleHBvc2VkIG1ldGhvZHMuXG4gKlxuICovXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cualF1ZXJ5IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5qUXVlcnkgOiBudWxsKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8vIEFkZHMgY2hpbGQgb2JqZWN0IHRvIGNvbnRhaW5lciwgYXBwZW5kcy9wcmVwZW5kcy9ldGMgdmlldywgbGlzdGVucyBmb3IgY2hpbGQgcmVtb3ZhbFxuICBfaW5zZXJ0T2JqZWN0OiBmdW5jdGlvbihvYmosIHNlbGVjdG9yLCBtZXRob2Qpe1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICghdXRpbC5pc0FnaWxpdHkob2JqKSkge1xuICAgICAgdGhyb3cgXCJhZ2lsaXR5LmpzOiBhcHBlbmQgYXJndW1lbnQgaXMgbm90IGFuIGFnaWxpdHkgb2JqZWN0XCI7XG4gICAgfVxuXG4gICAgdGhpcy5fY29udGFpbmVyLmNoaWxkcmVuW29iai5faWRdID0gb2JqOyAvLyBjaGlsZHJlbiBpcyAqbm90KiBhbiBhcnJheTsgdGhpcyBpcyBmb3Igc2ltcGxlciBsb29rdXBzIGJ5IGdsb2JhbCBvYmplY3QgaWRcbiAgICB0aGlzLnRyaWdnZXIobWV0aG9kLCBbb2JqLCBzZWxlY3Rvcl0pO1xuICAgIG9iai5fcGFyZW50ID0gdGhpcztcbiAgICAvLyBlbnN1cmVzIG9iamVjdCBpcyByZW1vdmVkIGZyb20gY29udGFpbmVyIHdoZW4gZGVzdHJveWVkOlxuICAgIG9iai5iaW5kKCdkZXN0cm95JywgZnVuY3Rpb24oZXZlbnQsIGlkKXsgXG4gICAgICBzZWxmLl9jb250YWluZXIucmVtb3ZlKGlkKTtcbiAgICB9KTtcbiAgICAvLyBUcmlnZ2VyIGV2ZW50IGZvciBjaGlsZCB0byBsaXN0ZW4gdG9cbiAgICBvYmoudHJpZ2dlcigncGFyZW50OicrbWV0aG9kKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBhcHBlbmQ6IGZ1bmN0aW9uKG9iaiwgc2VsZWN0b3IpIHsgXG4gICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyLl9pbnNlcnRPYmplY3QuY2FsbCh0aGlzLCBvYmosIHNlbGVjdG9yLCAnYXBwZW5kJyk7IFxuICB9LFxuXG4gIHByZXBlbmQ6IGZ1bmN0aW9uKG9iaiwgc2VsZWN0b3IpIHsgXG4gICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyLl9pbnNlcnRPYmplY3QuY2FsbCh0aGlzLCBvYmosIHNlbGVjdG9yLCAncHJlcGVuZCcpOyBcbiAgfSxcblxuICBhZnRlcjogZnVuY3Rpb24ob2JqLCBzZWxlY3RvcikgeyBcbiAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXIuX2luc2VydE9iamVjdC5jYWxsKHRoaXMsIG9iaiwgc2VsZWN0b3IsICdhZnRlcicpOyBcbiAgfSxcblxuICBiZWZvcmU6IGZ1bmN0aW9uKG9iaiwgc2VsZWN0b3IpIHsgXG4gICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyLl9pbnNlcnRPYmplY3QuY2FsbCh0aGlzLCBvYmosIHNlbGVjdG9yLCAnYmVmb3JlJyk7IFxuICB9LFxuICBcbiAgLy8gUmVtb3ZlcyBjaGlsZCBvYmplY3QgZnJvbSBjb250YWluZXJcbiAgcmVtb3ZlOiBmdW5jdGlvbihpZCl7XG4gICAgZGVsZXRlIHRoaXMuX2NvbnRhaW5lci5jaGlsZHJlbltpZF07XG4gICAgdGhpcy50cmlnZ2VyKCdyZW1vdmUnLCBpZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gSXRlcmF0ZXMgb3ZlciBhbGwgY2hpbGQgb2JqZWN0cyBpbiBjb250YWluZXJcbiAgZWFjaDogZnVuY3Rpb24oZm4pe1xuICAgICQuZWFjaCh0aGlzLl9jb250YWluZXIuY2hpbGRyZW4sIGZuKTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluYWJsZSBjYWxsc1xuICB9LFxuXG4gIC8vIFJlbW92ZXMgYWxsIG9iamVjdHMgaW4gY29udGFpbmVyXG4gIGVtcHR5OiBmdW5jdGlvbigpe1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIFxuICAvLyBOdW1iZXIgb2YgY2hpbGRyZW5cbiAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0aWwuc2l6ZSh0aGlzLl9jb250YWluZXIuY2hpbGRyZW4pO1xuICB9XG4gIFxufTtcbiIsIlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBfZXZlbnRzIEFQSSBhbmQgYXV4aWxpYXJ5IGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgZXZlbnRzXG4gKlxuICovXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cualF1ZXJ5IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5qUXVlcnkgOiBudWxsKSxcbiAgICBST09UX1NFTEVDVE9SID0gJyYnOyAvLyBBbHNvIGluIG12Yy92aWV3LmpzXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8vIEJpbmRzIGV2ZW50U3RyIHRvIGZuLiBldmVudFN0ciBpcyBwYXJzZWQgYXMgcGVyIHBhcnNlRXZlbnRTdHIoKVxuICBiaW5kOiBmdW5jdGlvbihldmVudFN0ciwgZm4pe1xuXG4gICAgdmFyIGV2ZW50T2JqID0gcGFyc2VFdmVudFN0cihldmVudFN0cik7XG5cbiAgICAvLyBET00gZXZlbnQgJ2V2ZW50IHNlbGVjdG9yJywgZS5nLiAnY2xpY2sgYnV0dG9uJ1xuICAgIGlmIChldmVudE9iai5zZWxlY3Rvcikge1xuXG4gICAgICAvLyBLZWVwIGNsaWNrIGFuZCBzdWJtaXQgbG9jYWxpemVkXG4gICAgICB2YXIgZm54ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZm4oZXZlbnQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFByZXZlbnQgZGVmYXVsdCAmIGJ1YmJsaW5nXG4gICAgICAgIC8vIG9yIGp1c3QgZGVmYXVsdD8gaWYgKCAhIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE1hbnVhbGx5IG92ZXJyaWRlIHJvb3Qgc2VsZWN0b3IsIGFzIGpRdWVyeSBzZWxlY3RvcnMgY2FuJ3Qgc2VsZWN0IHNlbGYgb2JqZWN0XG4gICAgICBpZiAoZXZlbnRPYmouc2VsZWN0b3IgPT09IFJPT1RfU0VMRUNUT1IpIHtcblxuICAgICAgICBpZiAoIGV2ZW50T2JqLnR5cGUgPT09ICdjbGljaycgfHwgZXZlbnRPYmoudHlwZSA9PT0gJ3N1Ym1pdCcgKSB7XG4gICAgICAgICAgdGhpcy52aWV3LiQoKS5vbihldmVudE9iai50eXBlLCBmbngpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudmlldy4kKCkub24oZXZlbnRPYmoudHlwZSwgZm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQGV4dGVuZCBSZXBsYWNlICQoKS5iaW5kIHdpdGggJCgpLm9uXG4gICAgICAgIC8vIHRoaXMudmlldy4kKCkuYmluZChldmVudE9iai50eXBlLCBmbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcblxuICAgICAgICBpZiAoIGV2ZW50T2JqLnR5cGUgPT09ICdjbGljaycgfHwgZXZlbnRPYmoudHlwZSA9PT0gJ3N1Ym1pdCcgKSB7XG4gICAgICAgICAgdGhpcy52aWV3LiQoKS5vbihldmVudE9iai50eXBlLCBldmVudE9iai5zZWxlY3RvciwgZm54KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnZpZXcuJCgpLm9uKGV2ZW50T2JqLnR5cGUsIGV2ZW50T2JqLnNlbGVjdG9yLCBmbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAZXh0ZW5kIFJlcGxhY2UgJCgpLmRlbGVnYXRlIHdpdGggJCgpLm9uXG4gICAgICAgIC8vIHRoaXMudmlldy4kKCkuZGVsZWdhdGUoZXZlbnRPYmouc2VsZWN0b3IsIGV2ZW50T2JqLnR5cGUsIGZuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ3VzdG9tIGV2ZW50XG4gICAgZWxzZSB7XG5cbiAgICAgIC8vIEBleHRlbmQgUmVwbGFjZSAkKCkuYmluZCB3aXRoICQoKS5vblxuICAgICAgJCh0aGlzLl9ldmVudHMuZGF0YSkub24oZXZlbnRPYmoudHlwZSwgZm4pO1xuICAgICAgLy8gJCh0aGlzLl9ldmVudHMuZGF0YSkuYmluZChldmVudE9iai50eXBlLCBmbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5hYmxlIGNhbGxzXG4gIH0sIC8vIGJpbmRcblxuICAvLyBBbGlhcyB0byBiaW5kKClcbiAgb246IGZ1bmN0aW9uKCBldmVudFN0ciwgZm4gKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5iaW5kKCBldmVudFN0ciwgZm4gKTtcbiAgfSxcblxuICAvLyBUcmlnZ2VycyBldmVudFN0ci4gU3ludGF4IGZvciBldmVudFN0ciBpcyBzYW1lIGFzIHRoYXQgZm9yIGJpbmQoKVxuICB0cmlnZ2VyOiBmdW5jdGlvbihldmVudFN0ciwgcGFyYW1zKXtcblxuICAgIHZhciBldmVudE9iaiA9IHBhcnNlRXZlbnRTdHIoZXZlbnRTdHIpO1xuXG4gICAgLy8gRE9NIGV2ZW50ICdldmVudCBzZWxlY3RvcicsIGUuZy4gJ2NsaWNrIGJ1dHRvbidcbiAgICBpZiAoZXZlbnRPYmouc2VsZWN0b3IpIHtcbiAgICAgIC8vIE1hbnVhbGx5IG92ZXJyaWRlIHJvb3Qgc2VsZWN0b3IsIGFzIGpRdWVyeSBzZWxlY3RvcnMgY2FuJ3Qgc2VsZWN0IHNlbGYgb2JqZWN0XG4gICAgICBpZiAoZXZlbnRPYmouc2VsZWN0b3IgPT09IFJPT1RfU0VMRUNUT1IpIHtcbiAgICAgICAgdGhpcy52aWV3LiQoKS50cmlnZ2VyKGV2ZW50T2JqLnR5cGUsIHBhcmFtcyk7XG4gICAgICB9XG4gICAgICBlbHNlIHsgICAgICAgICAgXG4gICAgICAgIHRoaXMudmlldy4kKCkuZmluZChldmVudE9iai5zZWxlY3RvcikudHJpZ2dlcihldmVudE9iai50eXBlLCBwYXJhbXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBDdXN0b20gZXZlbnRcbiAgICBlbHNlIHtcbiAgICAgICQodGhpcy5fZXZlbnRzLmRhdGEpLnRyaWdnZXIoJ18nK2V2ZW50T2JqLnR5cGUsIHBhcmFtcyk7XG4gICAgICAvLyBmaXJlICdwcmUnIGhvb2tzIGluIHJldmVyc2UgYXR0YWNobWVudCBvcmRlciAoIGxhc3QgZmlyc3QgKSB0aGVuIHB1dCB0aGVtIGJhY2tcbiAgICAgIHJldmVyc2VFdmVudHModGhpcy5fZXZlbnRzLmRhdGEsICdwcmU6JyArIGV2ZW50T2JqLnR5cGUpO1xuICAgICAgJCh0aGlzLl9ldmVudHMuZGF0YSkudHJpZ2dlcigncHJlOicgKyBldmVudE9iai50eXBlLCBwYXJhbXMpO1xuICAgICAgcmV2ZXJzZUV2ZW50cyh0aGlzLl9ldmVudHMuZGF0YSwgJ3ByZTonICsgZXZlbnRPYmoudHlwZSk7XG5cbiAgICAgICQodGhpcy5fZXZlbnRzLmRhdGEpLnRyaWdnZXIoZXZlbnRPYmoudHlwZSwgcGFyYW1zKTtcblxuICAgICAgLy8gVHJpZ2dlciBldmVudCBmb3IgcGFyZW50XG4gICAgICBpZiAodGhpcy5wYXJlbnQoKSlcbiAgICAgICAgdGhpcy5wYXJlbnQoKS50cmlnZ2VyKChldmVudE9iai50eXBlLm1hdGNoKC9eY2hpbGQ6LykgPyAnJyA6ICdjaGlsZDonKSArIGV2ZW50T2JqLnR5cGUsIHBhcmFtcyk7XG4gICAgICAkKHRoaXMuX2V2ZW50cy5kYXRhKS50cmlnZ2VyKCdwb3N0OicgKyBldmVudE9iai50eXBlLCBwYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluYWJsZSBjYWxsc1xuICB9IC8vIHRyaWdnZXJcbiAgXG59O1xuXG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogUGFyc2UgZXZlbnQgc3RyaW5nXG4gKlxuICogJ2V2ZW50JyAgICAgICAgICA6IGN1c3RvbSBldmVudFxuICogJ2V2ZW50IHNlbGVjdG9yJyA6IERPTSBldmVudCB1c2luZyAnc2VsZWN0b3InXG4gKlxuICogUmV0dXJucyB7IHR5cGU6J2V2ZW50JyBbLCBzZWxlY3Rvcjonc2VsZWN0b3InXSB9XG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUV2ZW50U3RyKCBldmVudFN0ciApIHtcblxuICB2YXIgZXZlbnRPYmogPSB7IHR5cGU6ZXZlbnRTdHIgfSwgXG4gICAgICBzcGFjZVBvcyA9IGV2ZW50U3RyLnNlYXJjaCgvXFxzLyk7XG5cbiAgLy8gRE9NIGV2ZW50ICdldmVudCBzZWxlY3RvcicsIGUuZy4gJ2NsaWNrIGJ1dHRvbidcbiAgaWYgKHNwYWNlUG9zID4gLTEpIHtcbiAgICBldmVudE9iai50eXBlID0gZXZlbnRTdHIuc3Vic3RyKDAsIHNwYWNlUG9zKTtcbiAgICBldmVudE9iai5zZWxlY3RvciA9IGV2ZW50U3RyLnN1YnN0cihzcGFjZVBvcysxKTtcbiAgfSBlbHNlIGlmICggZXZlbnRTdHIgPT09ICdjbGljaycgfHwgZXZlbnRTdHIgPT09ICdzdWJtaXQnICkge1xuICAgIC8vIEBleHRlbmQgU2hvcnRjdXQgZm9yICdjbGljayAmJyBhbmQgJ3N1Ym1pdCAmJ1xuICAgIGV2ZW50T2JqLnR5cGUgPSBldmVudFN0cjtcbiAgICBldmVudE9iai5zZWxlY3RvciA9IFJPT1RfU0VMRUNUT1I7XG4gIH1cbiAgcmV0dXJuIGV2ZW50T2JqO1xufVxuXG4vLyBSZXZlcnNlcyB0aGUgb3JkZXIgb2YgZXZlbnRzIGF0dGFjaGVkIHRvIGFuIG9iamVjdFxuXG5mdW5jdGlvbiByZXZlcnNlRXZlbnRzKG9iaiwgZXZlbnRUeXBlKXtcblxuICB2YXIgZXZlbnRzID0gJChvYmopLmRhdGEoJ2V2ZW50cycpO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCAmJiBldmVudHNbZXZlbnRUeXBlXSAhPT0gdW5kZWZpbmVkKXtcbiAgICAvLyBjYW4ndCByZXZlcnNlIHdoYXQncyBub3QgdGhlcmVcbiAgICB2YXIgcmV2ZXJzZWRFdmVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBlIGluIGV2ZW50c1tldmVudFR5cGVdKXtcbiAgICAgIGlmICghZXZlbnRzW2V2ZW50VHlwZV0uaGFzT3duUHJvcGVydHkoZSkpIGNvbnRpbnVlO1xuICAgICAgcmV2ZXJzZWRFdmVudHMudW5zaGlmdChldmVudHNbZXZlbnRUeXBlXVtlXSk7XG4gICAgfVxuICAgIGV2ZW50c1tldmVudFR5cGVdID0gcmV2ZXJzZWRFdmVudHM7XG4gIH1cbn1cbiIsIlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBFeHRlbmRlZCBzaG9ydGN1dHNcbiAqIFxuICogcmVwbGFjZSwgY2hpbGQsIGNoaWxkcmVuLCBsb2FkXG4gKlxuICovXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cualF1ZXJ5IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5qUXVlcnkgOiBudWxsKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgZ2V0IDogZnVuY3Rpb24oIGFyZyApIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXQoIGFyZyApO1xuICB9LFxuXG4gIHNldCA6IGZ1bmN0aW9uKCBhcmcsIHBhcmFtcywgdGhpcmQgKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWwuc2V0KCBhcmcsIHBhcmFtcywgdGhpcmQgICk7XG4gIH0sXG5cbiAgaW52YWxpZCA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1vZGVsLmludmFsaWQoKTtcbiAgfSxcblxuICByZXBsYWNlOiBmdW5jdGlvbiggb2JqLCBzZWxlY3RvciApe1xuICAgIGlmICggdHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJyApIHtcbiAgICAgIHRoaXMudmlldy4kKHNlbGVjdG9yKS5odG1sKCcnKTtcbiAgICB9XG4gICAgdGhpcy5lbXB0eSgpLl9jb250YWluZXIuYXBwZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmFibGUgY2FsbHNcbiAgfSxcblxuICAvLyBSZXR1cm4gbnRoIGNoaWxkIG9iamVjdFxuICBjaGlsZDogZnVuY3Rpb24obil7XG4gICAgdmFyIGkgPSAwO1xuICAgIG4gPSBuIHx8IDA7XG5cbiAgICBmb3IgKHZhciBqIGluIHRoaXMuX2NvbnRhaW5lci5jaGlsZHJlbikge1xuICAgICAgaWYgKCB0aGlzLl9jb250YWluZXIuY2hpbGRyZW4uaGFzT3duUHJvcGVydHkoaikgKSB7XG4gICAgICAgIGlmICggaSA9PSBuIClcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyLmNoaWxkcmVuW2pdO1xuICAgICAgICBlbHNlIGlmICggaSA+IG4gKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpKys7IC8vIENvbnRpbnVlIHNlYXJjaGluZ1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLy8gUmV0dXJuIGFsbCBjaGlsZCBvYmplY3RzXG4gIGNoaWxkcmVuOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9jb250YWluZXIuY2hpbGRyZW47IC8vIHsgaWQ6IGNoaWxkLCAuLiB9XG4gIH0sXG5cbiAgLy8gUmVwbGFjZSBjaGlsZHJlbiBtb2RlbHMgLSBhcHBlbmQgaWYgdGhlcmUncyBtb3JlLCBkZXN0cm95IGlmIGxlc3NcbiAgbG9hZDogZnVuY3Rpb24oIHByb3RvLCBtb2RlbHMsIHNlbGVjdG9yICkge1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBtYXhNb2RlbHMgPSBtb2RlbHMubGVuZ3RoLFxuICAgICAgICBtYXhDaGlsZHJlbiA9IHRoaXMuc2l6ZSgpO1xuXG4gICAgJC5lYWNoKG1vZGVscywgZnVuY3Rpb24oaW5kZXgsIG1vZGVsKSB7XG4gICAgICBpZiAoIHNlbGYuY2hpbGQoaW5kZXgpICkge1xuICAgICAgICBzZWxmLmNoaWxkKGluZGV4KS5tb2RlbC5zZXQoIG1vZGVsICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmFwcGVuZCggJCQoIHByb3RvLCBtb2RlbCApLCBzZWxlY3RvciApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG1heENoaWxkcmVuID4gbWF4TW9kZWxzKSB7XG4gICAgICBmb3IgKHZhciBpID0gbWF4TW9kZWxzOyBpIDwgbWF4Q2hpbGRyZW47IGkrKykge1xuICAgICAgICAvLyBDaGlsZCdzIGluZGV4IHN0YXlzIHRoZSBzYW1lLCBzaW5jZSBlYWNoIG9uZSBpcyBkZXN0cm95ZWRcbiAgICAgICAgc2VsZi5jaGlsZChtYXhNb2RlbHMpLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59O1xuIiwiXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIEZvcm0gaGVscGVyc1xuICpcbiAqL1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmpRdWVyeSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwualF1ZXJ5IDogbnVsbCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGZvcm0gOiB7XG5cbiAgICAvLyBDbGVhciB0aGUgZm9ybVxuICAgIGNsZWFyIDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHJldHVybiB0aGlzLiR2aWV3LmZpbmQoJzppbnB1dCcpXG4gICAgICAgIC5ub3QoJzpidXR0b24sIDpzdWJtaXQsIDpyZXNldCwgOmhpZGRlbicpLnJlbW92ZUF0dHIoJ2NoZWNrZWQnKS5yZW1vdmVBdHRyKCdzZWxlY3RlZCcpXG4gICAgICAgIC5ub3QoJzpjaGVja2JveCwgOnJhZGlvLCBzZWxlY3QnKS52YWwoJycpO1xuICAgIH0sXG5cbiAgICAvLyBWYWxpZGF0ZSBtb2RlbCwgaW5zdGVhZCBvZiBmb3JtIGluIHRoZSBET00gZGlyZWN0bHlcbiAgICAvLyBAcmV0dXJuIEFuIGFycmF5IG9mIGludmFsaWQgbW9kZWwgcHJvcGVydGllc1xuICAgIGludmFsaWQgOiBmdW5jdGlvbigpIHtcblxuICAgICAgcmV0dXJuIHRoaXMubW9kZWwuaW52YWxpZCgpO1xuICAgIH1cbiAgfVxuXG59O1xuXG4iLCJcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogQ29uc3RydWN0IGRlZmF1bHQgb2JqZWN0IHByb3RvdHlwZVxuICpcbiAqL1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmpRdWVyeSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwualF1ZXJ5IDogbnVsbCksXG5cbiAgICBkZWZhdWx0UHJvdG90eXBlID0ge1xuXG4gICAgICBfYWdpbGl0eTogdHJ1ZSxcbiAgICAgIF9jb250YWluZXI6IHJlcXVpcmUoJy4vY29udGFpbmVyJyksXG4gICAgICBfZXZlbnRzOiByZXF1aXJlKCcuL2V2ZW50cycpLFxuXG4gICAgICAkbm9kZToge30sIC8vIE1hcCBvZiBtb2RlbCBwcm9wZXJ0aWVzIC0+IGJvdW5kIGVsZW1lbnRzXG4gICAgICBrZXk6IHt9LCAvLyBNYXAgb2YgZWxlbWVudHMgLT4gYm91bmQgbW9kZWwgcHJvcGVydGllc1xuICAgICAgcmVxdWlyZWQ6IHt9LCAvLyBNYXAgb2YgcmVxdWlyZWQgbW9kZWwgcHJvcGVydGllcyBhbmQgcmVxdWlyZSB0eXBlc1xuXG4gICAgICBtb2RlbDogcmVxdWlyZSgnLi4vbXZjL21vZGVsJyksXG4gICAgICB2aWV3OiByZXF1aXJlKCcuLi9tdmMvdmlldycpLFxuICAgICAgY29udHJvbGxlcjogcmVxdWlyZSgnLi4vbXZjL2NvbnRyb2xsZXInKVxuXG4gICAgfSxcblxuICAgIHNob3J0Y3V0cyA9IHJlcXVpcmUoJy4vc2hvcnRjdXRzJyksXG4gICAgZXh0ZW5kID0gcmVxdWlyZSgnLi9leHRlbmQnKSxcbiAgICBmb3JtID0gcmVxdWlyZSgnLi9mb3JtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gJC5leHRlbmQodHJ1ZSwgZGVmYXVsdFByb3RvdHlwZSwgc2hvcnRjdXRzLCBleHRlbmQsIGZvcm0pO1xuIiwiXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIE9iamVjdCBzaG9ydGN1dHNcbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdkZXN0cm95JywgdGhpcy5faWQpOyAvLyBwYXJlbnQgbXVzdCBsaXN0ZW4gdG8gJ3JlbW92ZScgZXZlbnQgYW5kIGhhbmRsZSBjb250YWluZXIgcmVtb3ZhbCFcbiAgICAvLyBjYW4ndCByZXR1cm4gdGhpcyBhcyBpdCBtaWdodCBub3QgZXhpc3QgYW55bW9yZSFcbiAgfSxcbiAgcGFyZW50OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gIH0sXG4gIFxuICAvL1xuICAvLyBfY29udGFpbmVyIHNob3J0Y3V0c1xuICAvL1xuICBhcHBlbmQ6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5hYmxlIGNhbGxzXG4gIH0sXG4gIHByZXBlbmQ6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fY29udGFpbmVyLnByZXBlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluYWJsZSBjYWxsc1xuICB9LFxuICBhZnRlcjogZnVuY3Rpb24oKXtcbiAgICB0aGlzLl9jb250YWluZXIuYWZ0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluYWJsZSBjYWxsc1xuICB9LFxuICBiZWZvcmU6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fY29udGFpbmVyLmJlZm9yZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5hYmxlIGNhbGxzXG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24oKXtcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmFibGUgY2FsbHNcbiAgfSxcbiAgc2l6ZTogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyLnNpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcbiAgZWFjaDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyLmVhY2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcbiAgZW1wdHk6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lci5lbXB0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8vXG4gIC8vIF9ldmVudHMgc2hvcnRjdXRzXG4gIC8vXG4gIGJpbmQ6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fZXZlbnRzLmJpbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluYWJsZSBjYWxsc1xuICB9LFxuICBvbjogZnVuY3Rpb24oKXsgLy8gQWxpYXNcbiAgICB0aGlzLl9ldmVudHMuYmluZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5hYmxlIGNhbGxzXG4gIH0sXG4gIHRyaWdnZXI6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fZXZlbnRzLnRyaWdnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluYWJsZSBjYWxsc1xuICB9LFxuXG59O1xuIiwiXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIGpRdWVyeSB1dGlsaXR5IGZ1bmN0aW9uc1xuICpcbiAqL1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmpRdWVyeSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwualF1ZXJ5IDogbnVsbCk7XG5cbi8vIEdldCBlbGVtZW50IGluY2x1ZGluZyB3cmFwcGluZyB0YWdcblxuJC5mbi5vdXRlckhUTUwgPSBmdW5jdGlvbihzKSB7XG4gIGlmIChzKSB7XG4gICAgcmV0dXJuIHRoaXMuYmVmb3JlKHMpLnJlbW92ZSgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBkb2MgPSB0aGlzWzBdID8gdGhpc1swXS5vd25lckRvY3VtZW50IDogZG9jdW1lbnQ7XG4gICAgcmV0dXJuIGpRdWVyeSgnPGRpdj4nLCBkb2MpLmFwcGVuZCh0aGlzLmVxKDApLmNsb25lKCkpLmh0bWwoKTtcbiAgfVxufTtcblxuXG5cbi8vIEdlbmVyaWMgaXNFbXB0eVxuXG4kLmlzRW1wdHkgPSBmdW5jdGlvbiggbWl4ZWRfdmFyICkge1xuXG4gIC8vIEVtcHR5OiBudWxsLCB1bmRlZmluZWQsICcnLCBbXSwge31cbiAgLy8gTm90IGVtcHR5OiAwLCB0cnVlLCBmYWxzZVxuICAvLyBXaGF0IGFib3V0IGpRdWVyeSBvYmplY3Q/XG5cbiAgdmFyIHVuZGVmLCBrZXksIGksIGxlbjtcbiAgdmFyIGVtcHR5VmFsdWVzID0gW3VuZGVmLCBudWxsLCAnJ107XG5cbiAgZm9yIChpID0gMCwgbGVuID0gZW1wdHlWYWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAobWl4ZWRfdmFyID09PSBlbXB0eVZhbHVlc1tpXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBtaXhlZF92YXIgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChrZXkgaW4gbWl4ZWRfdmFyKSB7XG4gICAgICAvLyBJbmhlcml0ZWQgcHJvcGVydGllcyBjb3VudD9cbiAgICAgIC8vIGlmIChtaXhlZF92YXIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAvLyB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyogQW5vdGhlciB2ZXJzaW9uXG5cbndpbmRvdy5qUXVlcnkuaXNFbXB0eSA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXG4gIGlmKHR5cGVvZihkYXRhKSA9PSAnbnVtYmVyJyB8fCB0eXBlb2YoZGF0YSkgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmKHR5cGVvZihkYXRhKSA9PSAndW5kZWZpbmVkJyB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYodHlwZW9mKGRhdGEubGVuZ3RoKSAhPSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBkYXRhLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIHZhciBjb3VudCA9IDA7XG4gIGZvcih2YXIgaSBpbiBkYXRhKSB7XG4gICAgaWYoZGF0YS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgY291bnQgKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudCA9PT0gMDtcbn07XG4qL1xuXG5cbi8vIFZhbGlkYXRlIGUtbWFpbFxuXG4kLmlzRW1haWwgPSBmdW5jdGlvbiggZW1haWwgKSB7XG5cbiAgaWYgKCAkLmlzRW1wdHkoIGVtYWlsICkgKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHJlZ2V4ID0gL14oW2EtekEtWjAtOV8uKy1dKStcXEAoKFthLXpBLVowLTktXSkrXFwuKSsoW2EtekEtWjAtOV17Miw0fSkrJC87XG4gIHJldHVybiByZWdleC50ZXN0KGVtYWlsKTtcbn07XG5cbiIsIlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBTaGltIGZvcjogT2JqZWN0LmNyZWF0ZSBhbmQgT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gKlxuICovXG5cblxuLypqc2xpbnQgcHJvdG86IHRydWUgKi9cblxuLy8gTW9kaWZpZWQgZnJvbSBEb3VnbGFzIENyb2NrZm9yZCdzIE9iamVjdC5jcmVhdGUoKVxuLy8gVGhlIGNvbmRpdGlvbiBiZWxvdyBlbnN1cmVzIHdlIG92ZXJyaWRlIG90aGVyIG1hbnVhbCBpbXBsZW1lbnRhdGlvbnNcbmlmICghT2JqZWN0LmNyZWF0ZSB8fCBPYmplY3QuY3JlYXRlLnRvU3RyaW5nKCkuc2VhcmNoKC9uYXRpdmUgY29kZS9pKTwwKSB7XG4gIE9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbihvYmope1xuICAgIHZhciBBdXggPSBmdW5jdGlvbigpe307XG4gICAgJC5leHRlbmQoQXV4LnByb3RvdHlwZSwgb2JqKTsgLy8gc2ltcGx5IHNldHRpbmcgQXV4LnByb3RvdHlwZSA9IG9iaiBzb21laG93IG1lc3NlcyB3aXRoIGNvbnN0cnVjdG9yLCBzbyBnZXRQcm90b3R5cGVPZiB3b3VsZG4ndCB3b3JrIGluIElFXG4gICAgcmV0dXJuIG5ldyBBdXgoKTtcbiAgfTtcbn1cblxuLy8gTW9kaWZpZWQgZnJvbSBKb2huIFJlc2lnJ3MgT2JqZWN0LmdldFByb3RvdHlwZU9mKClcbi8vIFRoZSBjb25kaXRpb24gYmVsb3cgZW5zdXJlcyB3ZSBvdmVycmlkZSBvdGhlciBtYW51YWwgaW1wbGVtZW50YXRpb25zXG5pZiAoIU9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YudG9TdHJpbmcoKS5zZWFyY2goL25hdGl2ZSBjb2RlL2kpPDApIHtcbiAgaWYgKCB0eXBlb2YgXCJ0ZXN0XCIuX19wcm90b19fID09PSBcIm9iamVjdFwiICkge1xuICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gICAgICByZXR1cm4gb2JqZWN0Ll9fcHJvdG9fXztcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gICAgICAvLyBNYXkgYnJlYWsgaWYgdGhlIGNvbnN0cnVjdG9yIGhhcyBiZWVuIHRhbXBlcmVkIHdpdGhcbiAgICAgIHJldHVybiBvYmplY3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIH07XG4gIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogVGltZWQgZnVuY3Rpb25zXG4gKlxuICovXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cualF1ZXJ5IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5qUXVlcnkgOiBudWxsKTtcblxudmFyIHRpbWVycyA9IHt9LFxuICAgIGRlZmF1bHRJbnRlcnZhbCA9IDEwMDAwO1xuXG4kLmZuLnRpbWVkQ2xhc3MgPSBmdW5jdGlvbiggY2xhc3NOYW1lLCBkdXJhdGlvbiApIHtcblxuICB2YXIgJHNlbGYgPSAkKHRoaXMpO1xuXG4gIHJldHVybiAkKHRoaXMpLnRpbWVkRm4oXG4gICAgZnVuY3Rpb24oKXsgJHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApOyB9LFxuICAgIGZ1bmN0aW9uKCl7ICRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTsgfSxcbiAgICBkdXJhdGlvbiB8fCBkZWZhdWx0SW50ZXJ2YWxcbiAgKTtcbn07XG5cbiQuZm4udGltZWRUZXh0ID0gZnVuY3Rpb24oIHR4dCwgZHVyYXRpb24gKSB7XG5cbiAgdmFyICRzZWxmID0gJCh0aGlzKTtcblxuICByZXR1cm4gJCh0aGlzKS50aW1lZEZuKFxuICAgIGZ1bmN0aW9uKCl7ICRzZWxmLnRleHQoIHR4dCApOyB9LFxuICAgIGZ1bmN0aW9uKCl7ICRzZWxmLnRleHQoJycpOyB9LFxuICAgIGR1cmF0aW9uIHx8IGRlZmF1bHRJbnRlcnZhbFxuICApO1xufTtcblxuJC5mbi50aW1lZEZuID0gZnVuY3Rpb24oIGlkLCBzdGFydCwgZW5kLCBkdXJhdGlvbiApIHtcblxuICBkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IGRlZmF1bHRJbnRlcnZhbDtcblxuICAvLyBJRCBza2lwcGVkXG4gIGlmICggdHlwZW9mIGlkID09PSAnZnVuY3Rpb24nICkge1xuXG4gICAgZHVyYXRpb24gPSBlbmQgfHwgZHVyYXRpb247XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSBpZDtcblxuICAgIG5ldyBUaW1lcihmdW5jdGlvbigpe1xuICAgICAgZW5kKCk7XG4gICAgfSwgZHVyYXRpb24gKTtcblxuICAgIHJldHVybiBzdGFydCgpO1xuXG4gIC8vIElmIHRpbWVyIElEIGlzIHNldCBhbmQgb25lIGlzIGFscmVhZHkgZ29pbmcsIGFkZCB0byB0aGUgZHVyYXRpb25cbiAgfSBlbHNlIGlmICggdHlwZW9mIHRpbWVyc1tpZF0gIT09ICd1bmRlZmluZWQnICYmICEgdGltZXJzW2lkXS5maW5pc2hlZCApIHtcblxuICAgIHRpbWVyc1tpZF0uYWRkKCBkdXJhdGlvbiApO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB0aW1lcnNbaWRdID0gbmV3IFRpbWVyKGZ1bmN0aW9uKCl7XG4gICAgICBlbmQoKTtcbiAgICB9LCBkdXJhdGlvbiApO1xuXG4gICAgcmV0dXJuIHN0YXJ0KCk7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gVGltZXIoY2FsbGJhY2ssIHRpbWUpIHtcbiAgICB0aGlzLnNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWUpO1xufVxuXG5UaW1lci5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aW1lKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMudGltZSA9IHRpbWU7XG5cbiAgICBpZih0aGlzLnRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICB9XG4gICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHNlbGYuY2FsbGJhY2soKTtcbiAgICB9LCB0aW1lKTtcbiAgICB0aGlzLnN0YXJ0ID0gRGF0ZS5ub3coKTtcbn07XG5cblRpbWVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih0aW1lKSB7XG4gICBpZighdGhpcy5maW5pc2hlZCkge1xuICAgICAgIC8vIGFkZCB0aW1lIHRvIHRpbWUgbGVmdFxuICAgICAgIHRpbWUgPSB0aGlzLnRpbWUgLSAoRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnQpICsgdGltZTtcbiAgICAgICB0aGlzLnNldFRpbWVvdXQodGhpcy5jYWxsYmFjaywgdGltZSk7XG4gICB9XG59O1xuIiwiXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIHV0aWwuKlxuICpcbiAqIGlzQWdpbGl0eVxuICogcHJveHlBbGxcbiAqIHJldmVyc2VFdmVudHNcbiAqIHNpemVcbiAqIGV4dGVuZENvbnRyb2xsZXJcbiAqIFxuICovXG5cbi8qanNsaW50IGxvb3BmdW5jOiB0cnVlICovXG5cbnZhciB1dGlsID0ge30sXG4gICAgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmpRdWVyeSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwualF1ZXJ5IDogbnVsbCk7XG5cbi8vIENoZWNrcyBpZiBwcm92aWRlZCBvYmogaXMgYW4gYWdpbGl0eSBvYmplY3RcbnV0aWwuaXNBZ2lsaXR5ID0gZnVuY3Rpb24ob2JqKXtcbiByZXR1cm4gb2JqLl9hZ2lsaXR5ID09PSB0cnVlO1xufTtcblxuLy8gU2NhbnMgb2JqZWN0IGZvciBmdW5jdGlvbnMgKGRlcHRoPTIpIGFuZCBwcm94aWVzIHRoZWlyICd0aGlzJyB0byBkZXN0LlxuLy8gKiBUbyBlbnN1cmUgaXQgd29ya3Mgd2l0aCBwcmV2aW91c2x5IHByb3hpZWQgb2JqZWN0cywgd2Ugc2F2ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gYXMgXG4vLyAgIGEgJy5fcHJlUHJveHknIG1ldGhvZCBhbmQgd2hlbiBhdmFpbGFibGUgYWx3YXlzIHVzZSB0aGF0IGFzIHRoZSBwcm94eSBzb3VyY2UuXG4vLyAqIFRvIHNraXAgYSBnaXZlbiBtZXRob2QsIGNyZWF0ZSBhIHN1Yi1tZXRob2QgY2FsbGVkICdfbm9Qcm94eScuXG51dGlsLnByb3h5QWxsID0gZnVuY3Rpb24ob2JqLCBkZXN0KXtcbiAgaWYgKCFvYmogfHwgIWRlc3QpIHtcbiAgICB0aHJvdyBcImFnaWxpdHkuanM6IHV0aWwucHJveHlBbGwgbmVlZHMgdHdvIGFyZ3VtZW50c1wiO1xuICB9XG4gIGZvciAodmFyIGF0dHIxIGluIG9iaikge1xuICAgIHZhciBwcm94aWVkID0gb2JqW2F0dHIxXTtcbiAgICAvLyBQcm94eSByb290IG1ldGhvZHNcbiAgICBpZiAodHlwZW9mIG9ialthdHRyMV0gPT09ICdmdW5jdGlvbicgKSB7XG5cbiAgICAgIHByb3hpZWQgPSBvYmpbYXR0cjFdLl9ub1Byb3h5ID8gb2JqW2F0dHIxXSA6ICQucHJveHkob2JqW2F0dHIxXS5fcHJlUHJveHkgfHwgb2JqW2F0dHIxXSwgZGVzdCk7XG4gICAgICBwcm94aWVkLl9wcmVQcm94eSA9IG9ialthdHRyMV0uX25vUHJveHkgPyB1bmRlZmluZWQgOiAob2JqW2F0dHIxXS5fcHJlUHJveHkgfHwgb2JqW2F0dHIxXSk7IC8vIHNhdmUgb3JpZ2luYWxcbiAgICAgIG9ialthdHRyMV0gPSBwcm94aWVkO1xuXG4gICAgfVxuICAgIC8vIFByb3h5IHN1Yi1tZXRob2RzIChtb2RlbC4qLCB2aWV3LiosIGV0YykgLS0gZXhjZXB0IGZvciBqUXVlcnkgb2JqZWN0XG4gICAgZWxzZSBpZiAodHlwZW9mIG9ialthdHRyMV0gPT09ICdvYmplY3QnICYmICEob2JqW2F0dHIxXSBpbnN0YW5jZW9mIGpRdWVyeSkgKSB7XG4gICAgICBmb3IgKHZhciBhdHRyMiBpbiBvYmpbYXR0cjFdKSB7XG4gICAgICAgIHZhciBwcm94aWVkMiA9IG9ialthdHRyMV1bYXR0cjJdO1xuICAgICAgICBpZiAodHlwZW9mIG9ialthdHRyMV1bYXR0cjJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcHJveGllZDIgPSBvYmpbYXR0cjFdW2F0dHIyXS5fbm9Qcm94eSA/IG9ialthdHRyMV1bYXR0cjJdIDogJC5wcm94eShvYmpbYXR0cjFdW2F0dHIyXS5fcHJlUHJveHkgfHwgb2JqW2F0dHIxXVthdHRyMl0sIGRlc3QpO1xuICAgICAgICAgIHByb3hpZWQyLl9wcmVQcm94eSA9IG9ialthdHRyMV1bYXR0cjJdLl9ub1Byb3h5ID8gdW5kZWZpbmVkIDogKG9ialthdHRyMV1bYXR0cjJdLl9wcmVQcm94eSB8fCBvYmpbYXR0cjFdW2F0dHIyXSk7IC8vIHNhdmUgb3JpZ2luYWxcbiAgICAgICAgICBwcm94aWVkW2F0dHIyXSA9IHByb3hpZWQyO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvciBhdHRyMlxuICAgICAgb2JqW2F0dHIxXSA9IHByb3hpZWQ7XG4gICAgfSAvLyBpZiBub3QgZnVuY1xuICB9IC8vIGZvciBhdHRyMVxufTsgLy8gcHJveHlBbGxcblxuXG4vLyBEZXRlcm1pbmVzICMgb2YgYXR0cmlidXRlcyBvZiBnaXZlbiBvYmplY3QgKHByb3RvdHlwZSBpbmNsdXNpdmUpXG51dGlsLnNpemUgPSBmdW5jdGlvbihvYmope1xuICB2YXIgc2l6ZSA9IDAsIGtleTtcbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgc2l6ZSsrO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLy8gRmluZCBjb250cm9sbGVycyB0byBiZSBleHRlbmRlZCAod2l0aCBzeW50YXggJ34nKSwgcmVkZWZpbmUgdGhvc2UgdG8gZW5jb21wYXNzIHByZXZpb3VzbHkgZGVmaW5lZCBjb250cm9sbGVyc1xuLy8gRXhhbXBsZTpcbi8vICAgdmFyIGEgPSAkJCh7fSwgJzxidXR0b24+QTwvYnV0dG9uPicsIHsnY2xpY2sgJic6IGZ1bmN0aW9uKCl7IGFsZXJ0KCdBJyk7IH19KTtcbi8vICAgdmFyIGIgPSAkJChhLCB7fSwgJzxidXR0b24+QjwvYnV0dG9uPicsIHsnfmNsaWNrICYnOiBmdW5jdGlvbigpeyBhbGVydCgnQicpOyB9fSk7XG4vLyBDbGlja2luZyBvbiBidXR0b24gQiB3aWxsIGFsZXJ0IGJvdGggJ0EnIGFuZCAnQicuXG51dGlsLmV4dGVuZENvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgZm9yICh2YXIgY29udHJvbGxlck5hbWUgaW4gb2JqZWN0LmNvbnRyb2xsZXIpIHtcblxuICAgIC8vIG5ldyBzY29wZSBhcyB3ZSBuZWVkIG9uZSBuZXcgZnVuY3Rpb24gaGFuZGxlciBwZXIgY29udHJvbGxlclxuICAgIChmdW5jdGlvbigpe1xuICAgICAgdmFyIG1hdGNoZXMsIGV4dGVuZCwgZXZlbnROYW1lLFxuICAgICAgICAgIHByZXZpb3VzSGFuZGxlciwgY3VycmVudEhhbmRsZXIsIG5ld0hhbmRsZXI7XG5cbiAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmNvbnRyb2xsZXJbY29udHJvbGxlck5hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1hdGNoZXMgPSBjb250cm9sbGVyTmFtZS5tYXRjaCgvXihcXH4pKiguKykvKTsgLy8gJ2NsaWNrIGJ1dHRvbicsICd+Y2xpY2sgYnV0dG9uJywgJ19jcmVhdGUnLCBldGNcbiAgICAgICAgZXh0ZW5kID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgZXZlbnROYW1lID0gbWF0Y2hlc1syXTtcbiAgICAgIFxuICAgICAgICBpZiAoIWV4dGVuZCkgcmV0dXJuOyAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICAgICAgLy8gUmVkZWZpbmUgY29udHJvbGxlcjpcbiAgICAgICAgLy8gJ35jbGljayBidXR0b24nIC0tLT4gJ2NsaWNrIGJ1dHRvbicgPSBwcmV2aW91c0hhbmRsZXIgKyBjdXJyZW50SGFuZGxlclxuICAgICAgICBwcmV2aW91c0hhbmRsZXIgPSBvYmplY3QuY29udHJvbGxlcltldmVudE5hbWVdID8gKG9iamVjdC5jb250cm9sbGVyW2V2ZW50TmFtZV0uX3ByZVByb3h5IHx8IG9iamVjdC5jb250cm9sbGVyW2V2ZW50TmFtZV0pIDogdW5kZWZpbmVkO1xuICAgICAgICBjdXJyZW50SGFuZGxlciA9IG9iamVjdC5jb250cm9sbGVyW2NvbnRyb2xsZXJOYW1lXTtcbiAgICAgICAgbmV3SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChwcmV2aW91c0hhbmRsZXIpIHByZXZpb3VzSGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGlmIChjdXJyZW50SGFuZGxlcikgY3VycmVudEhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBvYmplY3QuY29udHJvbGxlcltldmVudE5hbWVdID0gbmV3SGFuZGxlcjtcbiAgICAgICAgZGVsZXRlIG9iamVjdC5jb250cm9sbGVyW2NvbnRyb2xsZXJOYW1lXTsgLy8gZGVsZXRlICd+Y2xpY2sgYnV0dG9uJ1xuICAgICAgfSAvLyBpZiBmdW5jdGlvblxuICAgIH0pKCk7XG4gIH0gLy8gZm9yIGNvbnRyb2xsZXJOYW1lXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG5cbiIsIlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiB3cC5hY3Rpb25cbiAqIFxuICogLSBnZXQsIHNhdmVcbiAqIC0gbG9naW4sIGxvZ291dCwgZ28sIHJlbG9hZFxuICpcbiAqL1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmpRdWVyeSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwualF1ZXJ5IDogbnVsbCk7XG52YXIgd3BBamF4ID0gcmVxdWlyZSgnLi9hamF4LmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gJC5leHRlbmQoIHdpbmRvdy53cC5hY3Rpb24gfHwge30sIHtcblxuICAvKipcbiAgICpcbiAgICogZ2V0KCBbdHlwZSxdIHsgcXVlcnkgfSApXG4gICAqIFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAgIENvbnRlbnQgdHlwZTogcG9zdHMsIHVzZXJzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBxdWVyeSAgUXVlcnkgYXJndW1lbnRzXG4gICAqIFxuICAgKiBAdG9kbyB0YXhvbm9teSwgY29tbWVudHNcbiAgICpcbiAgICovXG5cbiAgZ2V0IDogZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBEZWZhdWx0OiBnZXRfcG9zdHNcbiAgICB2YXIgdHlwZSA9ICdwb3N0cyc7XG5cbiAgICAvLyBGb3Igb3RoZXIgY29udGVudCB0eXBlczogZ2V0X3VzZXIsIGdldF90YXhvbm9teSwgLi4uXG4gICAgdmFyIG90aGVyVHlwZXMgPSBbICdwb3N0JywgJ3VzZXInLCAndXNlcnMnLCAndGF4b25vbXknLCAnZmllbGQnLCAnZmllbGRzJyBdO1xuXG4gICAgLy8gQ3JlYXRlIGFycmF5IG9mIGFyZ3VtZW50c1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIGlmICggYXJncy5sZW5ndGggPT09IDAgKVxuICAgICAgdGhyb3cgXCJ3cC5hY3Rpb24uZ2V0IG5lZWRzIGFuIG9iamVjdFwiO1xuXG4gICAgaWYgKCB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICB0eXBlID0gYXJnc1swXTtcbiAgICAgIGFyZ3Muc2hpZnQoKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0ID0gYXJnc1swXSB8fCB7fTtcbiAgICBzdWNjZXNzID0gYXJnc1sxXSB8fCB7fTtcbiAgICBlcnJvciA9IGFyZ3NbMl0gfHwge307XG5cbiAgICBpZiAoIHR5cGVvZiByZXF1ZXN0LnR5cGUgIT09ICd1bmRlZmluZWQnICYmICQuaW5BcnJheShyZXF1ZXN0LnR5cGUsIG90aGVyVHlwZXMpID4gLTEgKSB7XG4gICAgICB0eXBlID0gcmVxdWVzdC50eXBlO1xuICAgICAgZGVsZXRlIHJlcXVlc3QudHlwZTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3BBamF4KCAnZ2V0XycrdHlwZSwgcmVxdWVzdCwgc3VjY2VzcywgZXJyb3IgKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKlxuICAgKiBzYXZlKCBbdHlwZSxdIHsgZGF0YSB9IClcbiAgICogXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICAgQ29udGVudCB0eXBlOiBwb3N0LCB1c2VyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhICAgRGF0YVxuICAgKiBcbiAgICogQHRvZG8gdGF4b25vbXksIGNvbW1lbnRzLi5cbiAgICpcbiAgICovXG5cbiAgc2F2ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBGb3IgcG9zdCwgcGFnZSwgY3VzdG9tIHBvc3QgdHlwZTogc2F2ZV9wb3N0XG4gICAgdmFyIHR5cGUgPSAncG9zdCc7XG5cbiAgICAvLyBGb3Igb3RoZXIgY29udGVudCB0eXBlczogc2F2ZV91c2VyLCBzYXZlX3RheG9ub215LCAuLi5cbiAgICB2YXIgbm9uUG9zdFR5cGVzID0gWyAndXNlcicsICd1c2VycycsICd0YXhvbm9teScsICdmaWVsZCcsICdmaWVsZHMnIF07XG5cbiAgICAvLyBDcmVhdGUgYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgaWYgKCBhcmdzLmxlbmd0aCA9PT0gMCApXG4gICAgICB0aHJvdyBcIndwLmFjdGlvbi5zYXZlIG5lZWRzIGFuIG9iamVjdFwiO1xuXG4gICAgaWYgKCB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICB0eXBlID0gYXJnc1swXTtcbiAgICAgIGFyZ3Muc2hpZnQoKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0ID0gYXJnc1swXSB8fCB7fTtcbiAgICBzdWNjZXNzID0gYXJnc1sxXSB8fCB7fTtcbiAgICBlcnJvciA9IGFyZ3NbMl0gfHwge307XG5cbiAgICBpZiAoIHR5cGVvZiByZXF1ZXN0LnR5cGUgIT09ICd1bmRlZmluZWQnICYmICQuaW5BcnJheShyZXF1ZXN0LnR5cGUsIG5vblBvc3RUeXBlcykgPiAtMSApIHtcbiAgICAgIHR5cGUgPSByZXF1ZXN0LnR5cGU7XG4gICAgICBkZWxldGUgcmVxdWVzdC50eXBlO1xuICAgIH0gZWxzZSBpZiAoIHR5cGUgPT0gJ3Bvc3QnICYmICQuaXNBcnJheSggcmVxdWVzdCApICkge1xuICAgICAgdHlwZSA9ICdwb3N0cyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdwQWpheCggJ3NhdmVfJyt0eXBlLCByZXF1ZXN0LCBzdWNjZXNzLCBlcnJvciApO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqXG4gICAqIGxvZ2luLCBsb2dvdXQsIGdvLCByZWxvYWRcbiAgICpcbiAgICogQHRvZG8gcmVnaXN0ZXJcbiAgICpcbiAgICovXG5cblxuICBsb2dpbiA6IGZ1bmN0aW9uKCByZXF1ZXN0LCBzdWNjZXNzLCBlcnJvciApIHtcblxuICAgIHJldHVybiB3cEFqYXgoICdsb2dpbicsIHJlcXVlc3QsIHN1Y2Nlc3MsIGVycm9yICk7XG4gIH0sXG5cbiAgbG9nb3V0IDogZnVuY3Rpb24oIHJlZGlyZWN0ICkge1xuXG4gICAgdmFyIGxvZ291dCA9IHdwLnVybC5sb2dvdXQ7XG5cbiAgICBpZiAoIHR5cGVvZiByZWRpcmVjdCA9PT0gJ3VuZGVmaW5lZCcgKSByZWRpcmVjdCA9IHdwLmN1cnJlbnQucmVxdWVzdDtcblxuICAgIGxvZ291dCArPSAnJnJlZGlyZWN0X3RvPScrd3AudXJsLnNpdGUrcmVkaXJlY3Q7XG4gICAgbG9jYXRpb24uaHJlZiA9IGxvZ291dDtcbiAgfSxcblxuICBnbyA6IGZ1bmN0aW9uKCByb3V0ZSApIHtcbiAgICBsb2NhdGlvbi5ocmVmID0gd3AudXJsLnNpdGUrcm91dGU7XG4gIH0sXG5cbiAgcmVsb2FkIDogZnVuY3Rpb24oKSB7XG4gICAgbG9jYXRpb24uaHJlZiA9IHdwLmN1cnJlbnQudXJsO1xuICB9LFxuXG4gIC8qKlxuICAgKlxuICAgKiBlbWFpbFxuICAgKiBcbiAgICovXG5cbiAgbWFpbCA6IGZ1bmN0aW9uKCBtYWlsT2JqICkge1xuXG4gICAgLy8gRGVmYXVsdDogZ2V0X3Bvc3RzXG4gICAgdmFyIHR5cGUgPSAnbWFpbCc7XG5cbiAgICAvLyBDcmVhdGUgYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgaWYgKCBhcmdzLmxlbmd0aCA9PT0gMCApXG4gICAgICB0aHJvdyBcIndwLmFjdGlvbi5tYWlsIG5lZWRzIGFuIG9iamVjdFwiO1xuXG4gICAgcmVxdWVzdCA9IGFyZ3NbMF0gfHwge307XG4gICAgc3VjY2VzcyA9IGFyZ3NbMV0gfHwge307XG4gICAgZXJyb3IgPSBhcmdzWzJdIHx8IHt9O1xuXG4gICAgcmV0dXJuIHdwQWpheCggJ3NlbmRfZW1haWwnLCByZXF1ZXN0LCBzdWNjZXNzLCBlcnJvciApO1xuICB9XG5cblxufSk7XG5cbiIsIi8qIGdsb2JhbCB3cC5jdXJyZW50Lm5vbmNlLCB3cC51cmwuYWpheCAqL1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmpRdWVyeSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwualF1ZXJ5IDogbnVsbCk7XG5cbmZ1bmN0aW9uIHdwQWpheCggYWN0aW9uLCByZXF1ZXN0LCBzdWNjZXNzLCBlcnJvciApIHtcblxuICB2YXIgcmVxID0ge1xuICAgIHR5cGU6ICdQT1NUJyxcbiAgICB1cmw6IHdwLnVybC5hamF4LCAvLyBBSkFYIFVSTCBmcm9tIHNlcnZlci1zaWRlXG4gICAgZGF0YToge1xuICAgICAgYWN0aW9uOiAnYWdpbGl0eV8nK2FjdGlvbiwgLy8gUHJlZml4XG4gICAgICBub25jZTogd3AuY3VycmVudC5ub25jZSwgLy8gTm9uY2UgZnJvbSBzZXJ2ZXItc2lkZVxuICAgICAgZGF0YTogcmVxdWVzdCAvLyBUaGUgcmVhbCBkYXRhXG4gICAgfSxcbiAgICBiZWZvcmVTZW5kOiAnJyxcbiAgICBzdWNjZXNzOiAnJyxcbiAgICBlcnJvcjogJydcbiAgfTtcblxuICAvLyBCYXNlZCBvbiB3cC11dGlsLmpzXG4gIHJldHVybiAkLkRlZmVycmVkKCBmdW5jdGlvbiggZGVmZXJyZWQgKSB7XG5cbiAgICAvLyBUcmFuc2ZlciBzdWNjZXNzL2Vycm9yIGNhbGxiYWNrcy5cbiAgICBpZiAoIHN1Y2Nlc3MgKVxuICAgICAgZGVmZXJyZWQuZG9uZSggc3VjY2VzcyApO1xuICAgIGlmICggZXJyb3IgKVxuICAgICAgZGVmZXJyZWQuZmFpbCggZXJyb3IgKTtcblxuICAgIC8vIE9wdGlvbiB0byBmb3JjZSByZXR1cm4gZmFpbCBiZWZvcmUgQWpheCByZXF1ZXN0XG4gICAgaWYgKCBhY3Rpb24gPT09ICdmYWlsJyApXG4gICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblxuICAgIC8vIFVzZSB3aXRoIFBIUCdzIHdwX3NlbmRfanNvbl9zdWNjZXNzKCkgYW5kIHdwX3NlbmRfanNvbl9lcnJvcigpXG4gICAgJC5hamF4KCByZXEgKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cbiAgICAgIC8vIFRyZWF0IGEgcmVzcG9uc2Ugb2YgYDFgIGFzIHN1Y2Nlc3NmdWwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICBpZiAoIHJlc3BvbnNlID09PSAnMScgfHwgcmVzcG9uc2UgPT09IDEgKVxuICAgICAgICByZXNwb25zZSA9IHsgc3VjY2VzczogdHJ1ZSB9O1xuXG4gICAgICBpZiAoIHR5cGVvZiByZXNwb25zZS5kYXRhID09PSAndW5kZWZpbmVkJyApXG4gICAgICAgIHJlc3BvbnNlLmRhdGEgPSAnZW1wdHknO1xuXG4gICAgICBpZiAoIHR5cGVvZiByZXNwb25zZSA9PT0gJ29iamVjdCcgJiYgKCB0eXBlb2YgcmVzcG9uc2Uuc3VjY2VzcyAhPT0gJ3VuZGVmaW5lZCcgKSApXG4gICAgICAgIGRlZmVycmVkWyByZXNwb25zZS5zdWNjZXNzID8gJ3Jlc29sdmVXaXRoJyA6ICdyZWplY3RXaXRoJyBdKCB0aGlzLCBbcmVzcG9uc2UuZGF0YV0gKTtcbiAgICAgIGVsc2V7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdFdpdGgoIHRoaXMsIGFyZ3VtZW50cyApOyAvLyBbcmVzcG9uc2UuZGF0YV1cbiAgICAgIH1cbiAgICB9KS5mYWlsKCBmdW5jdGlvbigpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdFdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgIH0pO1xuICB9KS5wcm9taXNlKCk7XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cEFqYXg7XG5cblxuLyoqXG4gKiBTaGltIGZvciBcImZpeGluZ1wiIElFJ3MgbGFjayBvZiBzdXBwb3J0IChJRSA8IDkpIGZvciBhcHBseWluZyBzbGljZVxuICogb24gaG9zdCBvYmplY3RzIGxpa2UgTmFtZWROb2RlTWFwLCBOb2RlTGlzdCwgYW5kIEhUTUxDb2xsZWN0aW9uXG4gKiAodGVjaG5pY2FsbHksIHNpbmNlIGhvc3Qgb2JqZWN0cyBoYXZlIGJlZW4gaW1wbGVtZW50YXRpb24tZGVwZW5kZW50LFxuICogYXQgbGVhc3QgYmVmb3JlIEVTNiwgSUUgaGFzbid0IG5lZWRlZCB0byB3b3JrIHRoaXMgd2F5KS5cbiAqIEFsc28gd29ya3Mgb24gc3RyaW5ncywgZml4ZXMgSUUgPCA5IHRvIGFsbG93IGFuIGV4cGxpY2l0IHVuZGVmaW5lZFxuICogZm9yIHRoZSAybmQgYXJndW1lbnQgKGFzIGluIEZpcmVmb3gpLCBhbmQgcHJldmVudHMgZXJyb3JzIHdoZW5cbiAqIGNhbGxlZCBvbiBvdGhlciBET00gb2JqZWN0cy5cblxuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgX3NsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIHRyeSB7XG4gICAgLy8gQ2FuJ3QgYmUgdXNlZCB3aXRoIERPTSBlbGVtZW50cyBpbiBJRSA8IDlcbiAgICBfc2xpY2UuY2FsbChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICB9IGNhdGNoIChlKSB7IC8vIEZhaWxzIGluIElFIDwgOVxuICAgIC8vIFRoaXMgd2lsbCB3b3JrIGZvciBnZW51aW5lIGFycmF5cywgYXJyYXktbGlrZSBvYmplY3RzLCBcbiAgICAvLyBOYW1lZE5vZGVNYXAgKGF0dHJpYnV0ZXMsIGVudGl0aWVzLCBub3RhdGlvbnMpLFxuICAgIC8vIE5vZGVMaXN0IChlLmcuLCBnZXRFbGVtZW50c0J5VGFnTmFtZSksIEhUTUxDb2xsZWN0aW9uIChlLmcuLCBjaGlsZE5vZGVzKSxcbiAgICAvLyBhbmQgd2lsbCBub3QgZmFpbCBvbiBvdGhlciBET00gb2JqZWN0cyAoYXMgZG8gRE9NIGVsZW1lbnRzIGluIElFIDwgOSlcbiAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICAvLyBJRSA8IDkgZ2V0cyB1bmhhcHB5IHdpdGggYW4gdW5kZWZpbmVkIGVuZCBhcmd1bWVudFxuICAgICAgZW5kID0gKHR5cGVvZiBlbmQgIT09ICd1bmRlZmluZWQnKSA/IGVuZCA6IHRoaXMubGVuZ3RoO1xuXG4gICAgICAvLyBGb3IgbmF0aXZlIEFycmF5IG9iamVjdHMsIHdlIHVzZSB0aGUgbmF0aXZlIHNsaWNlIGZ1bmN0aW9uXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpID09PSAnW29iamVjdCBBcnJheV0nKXtcbiAgICAgICAgcmV0dXJuIF9zbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpOyBcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIGFycmF5IGxpa2Ugb2JqZWN0IHdlIGhhbmRsZSBpdCBvdXJzZWx2ZXMuXG4gICAgICB2YXIgaSwgY2xvbmVkID0gW10sXG4gICAgICAgIHNpemUsIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICAvLyBIYW5kbGUgbmVnYXRpdmUgdmFsdWUgZm9yIFwiYmVnaW5cIlxuICAgICAgdmFyIHN0YXJ0ID0gYmVnaW4gfHwgMDtcbiAgICAgIHN0YXJ0ID0gKHN0YXJ0ID49IDApID8gc3RhcnQ6IGxlbiArIHN0YXJ0O1xuXG4gICAgICAvLyBIYW5kbGUgbmVnYXRpdmUgdmFsdWUgZm9yIFwiZW5kXCJcbiAgICAgIHZhciB1cFRvID0gKGVuZCkgPyBlbmQgOiBsZW47XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICB1cFRvID0gbGVuICsgZW5kO1xuICAgICAgfVxuXG4gICAgICAvLyBBY3R1YWwgZXhwZWN0ZWQgc2l6ZSBvZiB0aGUgc2xpY2VcbiAgICAgIHNpemUgPSB1cFRvIC0gc3RhcnQ7XG5cbiAgICAgIGlmIChzaXplID4gMCkge1xuICAgICAgICBjbG9uZWQgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICAgIGlmICh0aGlzLmNoYXJBdCkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIGNsb25lZFtpXSA9IHRoaXMuY2hhckF0KHN0YXJ0ICsgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIGNsb25lZFtpXSA9IHRoaXNbc3RhcnQgKyBpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9O1xuICB9XG59KCkpO1xuICovXG5cbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==